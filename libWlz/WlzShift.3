.\" te
.\" ident MRC HGU $Id$
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.\" Project:    Woolz
.\" Title:      WlzShift.3
.\" Date:       December 1999
.\" Author:     Bill Hill
.\" Copyright:	1999 Medical Research Council, UK.
.\"		All rights reserved.
.\" Address:	MRC Human Genetics Unit,
.\"		Western General Hospital,
.\"		Edinburgh, EH4 2XU, UK.
.\" Purpose:    Woolz functions for shifting (applying integer
.\"		translations) to Woolz objects, domains and values.
.\" $Revision$
.\" Maintenance:Log changes below, with most recent at top of list.
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.nh
.TH "WlzShift" 3 "MRC HGU Woolz" "Woolz Procedure Library"
.SH NAME
WlzShift \- Woolz functions for shifting (applying integer translations) \
to Woolz objects, domains and values.
.SH SYNOPSIS
.LP
.B #include <Wlz.h>
.LP
.BI "WlzObject *WlzShiftObject(WlzObject *" inObj ,
.in +4m
.br
.BI "int " xShift ", int " yShift ", int " zShift ,
.br
.BI "WlzErrorNum *" wlzErr );
.in -4m
.LP
.BI "WlzDomain WlzShiftDomain(WlzObjectType " inObjType ,
.in +4m
.br
.BI "WlzDomain " inDom ,
.br
.BI "int " xShift ", int " yShift ", int " zShift ,
.br
.BI "WlzErrorNum *" wlzErr );
.in -4m
.LP
.BI "WlzValues WlzShiftValues(WlzObjectType " inObjType ,
.in +4m
.br
.BI "WlzValues " inVal ,
.BI "WlzDomain " inDom ,
.br
.BI "int " xShift ", int " yShift ", int " zShift ,
.br
.BI "WlzErrorNum *" wlzErr );
.in -4m
.SH ARGUMENTS
.TS
tab(^);
lI l.
inObj^Woolz object to be shifted.
inDom^Woolz domain to be shifted, or for values to be
^shifted.
inVal^Woolz values to be shifted.
inObjType^Woolz object type of object to be shifted, or
^parent object of values or domain to be shifted.
xShift^Increment for first column.
yShift^Increment for first line.
zShift^Increment for first plane.
wlzErr^Destination error code pointer, may be NULL.
.TE
.SH MT-LEVEL
.LP
Safe
.SH DESCRIPTION
.LP
.B WlzShiftObject
creates a new Woolz object which has it's domain and values shifted
by the given integer translation.
The domain and values are always created for the new object but if
the object has grey values then these are shared between the two objects.
.LP
.B WlzShiftDomain
creates a new Woolz domain which is shifted by the given integer translation.
The given object type is used to determine
the domain type and may be the type of the domain's parent object.
.LP
.B WlzShiftValues
creates a new shifted Woolz value table which shares any grey values
with the given value table.
The given object type is used to determine
the full type of the domain and values and may be the type of
the given value table's parent object.
.SH EXAMPLES
.LP
.ps -2
.cs B 24
.cs R 24
.nf

/* Simple example which reads a Woolz object from the standard
 * input, shifts it so that it's origin is at (0, 0, 0) and
 * then writes the shifted object to the standard output.
 */

#include <stdio.h>
#include <stdlib.h>
#include <Wlz.h>

int             main(char *argv[], int argc)
{
 int            xShift,
                yShift,
                zShift;
 WlzObject      *inObj = NULL,
                *outObj = NULL;
 WlzErrorNum   errNum = WLZ_ERR_NONE;

 if((inObj = WlzAssignObject(
             WlzReadObj(stdin,
                        &errNum), NULL)) == NULL)
 {
   (void )fprintf(stderr,
                  "%s: Failed to read object\\n",
                  *argv);
 }
 if(errNum == WLZ_ERR_NONE)
 {
   switch(inObj->type)
   {
     case WLZ_2D_DOMAINOBJ:
       if(inObj->domain.core == NULL)
       {
         errNum = WLZ_ERR_DOMAIN_NULL;
         (void )fprintf(stderr,
                        "%s: Input object has NULL domain\\n",
                        *argv);
       }
       else
       {
         xShift = -(inObj->domain.i->kol1);
         yShift = -(inObj->domain.i->line1);
         zShift = 0;
       }
       break;
     case WLZ_3D_DOMAINOBJ:
       if(inObj->domain.core == NULL)
       {
         errNum = WLZ_ERR_DOMAIN_NULL;
         (void )fprintf(stderr,
                        "%s: Input object has NULL domain\\n",
                        *argv);
       }
       else
       {
         xShift = -(inObj->domain.p->kol1);
         yShift = -(inObj->domain.p->line1);
         zShift = -(inObj->domain.p->plane1);
       }
       break;
     default:
       errNum = WLZ_ERR_OBJECT_TYPE;
       (void )fprintf(stderr,
                      "%s: Not a domain object\\n",
                      *argv);
   }
 }
 if(errNum == WLZ_ERR_NONE)
 {
   if((outObj = WlzShiftObject(inObj, xShift, yShift, zShift,
                               &errNum)) == NULL)
   {
     (void )fprintf(stderr,
                    "%s: Failed to shift object\\n",
                    *argv);
   }
 }
 if(inObj)
 {
   WlzFreeObj(inObj);
 }
 if(errNum == WLZ_ERR_NONE)
 {
   if((errNum = WlzWriteObj(stdout,
                            outObj)) != WLZ_ERR_NONE)
   {
     (void )fprintf(stderr,
                    "%s: Failed to write shifted object\\n",
                    *argv);
   }
 }
 if(outObj)
 {
   WlzFreeObj(outObj);
 }
 return(errNum);
}

.fi
.cs R
.cs B
.ps +2
.SH SEE ALSO
WlzAffineTransform(3),
WlzError(3)
.SH BUGS
Still to be found.
