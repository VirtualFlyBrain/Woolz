#pragma ident "MRC HGU $Id$"
/*!
* \file         libWlz/WlzMeshGen.c
* \author       Bill Hill
* \date         June 2003
* \version      $Id$
* \note
*               Copyright
*               2002 Medical Research Council, UK.
*               All rights reserved.
*               All rights reserved.
* \par Address:
*               MRC Human Genetics Unit,
*               Western General Hospital,
*               Edinburgh, EH4 2XU, UK.
* \brief	Functions for 2D and 3D conforming simplical mesh generation.
*		Meshes generated by these functions will conform approximately
*		to an objects boundaries.
* \bug          None known.
*/
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <Wlz.h>

/* #define WLZ_CMESH_DEBUG_MESH */
/* #define WLZ_CMESH_DEBUG_MAIN */

static void			WlzCMeshUpdateMaxSqEdgLen2D(
				  WlzCMesh2D *mesh);
static void			WlzCMeshUpdateBBox2D(
				  WlzCMesh2D *mesh);
static void			WlzCMeshAddNodToGrid2D(
				  WlzCMesh2D *mesh,
				  WlzCMeshNod2D *nod);
static void			WlzCMeshRemNodFromGrid2D(
				  WlzCMesh2D *mesh,
				  WlzCMeshNod2D *nod);
static void			WlzCMeshEntMarkFree(
				  int *idx);
static void			WlzCMeshElmsJoin2D(
				  WlzCMesh2D *mesh,
				  int nEdg,
				  WlzCMeshEdg2D **edg);
static void 			WlzCMeshRemEntCb2D(
				  WlzCMeshCbEntry **list,
				  WlzCMeshCbFn fn,
				  void *data);
static void			WlzCMeshEdgSetOpp2D(
				  WlzCMeshEdg2D *edg0,
				  WlzCMeshEdg2D *edg1);
static int			WlzCMeshCompLBTNodPos(
				  WlzDVertex2 *nPos,
				  WlzLBTDomain2D *lDom,
				  int idN,
				  WlzLBTNodeClass2D cls,
				  int rot);
static int			WlzCMeshElmWalkPos2D(
				  WlzCMesh2D *mesh,
				  int elmIdx,
				  WlzDVertex2 gPos);
static int			WlzCMeshElmJumpPos2D(
				  WlzCMesh2D *mesh,
				  WlzDVertex2 gPos);
static WlzErrorNum		WlzCMeshReassignBuckets(
				  WlzCMesh2D *mesh,
			          int newNumNod);
static WlzErrorNum 		WlzCMeshAddLBTNode2D(
				  WlzCMesh2D *mesh,
				  WlzLBTDomain2D *lDom,
				  WlzGreyValueWSpace *iGVWSp,
				  int idN);
static WlzErrorNum  		WlzCMeshSetElm2D(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D *elm,
				  WlzCMeshNod2D *nod0,
				  WlzCMeshNod2D *nod1,
				  WlzCMeshNod2D *nod2);
static WlzErrorNum 		WlzCMeshAddEntCb2D(
				  WlzCMeshCbEntry **list,
				  WlzCMeshCbFn fn,
				  void *data);
static WlzErrorNum 		WlzCMeshCallCallbacks(
				  void *meshP,
				  void *entP,
				  WlzCMeshCbEntry *entry);
static WlzErrorNum 		WlzCMeshElmFromLBTNode2D(
				  WlzCMesh2D *mesh,
				  WlzDVertex2 *nPos,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshEdg2D **mEdg,
				  WlzCMeshNod2D **mNod,
				  WlzLBTNodeClass2D cls,
				  int *dstNElm,
				  int *dstNEdg);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D0(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshEdg2D **mEdg,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm,
				  int *dstNEdg);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D1(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshEdg2D **mEdg,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm,
				  int *dstNEdg);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D2(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshEdg2D **mEdg,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm,
				  int *dstNEdg);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D3(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshEdg2D **mEdg,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm,
				  int *dstNEdg);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D4(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshEdg2D **mEdg,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm,
				  int *dstNEdg);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D5(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshEdg2D **mEdg,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm,
				  int *dstNEdg);
static WlzErrorNum 		WlzCMeshSetElmBoundaryFlagsBnd2D(
				  WlzCMesh2D *mesh,
				  WlzBoundList *bnd);
static WlzErrorNum 		WlzCMeshSetElmBoundaryFlagsPly2D(
				  WlzCMesh2D *mesh,
				  WlzPolygonDomain *ply);
static WlzIVertex2 		WlzCMeshBucketIdxVtx2D(
				  WlzCMesh2D *mesh,
				  WlzDVertex2 vtx);
static WlzCMeshNod2D 		*WlzCMeshAllocNod2D(
				  WlzCMesh2D *mesh);
static WlzCMeshNod3D 		*WlzCMeshAllocNod3D(
				  WlzCMesh3D *mesh);
static WlzCMeshElm2D 		*WlzCMeshAllocElm2D(
				  WlzCMesh2D *mesh);
static WlzCMeshElm3D 		*WlzCMeshAllocElm3D(
				  WlzCMesh3D *mesh);
static WlzCMeshEdg2D 		*WlzCMeshEdgFindOpp2D(
				  WlzCMeshEdg2D *gEdg);

/*!
* \return	New 2D mesh.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh data structure with the resources
*		optimized for the given number of mesh elements and nodes.
*		It is better to under estimate the number of elements and
*		nodes rather than over estimate and if zero is given some
*		reasonable defaults will be used.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMesh2D	*WlzCMeshNew2D(WlzErrorNum *dstErr)
{
  WlzCMesh2D	*mesh = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	blkSz = 1024;

  if(errNum == WLZ_ERR_NONE)
  {
    if((mesh = (WlzCMesh2D *)AlcCalloc(1, sizeof(WlzCMesh2D))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->type = WLZ_CMESH_TRI2D;
    if(((mesh->res.nod.vec = AlcVectorNew(1, sizeof(WlzCMeshNod2D),
    					  blkSz, NULL)) == NULL) ||
       ((mesh->res.elm.vec = AlcVectorNew(1, sizeof(WlzCMeshElm2D),
       					  blkSz, NULL)) == NULL))
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum != WLZ_ERR_NONE)
  {
    (void )WlzCMeshFree2D(mesh);
    mesh = NULL;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	New 3D mesh.
* \ingroup	WlzMesh
* \brief	Creates a new 3D mesh data structure with the resources
*		optimized for the given number of mesh elements and nodes.
*		It is better to under estimate the number of elements and
*		nodes rather than over estimate and if zero is given some
*		reasonable defaults will be used.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMesh3D	*WlzCMeshNew3D(WlzErrorNum *dstErr)
{
  WlzCMesh3D	*mesh = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	blkSz = 1024;

  if(errNum == WLZ_ERR_NONE)
  {
    if((mesh = (WlzCMesh3D *)AlcCalloc(1, sizeof(WlzCMesh3D))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->type = WLZ_CMESH_TET3D;
    if(((mesh->res.nod.vec = AlcVectorNew(1, sizeof(WlzCMeshNod3D),
    					  blkSz, NULL)) == NULL) ||
       ((mesh->res.elm.vec = AlcVectorNew(1, sizeof(WlzCMeshElm3D),
       					  blkSz, NULL)) == NULL))
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum != WLZ_ERR_NONE)
  {
    (void )WlzCMeshFree3D(mesh);
    mesh = NULL;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb2D(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb2D(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a deleted node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb2D(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a deleted element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb2D(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{

  WlzCMeshRemEntCb2D(&(mesh->res.nod.newEntCb), fn, data);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{

  WlzCMeshRemEntCb2D(&(mesh->res.elm.newEntCb), fn, data);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{

  WlzCMeshRemEntCb2D(&(mesh->res.nod.delEntCb), fn, data);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{

  WlzCMeshRemEntCb2D(&(mesh->res.elm.delEntCb), fn, data);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds an entity callback to the given callback list.
* \param	list			Given callback list.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
static WlzErrorNum WlzCMeshAddEntCb2D(WlzCMeshCbEntry **list, WlzCMeshCbFn fn,
				      void *data)
{
  WlzCMeshCbEntry *newCbE = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(list && fn)
  {
    if((newCbE = (WlzCMeshCbEntry *)
    		 AlcMalloc(sizeof(WlzCMeshCbEntry))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
    else
    {
      newCbE->fn = fn;
      newCbE->data = data;
      newCbE->next = *list;
      *list = newCbE;
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes an entity callback from the given callback list.
* \param	list			Given callback list.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
static void 	WlzCMeshRemEntCb2D(WlzCMeshCbEntry **list, WlzCMeshCbFn fn,
				   void *data)
{
  WlzCMeshCbEntry *cBE0,
  		*cBE1;

  if(list && ((cBE1 = *list) != NULL) && fn)
  {
    cBE0 = NULL;
    while((fn != cBE1->fn) && (data != cBE1->data) && cBE1->next)
    {
      cBE0 = cBE1;
      cBE1 = cBE1->next;
    }
    if((fn == cBE1->fn) && (data == cBE1->data))
    {
      if(cBE0)
      {
        cBE0->next = cBE1->next;
      }
      else
      {
        *list = NULL;
      }
      AlcFree(cBE1);
    }
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Calls all calbacks in the given list.
* \param	meshP			The mesh.
* \param	entP			The entity (node or element).
* \param	entry			Callback entry.
*/
static WlzErrorNum WlzCMeshCallCallbacks(void *meshP, void *entP,
				      WlzCMeshCbEntry *entry)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  while(entry && (errNum == WLZ_ERR_NONE))
  {
    if(entry->fn)
    {
      errNum = (*(entry->fn))(meshP, entP, entry->data);
    }
    entry = entry->next;
  }
  return(errNum);
}

/*!
* \return	New 2D mesh node.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh node at the given position. It is
*		assumed that a node does not already exist at the given
*		position but for efficiency this is not checked.
* \param	mesh			The mesh for resources.
* \param	pos			Position for the node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshNod2D	*WlzCMeshNewNod2D(WlzCMesh2D *mesh, WlzDVertex2 pos,
				  WlzErrorNum *dstErr)
{
  WlzCMeshNod2D	*nNod = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;


  if((nNod = WlzCMeshAllocNod2D(mesh)) == NULL)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  else
  {
    nNod->pos = pos;
    WlzCMeshAddNodToGrid2D(mesh, nNod);
  }
  if((errNum == WLZ_ERR_NONE) && mesh->res.nod.newEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nNod, mesh->res.nod.newEntCb);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nNod);
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Adds a new mesh node to the mesh's bucket grid.
*		It is assumed that the given node is not already in the
*		bucket grid but this is not checked for.
* \param	mesh			The mesh.
* \param	nod			New node to add.
*/
static void	WlzCMeshAddNodToGrid2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  WlzIVertex2	idx;
  WlzCMeshNod2D	**bktP;

  /* Find the bucket in the grid. */
  idx = WlzCMeshBucketIdxVtx2D(mesh, nod->pos);
  bktP = *(mesh->bGrid.buckets + idx.vtY) + idx.vtX;
  /* Add the node to the bucket. */
  nod->next = *bktP;
  *bktP = nod;
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Removes a mesh node from the mesh's bucket grid.
* \param	mesh			The mesh.
* \param	nod			New node to add.
*/
static void	WlzCMeshRemNodFromGrid2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  WlzCMeshNod2D	*nod0,
  		*nod1;
  WlzIVertex2	idx;
  WlzCMeshNod2D	**bktP;

  /* Find the bucket in the grid. */
  idx = WlzCMeshBucketIdxVtx2D(mesh, nod->pos);
  bktP = *(mesh->bGrid.buckets + idx.vtY) + idx.vtX;
  if(*bktP)
  {
    if(*bktP == nod)
    {
      *bktP = nod->next;
    }
    else
    {
      nod0 = *bktP;
      while(nod0)
      {
	nod1 = nod0->next;
	if(nod1 == nod)
	{
	  nod0->next = nod->next;
	  break;
	}
	nod0 = nod1;
      }
    }
  }
}

/*!
* \return	New 3D mesh node.
* \ingroup	WlzMesh
* \brief	Creates a new 3D mesh node at the given position. A node
*		must not already exist at this position.
* \param	mesh			The mesh for resources.
* \param	pos			Position for the node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshNod3D	*WlzCMeshNewNod3D(WlzCMesh3D *mesh, WlzDVertex3 pos,
				  WlzErrorNum *dstErr)
{
  WlzCMeshNod3D	*nNod = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;


  if((nNod = WlzCMeshAllocNod3D(mesh)) == NULL)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  else
  {
    nNod->pos = pos;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nNod);
}

/*!
* \return	New 2D mesh node or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D mesh node and sets it's index. 
*		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
* \param	dstErr			Destination error pointer, may be NULL.
*/
static WlzCMeshNod2D *WlzCMeshAllocNod2D(WlzCMesh2D *mesh)
{
  WlzCMeshEntRes	*nRes;
  WlzCMeshNod2D	*nod = NULL;
  
  nRes = &(mesh->res.nod);
  if((nod = (WlzCMeshNod2D *)
	    (AlcVectorExtendAndGet(nRes->vec, nRes->nextIdx))) != NULL)
  {
    ++(nRes->numEnt);
    ++(nRes->maxEnt);
    nod->idx = nRes->nextIdx++;
  }
  return(nod);
}

/*!
* \return	New 3D mesh node or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 3D mesh node and sets it's index. 
*		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
* \param	dstErr			Destination error pointer, may be NULL.
*/
static WlzCMeshNod3D *WlzCMeshAllocNod3D(WlzCMesh3D *mesh)
{
  WlzCMeshEntRes	*nRes;
  WlzCMeshNod3D	*nod = NULL;
  
  nRes = &(mesh->res.nod);
  if((nod = (WlzCMeshNod3D *)
	    (AlcVectorExtendAndGet(nRes->vec, nRes->nextIdx))) != NULL)
  {
    ++(nRes->numEnt);
    ++(nRes->maxEnt);
    nod->idx = nRes->nextIdx++;
  }
  return(nod);
}

/*!
* \return	New 2D mesh element.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh element connecting the given
*		mesh nodes but does not connect this new mesh element
*		to the rest of the mesh apart from changing the parent
*		edges of the mesh nodes.
* \param	mesh			The mesh for resources.
* \param	nod0			First mesh node.
* \param	nod1			Second mesh node.
* \param	nod2			Third mesh node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshElm2D 	*WlzCMeshNewElm2D(WlzCMesh2D *mesh,
				  WlzCMeshNod2D *nod0, WlzCMeshNod2D *nod1,
				  WlzCMeshNod2D *nod2, WlzErrorNum *dstErr)
{
  WlzCMeshElm2D	*nElm = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((nod0 == NULL) || (nod1 == NULL) || (nod2 == NULL))
  {
    errNum = WLZ_ERR_PARAM_NULL;
  }
  else
  {
    if((nElm = WlzCMeshAllocElm2D(mesh)) == NULL)
    {
      errNum == WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshSetElm2D(mesh, nElm, nod0, nod1, nod2);
  }
  if((errNum == WLZ_ERR_NONE) && mesh->res.nod.newEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nElm, mesh->res.elm.newEntCb);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nElm);
}

/*!
* \return	New 2D mesh element or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D mesh element and sets it's index. 
*		Internal edge connectivities are set.
* 		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
*/
static WlzCMeshElm2D *WlzCMeshAllocElm2D(WlzCMesh2D *mesh)
{
  WlzCMeshEntRes	*eRes;
  WlzCMeshElm2D	*elm = NULL;
  
  eRes = &(mesh->res.elm);
  if((elm = (WlzCMeshElm2D *)
	    (AlcVectorExtendAndGet(eRes->vec, eRes->nextIdx))) != NULL)
  {
    ++(eRes->numEnt);
    ++(eRes->maxEnt);
    elm->idx = eRes->nextIdx++;
    elm->edg[0].next = &(elm->edg[1]);
    elm->edg[1].next = &(elm->edg[2]);
    elm->edg[2].next = &(elm->edg[0]);
  }
  return(elm);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets up the edge and node connectivities within the given
*		2D mesh element. No opposites are changed.
*		The geometry of the element is checked to make sure that
*		it's area is greater than the mesh tolerance and that
*		the nodes are in CCW order. If this test fails an error
*		is returned.
* \param	mesh			The mesh.
* \param	elm			Given mesh element.
* \param	nod0			First mesh node of element.
* \param	nod1			Second mesh node of element.
* \param	nod2			Third mesh node of element.
*/
static WlzErrorNum  WlzCMeshSetElm2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm,
				     WlzCMeshNod2D *nod0, WlzCMeshNod2D *nod1,
				     WlzCMeshNod2D *nod2)
{
  int		idE,
  		idN;
  double	lenSq,
  		sA2;
  WlzCMeshEdg2D	*edg;
  WlzDVertex2	dsp;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  sA2 = WlzGeomTriangleSnArea2(nod0->pos, nod1->pos, nod2->pos);
  if(sA2 < WLZ_MESH_TOLERANCE_SQ)
  {
    /* Element either has a very small area or is CW. */
    errNum = WLZ_ERR_PARAM_DATA;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    elm->edg[0].nod = nod0;
    elm->edg[1].nod = nod1;
    elm->edg[2].nod = nod2;
    /* Set up all the adjacencies and check for maximum edge length. */
    for(idE = 0; idE < 3; ++idE)
    {
      idN = (idE + 1) % 3;
      edg = &(elm->edg[idE]);
      edg->elm = elm;
      edg->next = &(elm->edg[idN]);
      if(edg->nod->edg)
      {
        edg->nnxt = edg->nod->edg->nnxt;
	edg->nod->edg->nnxt = edg;
      }
      else
      {
        edg->nnxt = edg;
	edg->nod->edg = edg;
      }
      WLZ_VTX_2_SUB(dsp, elm->edg[idE].nod->pos, elm->edg[idN].nod->pos);
      lenSq = WLZ_VTX_2_SQRLEN(dsp);
      if(lenSq > mesh->maxSqEdgLen)
      {
        mesh->maxSqEdgLen = lenSq;
      }
    }
  }
  return(errNum);
}

/*!
* \return	New 3D mesh element or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 3D mesh element and sets it's index. 
* 		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
*/
static WlzCMeshElm3D *WlzCMeshAllocElm3D(WlzCMesh3D *mesh)
{
  WlzCMeshEntRes	*eRes;
  WlzCMeshElm3D	*elm = NULL;
  
  eRes = &(mesh->res.elm);
  if((elm = (WlzCMeshElm3D *)
	    (AlcVectorExtendAndGet(eRes->vec, eRes->nextIdx))) != NULL)
  {
    ++(eRes->numEnt);
    ++(eRes->maxEnt);
    elm->idx = eRes->nextIdx++;
  }
  return(elm);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's the 2D mesh, it's buckets, nodes and elements.
* \param	mesh			Mesh to free.
*/
WlzErrorNum	WlzCMeshFree2D(WlzCMesh2D *mesh)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzUnlink(&(mesh->linkcount), &errNum))
  {
    (void )AlcVectorFree(mesh->res.elm.vec);
    (void )AlcVectorFree(mesh->res.nod.vec);
    (void )Alc2Free((void **)(mesh->bGrid.buckets));
    AlcFree(mesh);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's the 3D mesh, it's buckets, nodes and elements.
* \param	mesh			Mesh to free.
*/
WlzErrorNum	WlzCMeshFree3D(WlzCMesh3D *mesh)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzUnlink(&(mesh->linkcount), &errNum))
  {
    (void )AlcVectorFree(mesh->res.elm.vec);
    (void )AlcVectorFree(mesh->res.nod.vec);
    (void )Alc3Free((void ***)(mesh->bGrid.buckets));
    AlcFree(mesh);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 2D mesh node. This function assumes that the node
*		is no longer used by any elements.
* \param	mesh			The mesh to which the element belongs.
* \param	nod			The given node.
*/
WlzErrorNum	WlzCMeshDelNod2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (nod == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((errNum == WLZ_ERR_NONE) && mesh->res.nod.delEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nod, mesh->res.nod.delEntCb);
  }
  else
  {
    WlzCMeshRemNodFromGrid2D(mesh, nod);
    WlzCMeshNodFree2D(mesh, nod);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 2D mesh element and any mesh nodes that are
*		used exclusively by this mesh element. 
* \param	mesh			The mesh to which the element belongs.
* \param	elm			The given element.
*/
WlzErrorNum	WlzCMeshDelElm2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm)
{
  int		idE;
  WlzCMeshEdg2D	*edg0,
  		*edg1,
		*edg2;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (elm == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((errNum == WLZ_ERR_NONE) && mesh->res.elm.delEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, elm, mesh->res.elm.delEntCb);
  }
  else
  {
    for(idE = 0; idE < 3; ++idE)
    {
      edg0 = &(elm->edg[idE]);
      if(edg0->opp)
      {
        edg0->opp->opp = NULL;
      }
      if(edg0 == edg0->nnxt)
      {
        (void )WlzCMeshDelNod2D(mesh, edg0->nod);
      }
      else
      {
        edg1 = edg0;
	edg2 = edg1->nnxt;
	while(edg2 != edg0)
	{
	  edg1 = edg2;
	  edg2 = edg2->nnxt;
	}
	edg1->nnxt = edg2->nnxt;
	edg1->nod->edg = edg1;
      }
    }
    WlzCMeshElmFree2D(mesh, elm);
  }
  return(errNum);
}

/*!
* \return	<void>
* \ingroup	WlzMesh
* \brief	Sets the index to indicate that the mesh entity is free.
* \param	idx			Entity index pointer.
*/
static void	WlzCMeshEntMarkFree(int *idx)
{
  if(*idx >= 0)
  {
    *idx = -(*idx + 1);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given 2D mesh node. Actually just sets the
*		node's index to mark it freed and then decrements
*		the number of mesh nodes.
* \param	mesh			Input mesh
* \param	nod			Given mesh node.
*/
void 		WlzCMeshNodFree2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  if(nod && (nod->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(nod->idx));
    --(mesh->res.nod.numEnt);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given 3D mesh node. Actually just sets the
*		node's index to mark it freed and then decrements
*		the number of mesh nodes.
* \param	mesh			Input mesh
* \param	nod			Given mesh node.
*/
void 		WlzCMeshNodFree3D(WlzCMesh3D *mesh, WlzCMeshNod3D *nod)
{
  if(nod && (nod->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(nod->idx));
    --(mesh->res.nod.numEnt);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given 2D mesh element. Actually just sets the
*		element's index to mark it freed and then decrements
*		the number of mesh elements.
* \param	mesh			Input mesh
* \param	elm			Given mesh element.
*/
void		WlzCMeshElmFree2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm)
{
  if(elm && (elm->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(elm->idx));
    --(mesh->res.elm.numEnt);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given 3D mesh element. Actually just sets the
*		element's index to mark it freed and then decrements
*		the number of mesh elements.
* \param	mesh			Input mesh
* \param	elm			Given mesh element.
*/
void		WlzCMeshElmFree3D(WlzCMesh3D *mesh, WlzCMeshElm3D *elm)
{
  if(elm && (elm->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(elm->idx));
    --(mesh->res.elm.numEnt);
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Affine transforms the node positions of the given mesh.
* \param	mesh			Given mesh.
* \param	tr			Affine transform.
*/
WlzErrorNum	WlzCMeshAffineTransformMesh2D(WlzCMesh2D *mesh,
					      WlzAffineTransform *tr)
{
  int		idN,
  		nNod;
  WlzCMeshNod2D	*nod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (tr == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzAffineTransformDimension(tr, NULL) != 2)
  {
    errNum = WLZ_ERR_TRANSFORM_TYPE;
  }
  else
  {
    /* Transform the nodes. */
    nNod = 0;
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	++nNod;
        nod->pos = WlzAffineTransformVertexD2(tr, nod->pos, NULL);
      }
    }
    /* Update the bounding box. */
    WlzCMeshUpdateBBox2D(mesh);
    /* Compute a new bucket grid and reassign nodes to it. */
    errNum = WlzCMeshReassignBuckets(mesh, nNod);
    /* Recompute maximum edge length. */
    WlzCMeshUpdateMaxSqEdgLen2D(mesh);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets the WLZ_CMESH_NOD_FLAG_OUTSIDE for nodes which
*		are outside the object's domain.
* \param	mesh			Given mesh.
* \param	obj			Object with domain to which the
*					mesh should conform.
*/
WlzErrorNum	WlzCMeshSetNodOutsideFlags2D(WlzCMesh2D *mesh,
					    WlzObject *obj)
{
  int		idN;
  WlzCMeshNod2D	*nod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(obj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else if((mesh == NULL) || (obj->domain.core == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if((nod->idx >= 0) &&
         (WlzInsideDomain(obj, 0.0, nod->pos.vtY, nod->pos.vtX, NULL) == 0))
      {
	nod->flags |= WLZ_CMESH_NOD_FLAG_OUTSIDE;
      }
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets the WLZ_CMESH_ELM_FLAG_BOUNDARY for elements which
*		intersect the object's boundary.
* \param	mesh			Given mesh.
* \param	obj			Object with domain to which the
*					mesh should conform.
*/
WlzErrorNum	WlzCMeshSetElmBoundaryFlags2D(WlzCMesh2D *mesh,
					      WlzObject *obj)
{
  WlzObject	*bObj = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  bObj = WlzObjToBoundary(obj, 1, &errNum);
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshSetElmBoundaryFlagsBnd2D(mesh, bObj->domain.b);
  }
  (void )WlzFreeObj(bObj);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets the WLZ_CMESH_ELM_FLAG_BOUNDARY for elements which
*		intersect the boundary.
* \param	mesh			Given mesh.
* \param	bnd			Boundary to which the mesh should
*					conform.
*/
static WlzErrorNum WlzCMeshSetElmBoundaryFlagsBnd2D(WlzCMesh2D *mesh,
					            WlzBoundList *bnd)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(bnd->poly)
  {
    errNum = WlzCMeshSetElmBoundaryFlagsPly2D(mesh, bnd->poly);
  }
  if((errNum == WLZ_ERR_NONE) && (bnd->next != NULL))
  {
    errNum = WlzCMeshSetElmBoundaryFlagsBnd2D(mesh, bnd->next);
  }
  if((errNum == WLZ_ERR_NONE) && (bnd->down != NULL))
  {
    errNum = WlzCMeshSetElmBoundaryFlagsBnd2D(mesh, bnd->down);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets the WLZ_CMESH_ELM_FLAG_BOUNDARY for elements which
*		intersect the polygon.
* \todo		If the position is on an edge or is at a node of the
* 		element then these elements which shares the edge or node
* 		and the position may not be marked as being on the boundary.
* \param	mesh			Given mesh.
* \param	bnd			Polygon to which the mesh should
*					conform.
*/
static WlzErrorNum WlzCMeshSetElmBoundaryFlagsPly2D(WlzCMesh2D *mesh,
					            WlzPolygonDomain *ply)
{
  int		idE,
  		idN;
  WlzObject	*obj8 = NULL;
  WlzCMeshElm2D	*elm;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  obj8 = WlzPolyTo8Polygon(ply, 0, &errNum);
  if(errNum == WLZ_ERR_NONE)
  {
    idE = -1;
    for(idN = 0; idN < obj8->domain.poly->nvertices; ++idN)
    {
      idE = WlzCMeshElmEnclosingPos2D(mesh, idE,
      				      (obj8->domain.poly->vtx + idN)->vtX,
      				      (obj8->domain.poly->vtx + idN)->vtY);
      if(idE >= 0)
      {
	/* Position is inside element. */
        elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
	elm->flags |= WLZ_CMESH_ELM_FLAG_BOUNDARY;
      }
      else
      {
        errNum = WLZ_ERR_DOMAIN_DATA;
	break;
      }
    }
  }
  (void )WlzFreeObj(obj8);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes all mesh elements which have all nodes flaged as
*		being outside the domain.
* \param	mesh			Given mesh.
*/
WlzErrorNum	WlzCMeshDelAllElmOutside2D(WlzCMesh2D *mesh)
{
  int		idE;
  WlzCMeshElm2D	*elm;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
    {
      elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
        if(((elm->flags & WLZ_CMESH_ELM_FLAG_BOUNDARY) == 0) &&
	   (((elm->edg[0].nod->flags | elm->edg[1].nod->flags | 
              elm->edg[2].nod->flags) & WLZ_CMESH_NOD_FLAG_OUTSIDE) != 0))
        {
	  (void )WlzCMeshDelElm2D(mesh, elm);
	}
      }
#ifdef WLZ_CMESH_DEBUG_MESH
      errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
#endif
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Checks that the 2D mesh has valid connectivities.
*		This function is slow and should only be used when
*		debugging mesh connectivities - it is not intended for
*		routine use. With an invalid mesh this checking function
*		may provoke NULL pointer access or segmentation faults.
* \param	mesh			Given mesh.
* \param	dstElm			Destination mesh element pointer
*					for last mesh element, may be NULL.
* \param	allErr			If non zero the checking conmtinues
*					after an error has been found, else if
*					zero the checking stops after the first
*					error has been found.
* \param	fP			Stream for diagnostic output
*					statements - may be NULL in which case
*					there will be no diagnostic output.
*/
WlzErrorNum 	WlzCMeshVerify2D(WlzCMesh2D *mesh, WlzCMeshElm2D **dstElm,
				 int allErr, FILE *fP)
{
  int		cnt,
  		idE,
  		idN;
  WlzCMeshEdg2D *edg0,
  		*edg1;
  WlzCMeshElm2D	*elm;
  WlzErrorNum	errNum0,
  		errNum1 = WLZ_ERR_NONE;
  const		nnxtLimit = 1000;
  char		msgBuf[1000];

  if(mesh == NULL)
  {
    errNum1 = WLZ_ERR_DOMAIN_NULL;
  }
  else if(mesh->type != WLZ_CMESH_TRI2D)
  {
    errNum1 = WLZ_ERR_DOMAIN_TYPE;
  }
  else
  {
    idE = 0;
    while((idE < mesh->res.elm.maxEnt) &&
          ((allErr == 0)  || (errNum1 == WLZ_ERR_NONE)))
    {
      /* Verify elements of mesh. */
      elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
	idN = 0;
	while((idN < 3) &&
	      ((allErr == 0)  || (errNum1 == WLZ_ERR_NONE)))
	{
	  errNum0 = WLZ_ERR_NONE;
	  /* Verify each edge of element. */
	  if(((allErr == 0)  || (errNum0 == WLZ_ERR_NONE)) &&
	     (elm->edg[idN].next != &(elm->edg[(idN + 1) % 3])))
	  {
	    errNum0 = WLZ_ERR_DOMAIN_DATA;
	    (void )sprintf(msgBuf,
	                   "elm[%d]->edg[%d].next != &(elm[%d]->edg[%d])",
			   idE, idN, idE, (idN + 1) % 3);
	  }
	  if(((allErr == 0)  || (errNum0 == WLZ_ERR_NONE)) &&
	     (elm->edg[idN].nod == NULL))
	  {
	    (void )sprintf(msgBuf,
	    		   "elm[%d]->edg[%d].nod == NULL",
			   idE, idN);
	    errNum0 = WLZ_ERR_DOMAIN_DATA;
	  }
	  if(((allErr == 0)  || (errNum0 == WLZ_ERR_NONE)) &&
	     (elm->edg[idN].nod->idx < 0))
	  {
	    errNum0 = WLZ_ERR_DOMAIN_DATA;
	    (void )sprintf(msgBuf,
	    		   "elm[%d]->edg[%d].nod->idx < 0",
			   idE, idN);
	  }
	  if(((allErr == 0)  || (errNum0 == WLZ_ERR_NONE)) &&
	     (elm->edg[idN].nod->edg->nod != elm->edg[idN].nod))
	  {
	    errNum0 = WLZ_ERR_DOMAIN_DATA;
	    (void )sprintf(msgBuf,
		"elm[%d]->edg[%d].nod->edg->nod != elm[%d]->edg[%d].nod",
		idE, idN, idE, idN);
	  }
	  if(((allErr == 0)  || (errNum0 == WLZ_ERR_NONE)) &&
	     ((elm->edg[idN].opp != NULL) &&
	     (elm->edg[idN].opp->opp != &(elm->edg[idN]))))
	  {
	    errNum0 = WLZ_ERR_DOMAIN_DATA;
	    (void )sprintf(msgBuf,
	    		   "elm[%d]->edg[%d].opp->opp != &(elm[%d]->edg[%d])",
			   idE, idN, idE, idN);
	  }
	  if((allErr == 0)  || (errNum0 == WLZ_ERR_NONE))
	  {
	    cnt = 0;
	    edg1 = edg0 = elm->edg[idN].nod->edg;
	    do
	    {
	      edg1 = edg1->nnxt;
	    }
	    while((cnt++ < nnxtLimit) && (edg1 != edg0));
	    if(cnt >= nnxtLimit)
	    {
	      errNum0 = WLZ_ERR_DOMAIN_DATA;
	      (void )sprintf(msgBuf,
			     "elm[%d]->edg[%d].nod->edg->nnxt cycle > %d",
			     idE, idN, nnxtLimit);
	    }
	  }
	  if(errNum1 == WLZ_ERR_NONE)
	  {
	    errNum1 = errNum0;
	  }
	  ++idN;
	}
	if((allErr == 0)  || (errNum1 == WLZ_ERR_NONE))
	{
	  if(WlzCMeshElmSnArea22D(elm) < WLZ_MESH_TOLERANCE_SQ)
	  {
	    errNum0 = WLZ_ERR_DOMAIN_DATA;
	    (void )sprintf(msgBuf,
	    		   "WlzCMeshElmSnArea22D(elm[%d]) < %g",
			   idE, WLZ_MESH_TOLERANCE_SQ);
	  }
	}
      }
      ++idE;
    }
  }
  if(dstElm)
  {
    *dstElm = elm;
  }
  return(errNum1);
}

/*!
* \return	Twice the signed area of the 2D mesh element.
* \ingroup	WlzMesh
* \brief	Computes twice the signed area of the 2D mesh element.
* \param	elm			Given mesh element.
*/
double		WlzCMeshElmSnArea22D(WlzCMeshElm2D *elm)
{
  double	area;

  area = WlzGeomTriangleSnArea2(elm->edg[0].nod->pos,
  			        elm->edg[1].nod->pos,
  				elm->edg[2].nod->pos);
  return(area);
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Updates the bounding box of the 2D conforming mesh.
* \param	mesh			The mesh.
*/
static void	WlzCMeshUpdateBBox2D(WlzCMesh2D *mesh)
{
  int		idN,
  		firstNod;
  WlzCMeshNod2D	*nod;
  WlzDBox2	bBox;

  /* Update the bounding box. */
  firstNod = 1;
  for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
  {
    nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
    if(nod->idx >= 0)
    {
      if(firstNod)
      {
	firstNod = 0;
	bBox.xMin = bBox.xMax = nod->pos.vtX;
	bBox.yMin = bBox.yMax = nod->pos.vtY;
      }
      else
      {
	if(nod->pos.vtX < bBox.xMin)
	{
	  bBox.xMin = nod->pos.vtX;
	}
	else if(nod->pos.vtX > bBox.xMax)
	{
	  bBox.xMax = nod->pos.vtX;
	}
	if(nod->pos.vtY < bBox.yMin)
	{
	  bBox.yMin = nod->pos.vtY;
	}
	else if(nod->pos.vtY > bBox.yMax)
	{
	  bBox.yMax = nod->pos.vtY;
	}
      }
    }
  }
  if(firstNod == 0)
  {
    mesh->bBox = bBox;
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Computes the mesh maximum edge length which is used to
*		terminate vertex location. This should not be allowed
*		to become less than the actual maximum edge length or
*		vertex location may fail, also if it is far larger than
*		the actual maximum edge length then vertex location
*		will be inefficient when vertices are outside the mesh.
* \param	mesh			The mesh.
*/
static void	WlzCMeshUpdateMaxSqEdgLen2D(WlzCMesh2D *mesh)
{
  int		idE;
  double	dSq;
  WlzCMeshElm2D	*elm;

  mesh->maxSqEdgLen = 0.0;
  for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
  {
    elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
    if(elm->idx >= 0)
    {
      dSq = WlzGeomDistSq2D(elm->edg[0].nod->pos, elm->edg[1].nod->pos);
      if(dSq > mesh->maxSqEdgLen)
      {
        mesh->maxSqEdgLen = dSq;
      }
      dSq = WlzGeomDistSq2D(elm->edg[1].nod->pos, elm->edg[2].nod->pos);
      if(dSq > mesh->maxSqEdgLen)
      {
        mesh->maxSqEdgLen = dSq;
      }
      dSq = WlzGeomDistSq2D(elm->edg[2].nod->pos, elm->edg[0].nod->pos);
      if(dSq > mesh->maxSqEdgLen)
      {
        mesh->maxSqEdgLen = dSq;
      }
    }
  }
}

/*!
* \return	Wlz error code.
* \ingroup	WlzMesh
* \brief	Allocates a new bucket grid and then reassigns the nodes
*		to the buckets.
* \param	mesh			The mesh.
* \param	mesh			New expected number of nodes.
*/
WlzErrorNum    WlzCMeshReassignBuckets(WlzCMesh2D *mesh, int newNumNod)
{
  int		idN;
  double	tD0;
  WlzIVertex2	bSz;
  WlzCMeshNod2D	*nod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const double	nodPerBucket = 4.0; /* TODO This is an efficiency tuning
  				       parameter which is to be determined. */

  /* This assumes that the mesh nodes will be evenly distributed over
   * the LBT domain (which they're not). */
  tD0 = nodPerBucket / (double)newNumNod;
  bSz.vtX = mesh->bBox.xMax - mesh->bBox.xMin; /* NOT + 1 */
  bSz.vtY = mesh->bBox.yMax - mesh->bBox.yMin; /* NOT + 1 */
  mesh->bGrid.nB.vtX = (int )ceil((double )(bSz.vtX) * sqrt(tD0)) + 1;
  mesh->bGrid.nB.vtY = (int )ceil((double )(bSz.vtY) * sqrt(tD0)) + 1;
  mesh->bGrid.bSz.vtX = (double )(bSz.vtX) /
			(double )(mesh->bGrid.nB.vtX);
  mesh->bGrid.bSz.vtY = (double )(bSz.vtY) /
			(double )(mesh->bGrid.nB.vtY);
   /* Reallocate the grid buckets. */
  Alc2Free((void **)(mesh->bGrid.buckets));
  if(AlcPtr2Calloc((void ***)&(mesh->bGrid.buckets),
		    mesh->bGrid.nB.vtY,
		    mesh->bGrid.nB.vtX) != ALC_ER_NONE)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  /* Add all the nodes to the grid buckets. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	nod->next = NULL;
	WlzCMeshAddNodToGrid2D(mesh, nod);
      }
    }
  }
  return(errNum);
}

/*!
* \return	Mesh grid bucket indices.
* \ingroup	WlzMesh
* \brief	Computes the mesh grid bucket indices for a given
*		vertex position.
* \param	mesh			The mesh.
* \param	vtx			Given vertex.
*/
static WlzIVertex2 WlzCMeshBucketIdxVtx2D(WlzCMesh2D *mesh, WlzDVertex2 vtx)
{
  WlzIVertex2	idx;

  idx.vtX = (int )floor((double )(vtx.vtX - mesh->bBox.xMin) /
  		        (double )(mesh->bGrid.bSz.vtX));
  idx.vtY = (int )floor((double )(vtx.vtY - mesh->bBox.yMin) /
  		        (double )(mesh->bGrid.bSz.vtY));
  idx.vtX = WLZ_CLAMP(idx.vtX, 0, mesh->bGrid.nB.vtX - 1);
  idx.vtY = WLZ_CLAMP(idx.vtY, 0, mesh->bGrid.nB.vtY - 1);
  return(idx);
}

/*!
* \return	Non zero if there is an existing node at the given position.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_CMESH_TOLERANCE distance) of
*		the given vertex. This function also gives access to the
*		grid bucket containing the node.
* \param	mesh			The mesh.
* \param	nPos			Given node position.
* \param	dstGPos			Destination pointer for the grid
*					position. Must not be NULL.
* \param	dstPrev			Destination pointer for the previous
*					node in the bucket's linked list,
*					which will be NULL if either the
*					bucket is empty or the matched node
*					is the first in the bucket. Must not
*					be NULL.
* \param	dstNod			Destination pointer for the matched
*					node which will be NULL if there
*					is no node at the given position.
*					Must not be NULL.
*/
int	 	WlzCMeshLocateNod2D(WlzCMesh2D *mesh, 
				    WlzDVertex2 nPos,
				    WlzIVertex2 *dstGPos,
				    WlzCMeshNod2D **dstPrev,
				    WlzCMeshNod2D **dstNod)
{
  int		found = 0;
  double	delta;
  WlzIVertex2	gPos;
  WlzIBox2	gBox;
  WlzCMeshNod2D	*nod,
  		*prev = NULL;
  const double	eps = 0.01;

  /* Search within a box of buckets because the vertex may be on the
   * edge of a bucket. */
  delta = eps * mesh->bGrid.bSz.vtX;
  gBox.xMin = (int )floor((double )(nPos.vtX - mesh->bBox.xMin - delta) /
                          (double )(mesh->bGrid.bSz.vtX));
  gBox.xMax = (int )floor((double )(nPos.vtX - mesh->bBox.xMin + delta) /
                          (double )(mesh->bGrid.bSz.vtX));
  delta = eps * mesh->bGrid.bSz.vtY;
  gBox.yMin = (int )floor((double )(nPos.vtY - mesh->bBox.yMin - delta) /
                         (double )(mesh->bGrid.bSz.vtY));
  gBox.yMax = (int )floor((double )(nPos.vtY - mesh->bBox.yMin + delta) /
                          (double )(mesh->bGrid.bSz.vtY));
  if(gBox.xMin < 0)
  {
    gBox.xMin= 0;
  }
  if(gBox.xMax >= mesh->bGrid.nB.vtX)
  {
    gBox.xMax = mesh->bGrid.nB.vtX - 1;
  }
  if(gBox.yMin < 0)
  {
    gBox.yMin = 0;
  }
  if(gBox.yMax >= mesh->bGrid.nB.vtY)
  {
    gBox.yMax = mesh->bGrid.nB.vtY - 1;
  }
  for(gPos.vtY = gBox.yMin; gPos.vtY <= gBox.yMax; ++gPos.vtY)
  {
    for(gPos.vtX = gBox.xMin; gPos.vtX <= gBox.xMax; ++gPos.vtX)
    {
      prev = NULL;
      nod = *(*(mesh->bGrid.buckets + gPos.vtY) + gPos.vtX);
      while(nod)
      {
        if(WlzGeomVtxEqual2D(nod->pos, nPos, WLZ_MESH_TOLERANCE_SQ))
        {
	  found = 1;
	  goto FOUND;
        }
	prev = nod;
        nod = nod->next;
      }
    }
  }
FOUND:
  *dstGPos = gPos;
  *dstPrev = prev;
  *dstNod = (found)? nod: NULL;
  return(found);
}

/*!
* \return	Matched node or NULL if no node is matched.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_CMESH_TOLERANCE distance) of
*		the given vertex.
* \param	mesh			The mesh.
* \param	nPos			Given vertex position.
*/
WlzCMeshNod2D 	*WlzCMeshMatchNod2D(WlzCMesh2D *mesh, WlzDVertex2 nPos)
{
  WlzIVertex2	gPos;
  WlzCMeshNod2D	*prev,
  		*mNod;

  (void )WlzCMeshLocateNod2D(mesh, nPos, &gPos, &prev, &mNod);
  return(mNod);
}

/*!
* \return	Number of matched nodes.
* \ingroup	WlzMesh
* \brief	Locates the nodes matching the given vertex positions.
*		The matched nodes are the mesh nodes which have the
*		same positions (within WLZ_CMESH_TOLERANCE distance) of
*		the given vertices.
* \param	mesh			The mesh.
* \param	nNod			Number of node positions to match.
* \param	nPos			Node positions.
* \param	mNod			Array for matched nodes.
*/
int		WlzCMeshMatchNNod2D(WlzCMesh2D *mesh, int nNod,
				    WlzDVertex2 *nPos, WlzCMeshNod2D **mNod)
{
  int		idN,
  		cnt = 0;

  for(idN = 0; idN < nNod; ++idN)
  {
    cnt += (*(mNod + idN) = WlzCMeshMatchNod2D(mesh, *(nPos + idN))) != NULL;
  }
  return(cnt);
}

/*!
* \return       Element index or negative value if there is no enclosing
*               element.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position.
*
*		If a valid last element index is given then a search is
*		made for the enclosing element both within this element
*		and then, if not found, within it's immediate edge
*		neighbours.
*		If this simple 'walk search' fails to locate the enclosing
*		element a 'jump search' is used in which the grid buckets
*		of the conforming mesh are searched.
* \param        mesh			The mesh.
* \param        lastElmIdx		Last element index to help efficient
* 					location. If negative this is ignored.
* \param        pX			Column coordinate of position.
* \param        pY			Line coordinate of position.
*/
int             WlzCMeshElmEnclosingPos2D(WlzCMesh2D *mesh,
                                        int lastElmIdx,
                                        double pX, double pY)
{
  WlzDVertex2	gPos;
  int           elmIdx = -1;

  gPos.vtX = pX;
  gPos.vtY = pY;
  if(lastElmIdx >= 0)
  {
    elmIdx = WlzCMeshElmWalkPos2D(mesh, lastElmIdx, gPos);
  }
  if(elmIdx < 0)
  {
    elmIdx = WlzCMeshElmJumpPos2D(mesh, gPos);
  }
  return(elmIdx);
}

/*!
* \return	Element index or negative value if no enclosing element found.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position by testing the given element and it's
*		immediate edge neighbours.
* \param	mesh			The mesh.
* \param	elmIdx			Index of first element to test.
* \param	gPos			Test position.
*/
static int	WlzCMeshElmWalkPos2D(WlzCMesh2D *mesh, int elmIdx,
				     WlzDVertex2 gPos)
{
  int		idE;
  WlzCMeshElm2D	*elm0,
  		*elm1;

  if((elmIdx >= 0) && (elmIdx < mesh->res.elm.maxEnt))
  {
    elm0 = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, elmIdx);
    if(WlzCMeshElmEnclosesPos2D(elm0, gPos) == 0)
    {
      elmIdx = -1;
      for(idE = 0; idE < 3; ++idE)
      {
	if(elm0->edg[idE].opp)
	{
	  elm1 = elm0->edg[idE].opp->elm;
	  if(WlzCMeshElmEnclosesPos2D(elm1, gPos) != 0)
	  {
	    elmIdx = elm1->idx;
	    break;
	  }
	}
      }
    }
  }
  return(elmIdx);
}

/*!
* \return	Index of the enclosing element or < 0 if no enclosing
*		element is found.
* \ingroup	WlzMesh
* \brief	Searches for the conforming mesh element which encloses
*		the given position by jumping to the corresponding grid
*		bucket and then spiraling out from this grid bucket until
*		the maximum search distance is reached. For each of the
*		grid buckets - all the elements of it's nodes are searched.
*		The search terminates either when the enclosing element
*		is found or when the maximum search distance is reached.
* \param	mesh			The conforming  mesh.
* \param	gPos			Given position.
*/
static int	WlzCMeshElmJumpPos2D(WlzCMesh2D *mesh, WlzDVertex2 gPos)
{
  int		spiralCnt = 0,
  		elmIdx = -1;
  double	d0,
  		d1;
  WlzDVertex2	bPos;
  WlzIVertex2	idB;
  double	dstSq = 0.0;
  WlzCMeshNod2D	*nod;
  WlzCMeshEdg2D	*edg;
  WlzCMeshNod2D	**bktP;

  /* Compute extra distance to allow for search within circle rather than
   * rectangle: \f$h = \sqrt{d_0^2 + d_1^2} - d_1\f$, where \f$d_0\f$ and
   * \f$d_1\f$ are twice the maximum and minimum grid buckect cell dimensions
   * respectively. */
  if(mesh->bGrid.bSz.vtX > mesh->bGrid.bSz.vtY)
  {
    d0 = mesh->bGrid.bSz.vtX * 0.5;
    d1 = mesh->bGrid.bSz.vtY * 0.5;
  }
  else
  {
    d0 = mesh->bGrid.bSz.vtY * 0.5;
    d1 = mesh->bGrid.bSz.vtX * 0.5;
  }
  d0 = sqrt((d0 * d0) + (d1 * d1)) - d1; /* This is the extra distance. */
  /* Find the grid bucket which contains the position. */
  idB = WlzCMeshBucketIdxVtx2D(mesh, gPos);
  do
  {
    bktP = *(mesh->bGrid.buckets + idB.vtY) + idB.vtX;
    /* for each node in the grid bucket. */
    nod = *bktP;
    while(nod)
    {
      edg = nod->edg;
      do
      {
	if(WlzCMeshElmEnclosesPos2D(edg->elm, gPos))
	{
	  elmIdx = edg->elm->idx;
	  goto FOUND;
	}
	if(edg->opp && WlzCMeshElmEnclosesPos2D(edg->opp->elm, gPos))
	{
	  elmIdx = edg->opp->elm->idx;
	  goto FOUND;
	}
	edg = edg->nnxt;
      }
      while(edg != nod->edg);
      nod = nod->next;
    }
    /* Spiral out from the initial grid bucket. */
    spiralCnt = WlzGeomItrSpiral2I(spiralCnt, &(idB.vtX), &(idB.vtY));
    /* Compute squared distance from the position to the closest vertex
     * of the grid bucket's cell, then subtract the extra distance to
     * account for search in circle rather than rectangle.  If the
     * resulting squared distance is greater than the maximum square
     * edge length then stop searching. */
    bPos.vtX = mesh->bBox.xMin + (mesh->bGrid.bSz.vtX * (idB.vtX + 0));
    bPos.vtY = mesh->bBox.yMin + (mesh->bGrid.bSz.vtY * (idB.vtY + 0));
    dstSq = WlzGeomDistSq2D(gPos, bPos);
    bPos.vtX = mesh->bBox.xMin + (mesh->bGrid.bSz.vtX * (idB.vtX + 1));
    bPos.vtY = mesh->bBox.yMin + (mesh->bGrid.bSz.vtY * (idB.vtY + 0));
    d1 = WlzGeomDistSq2D(gPos, bPos);
    if(d1 < dstSq)
    {
      dstSq = d1;
    }
    bPos.vtX = mesh->bBox.xMin + (mesh->bGrid.bSz.vtX * (idB.vtX + 0));
    bPos.vtY = mesh->bBox.yMin + (mesh->bGrid.bSz.vtY * (idB.vtY + 1));
    d1 = WlzGeomDistSq2D(gPos, bPos);
    if(d1 < dstSq)
    {
      dstSq = d1;
    }
    bPos.vtX = mesh->bBox.xMin + (mesh->bGrid.bSz.vtX * (idB.vtX + 1));
    bPos.vtY = mesh->bBox.yMin + (mesh->bGrid.bSz.vtY * (idB.vtY + 1));
    d1 = WlzGeomDistSq2D(gPos, bPos);
    if(d1 < dstSq)
    {
      dstSq = d1;
    }
  } while((dstSq  - d0) < mesh->maxSqEdgLen);
FOUND:
  return(elmIdx);
}

int		WlzCMeshElmEnclosesPos2D(WlzCMeshElm2D *elm, WlzDVertex2 gPos)
{
  int		inside = 0;

  inside = WlzGeomVxInTriangle(elm->edg[0].nod->pos, elm->edg[1].nod->pos,
                               elm->edg[2].nod->pos, gPos) >= 0;
  return(inside);
}

/*!
* \return	New mesh or NULL on error.
* \ingroup	WlzMesh
* \brief	Constructs a 2D mesh from a 2D domain object.
*		Because of the difficulty in computing a mesh which conforms
*		to the domain of the given object, the resulting mesh will
*		instead cover the given domain with some nodes of the
*		mesh outside the given domain. All mesh nodes will however
*		be within the dilated domain, where the dilation is by a sphere
*		of radius twice the minimum element size.
* \param	obj			Given domain object.
* \param	minElmSz		Minimum element size.
* \param	maxElmSz		Minimum element size.
* \param	dstDilObj		Destination pointer for the dilated
*					object used to build the mesh.
* \param	dstErr			Destination error pointer may be NULL.
*/
WlzCMesh2D	*WlzCMeshFromObj2D(WlzObject *obj,
				   double minElmSz, double maxElmSz,
				   WlzObject **dstDilObj,
				   WlzErrorNum *dstErr)
{
  int		scale,
  		maxLBTNdSz;
  double	invScale;
  WlzCMesh2D	*mesh = NULL;
  WlzLBTDomain2D *lDom = NULL;
  WlzObject	*dilObj = NULL,
  		*idxObj = NULL,
  		*sclObj = NULL,
		*strObj = NULL,
		*tmpObj = NULL;
  WlzAffineTransform *tr = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	maxBndNdSz = 1;

  if(obj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else if(obj->type != WLZ_2D_DOMAINOBJ)
  {
    errNum = WLZ_ERR_OBJECT_TYPE;
  }
  else if(obj->domain.core == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(minElmSz < 1.0)
  {
    errNum = WLZ_ERR_PARAM_DATA;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    if(minElmSz < 1.0)
    {
      minElmSz = 1.0;
    }
    scale = (int )ceil(minElmSz);
    maxLBTNdSz = (int )ceil(maxElmSz / minElmSz);
    if(maxLBTNdSz < 1)
    {
      maxLBTNdSz = 1;
    }
    invScale = 1.0 / scale;
    strObj = WlzMakeSphereObject(WLZ_2D_DOMAINOBJ, ceil((3.0 * scale) + 1.0),
				 0.0, 0.0, 0.0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    dilObj = WlzStructDilation(obj, strObj, &errNum);
  }
  (void )WlzFreeObj(strObj); strObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    tr = WlzMakeAffineTransform(WLZ_TRANSFORM_2D_AFFINE, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    (void )WlzAffineTransformScaleSet(tr, invScale, invScale, invScale);
    sclObj = WlzAffineTransformObj(dilObj, tr, WLZ_INTERPOLATION_NEAREST,
				   &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    lDom = WlzLBTDomain2DFromDomain(sclObj->domain, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    idxObj = WlzLBTMakeNodeIndexObj2D(lDom, sclObj->domain.i, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzLBTBalanceDomain2D(lDom, idxObj, maxLBTNdSz, 0);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzLBTIndexObjSetAllNodes2D(lDom, idxObj);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh = WlzCMeshFromBalLBTDom2D(lDom, idxObj, &errNum);
  }
  WlzFreeObj(idxObj); idxObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    (void )WlzAffineTransformScaleSet(tr, scale, scale, scale);
    errNum = WlzCMeshAffineTransformMesh2D(mesh, tr);
  }
  WlzFreeObj(dilObj); dilObj = NULL;
  if((errNum == WLZ_ERR_NONE) && dstDilObj)
  {
    dilObj = WlzAffineTransformObj(sclObj, tr, WLZ_INTERPOLATION_NEAREST,
    				   &errNum);
    *dstDilObj = dilObj;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshSetNodOutsideFlags2D(mesh, obj);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshSetElmBoundaryFlags2D(mesh, obj);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshDelAllElmOutside2D(mesh);
  }
  (void )WlzFreeObj(sclObj);
  (void )WlzFreeAffineTransform(tr);
  (void )WlzFreeLBTDomain2D(lDom);
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	New mesh or NULL on error.
* \ingroup	WlzMesh
* \brief	Constructs a 3D mesh from a 3D domain object.
* \param	obj			Given domain object.
* \param	dstErr			Destination error pointer may be NULL.
*/
WlzCMesh3D	*WlzCMeshFromObj3D(WlzObject *obj, WlzErrorNum *dstErr)
{
  WlzCMesh3D	*mesh = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(obj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else if(obj->type != WLZ_3D_DOMAINOBJ)
  {
    errNum = WLZ_ERR_OBJECT_TYPE;
  }
  else if(obj->domain.core == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    errNum = WLZ_ERR_UNIMPLEMENTED;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return       New mesh or NULL on error.
* \ingroup      WlzMesh
* \brief        Constructs a 2D mesh from a balanced 2D linear binary
*		tree domain.
* \param	lDom			Linear binary tree domain.
* \param	iObj			Index object for lDom.
* \param        dstErr			Destination error pointer may be NULL.
*/
WlzCMesh2D	*WlzCMeshFromBalLBTDom2D(WlzLBTDomain2D *lDom, WlzObject *iObj,
				         WlzErrorNum *dstErr)
{
  int		idN;
  WlzIVertex2	bSz;
  WlzCMesh2D	*mesh = NULL;
  WlzGreyValueWSpace *iGVWSp = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(lDom == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(iObj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else
  {
    mesh = WlzCMeshNew2D(&errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    iGVWSp = WlzGreyValueMakeWSp(iObj, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->bBox.xMin = lDom->kol1;
    mesh->bBox.yMin = lDom->line1;
    mesh->bBox.xMax = lDom->lastkl;
    mesh->bBox.yMax = lDom->lastln;
    bSz.vtX = mesh->bBox.xMax - mesh->bBox.xMin; /* NOT + 1 */
    bSz.vtY = mesh->bBox.yMax - mesh->bBox.yMin; /* NOT + 1 */
    if((lDom->nNodes <= 0) || (bSz.vtX <= 0) || (bSz.vtY <= 0))
    {
      errNum = WLZ_ERR_DOMAIN_DATA;
    }
  }
  /* Create an initial grid of buckets. */
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshReassignBuckets(mesh, lDom->nNodes * 4);
  }
  /* Add the LBT nodes to the mesh. */
  if(errNum == WLZ_ERR_NONE)
  {
    idN = 0;
    while((errNum == WLZ_ERR_NONE) && (idN < lDom->nNodes))
    {
      errNum = WlzCMeshAddLBTNode2D(mesh, lDom, iGVWSp, idN);
      ++idN;
    }
  }
  /* Free temporary storage. */
  WlzGreyValueFreeWSp(iGVWSp);
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return       Woolz error code.
* \ingroup      WlzMesh
* \brief        Adds a balanced LBT node to a 2D mesh.
* \param	mesh			The mesh.
* \param	lDom			Linear binary tree domain.
* \param	iGVWSp			Grey workspace for index object.
* \param        idN			Index of the LBT node.
*/
static WlzErrorNum WlzCMeshAddLBTNode2D(WlzCMesh2D *mesh, WlzLBTDomain2D *lDom,
				        WlzGreyValueWSpace *iGVWSp, int idN)
{
  int		rot,
  		nElm,
		nEdg,
		nNod;
  WlzLBTNodeClass2D cls;
  WlzDVertex2	nPos[8];
  WlzCMeshEdg2D	*mEdg[8];
  WlzCMeshNod2D	*mNod[8];
  WlzCMeshElm2D	*mElm[6];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Classify the LBT node. */
  WlzLBTClassifyNode2D(lDom, iGVWSp, idN, &cls, &rot);
  /* Compute mesh node positions. */
  nNod = WlzCMeshCompLBTNodPos(nPos, lDom, idN,  cls, rot);
  /* Match mesh nodes to computed positions. */
  (void )WlzCMeshMatchNNod2D(mesh, nNod, nPos, mNod);
  /* Create nodes that don't already exist. */
  for(idN = 0; idN < nNod; ++idN)
  {
    if(mNod[idN] == NULL)
    {
      mNod[idN] = WlzCMeshNewNod2D(mesh, nPos[idN], &errNum);
      if(errNum != WLZ_ERR_NONE)
      {
        break;
      }
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    /* Create new mesh elements. */
    errNum = WlzCMeshElmFromLBTNode2D(mesh, nPos, mElm, mEdg, mNod, cls,
    				     &nElm, &nEdg);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    /* Join the edge of the new mesh elements to the rest of the mesh
     * using their opp links. */
    WlzCMeshElmsJoin2D(mesh, nEdg, mEdg);
  }
#ifdef WLZ_CMESH_DEBUG_MESH
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return	Number of nodes for the given LBT domain node.
* \ingroup	WlzMesh
* \brief	Computes the positions of the mesh nodes for the given
*		LBT domain node.
* \param	nPos			Array for node positions.
* \param	lDom			LBT domain.
* \param	idN			Index of LBT node.
* \param	cls			LBT node adjacency class.
* \param	rot			LBT node rotation from class.
*/
static int	WlzCMeshCompLBTNodPos(WlzDVertex2 *nPos, WlzLBTDomain2D *lDom,
				      int idN,  WlzLBTNodeClass2D cls, int rot)
{
  int		nNod = 0;
  double	tD0,
  		hWidth,
		width;
  WlzIVertex2	lPos;

  /* Compute LBT node's position and size / 2. */
  WlzLBTKeyToPos2I((lDom->nodes + idN)->keys, &lPos);
  width = (double )WlzLBTNodeSz2D(lDom->nodes + idN);
  hWidth = width / 2.0;
  /* Set relative mesh node positions without rotation or offset. */
  switch(cls)
  {
    case WLZ_LBT_NODE_CLASS_2D_0:
      nNod  = 4;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = width;  nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = width;
      nPos[3].vtX = 0.0;    nPos[3].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_1:
      nNod  = 5;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = width;  nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = width;
      nPos[3].vtX = hWidth; nPos[3].vtY = width;
      nPos[4].vtX = 0.0;    nPos[4].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_2:
      nNod  = 6;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = width;  nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = hWidth;
      nPos[3].vtX = width;  nPos[3].vtY = width;
      nPos[4].vtX = hWidth; nPos[4].vtY = width;
      nPos[5].vtX = 0.0;    nPos[5].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_3:
      nNod  = 6;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = hWidth; nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = 0.0;
      nPos[3].vtX = width;  nPos[3].vtY = width;
      nPos[4].vtX = hWidth; nPos[4].vtY = width;
      nPos[5].vtX = 0.0;    nPos[5].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_4:
      nNod  = 7;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = hWidth; nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = 0.0;
      nPos[3].vtX = width;  nPos[3].vtY = hWidth;
      nPos[4].vtX = width;  nPos[4].vtY = width;
      nPos[5].vtX = hWidth; nPos[5].vtY = width;
      nPos[6].vtX = 0.0;    nPos[6].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_5:
      nNod  = 8;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = hWidth; nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = 0.0;
      nPos[3].vtX = width;  nPos[3].vtY = hWidth;
      nPos[4].vtX = width;  nPos[4].vtY = width;
      nPos[5].vtX = hWidth; nPos[5].vtY = width;
      nPos[6].vtX = 0.0;    nPos[6].vtY = width;
      nPos[7].vtX = 0.0;    nPos[7].vtY = hWidth;
      break;
  }
  /* Rotate the mesh nodes adding the offset from the LBT node's position. */
  switch(rot)
  {
    case 0:
      for(idN = 0; idN < nNod; ++idN)
      {
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtY;
      }
      break;
    case 1:
      for(idN = 0; idN < nNod; ++idN)
      {
	tD0 = nPos[idN].vtX;
	nPos[idN].vtX = lPos.vtX + width - nPos[idN].vtY;
	nPos[idN].vtY = lPos.vtY + tD0;
      }
      break;
    case 2:
      for(idN = 0; idN < nNod; ++idN)
      {
	nPos[idN].vtX = lPos.vtX + width - nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + width - nPos[idN].vtY;
      }
      break;
    case 3:
      for(idN = 0; idN < nNod; ++idN)
      {
	tD0 = nPos[idN].vtX;
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtY;
	nPos[idN].vtY = lPos.vtY + width - tD0;
      }
      break;
  }
  return(nNod);
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Joins the collection of elements created by the addition
*		of an LBT node to the other elements of the mesh.
* \param	mesh			The mesh.
* \param	nEdg 			The number of peripheral edges.
* \param	edg			The peripheral edges.
*/
static void	WlzCMeshElmsJoin2D(WlzCMesh2D *mesh,
				   int nEdg, WlzCMeshEdg2D **edg)
{
  int		idE;

  for(idE = 0; idE < nEdg; ++idE)
  {
    if((*edg)->opp == NULL)
    {
      (*edg)->opp = WlzCMeshEdgFindOpp2D(*edg);
      if((*edg)->opp)
      {
        (*edg)->opp->opp = *edg;
      }
    }
    ++edg;
  }
}


/*!
* \return	The opposite edge or NULL if there is no opposite edge.
* \ingroup	WlzMesh
* \brief	Finds the opposite edge (to set the opp link) using node
*		nnxt links.
* \param	gEdg			Given edge.
*/
static WlzCMeshEdg2D *WlzCMeshEdgFindOpp2D(WlzCMeshEdg2D *gEdg)
{
  WlzCMeshEdg2D	*fEdg,
  		*tEdg,
		*oEdg = NULL;

  tEdg = fEdg = gEdg->next->nod->edg;
  do
  {
    if(tEdg->next->nod == gEdg->nod)
    {
      oEdg = tEdg;
      break;
    }
    tEdg = tEdg->nnxt;
  } while(tEdg != fEdg);
  return(oEdg);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the mesh elements for an LBT node.
* \param	mesh			The mesh.
* \param	nPos			Positions of the nodes.
* \param	mEdg			The peripheral edges.
* \param	mElm			The new mesh elements.
* \param	mNod			Mesh nodes, non-NULL where the
*					already exist.
* \param	cls			LBT node connectivity class.
* \param	dstNElm			Destination pointer for number of
					elements.
* \param	dstNEdg			Destination pointer for number of
					peripheral edges.
*/
static WlzErrorNum WlzCMeshElmFromLBTNode2D(WlzCMesh2D *mesh, WlzDVertex2 *nPos,
					WlzCMeshElm2D **mElm,
					WlzCMeshEdg2D **mEdg,
					WlzCMeshNod2D **mNod,
					WlzLBTNodeClass2D cls,
					int *dstNElm,
					int *dstNEdg)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  switch(cls)
  {
    case WLZ_LBT_NODE_CLASS_2D_0:
      errNum = WlzCMeshElmsFromLBTNode2D0(mesh, mElm, mEdg, mNod, nPos,
      					 dstNElm, dstNEdg);
      break;
    case WLZ_LBT_NODE_CLASS_2D_1:
      errNum = WlzCMeshElmsFromLBTNode2D1(mesh, mElm, mEdg, mNod, nPos,
      					 dstNElm, dstNEdg);
      break;
    case WLZ_LBT_NODE_CLASS_2D_2:
      errNum = WlzCMeshElmsFromLBTNode2D2(mesh, mElm, mEdg, mNod, nPos,
      					 dstNElm, dstNEdg);
      break;
    case WLZ_LBT_NODE_CLASS_2D_3:
      errNum = WlzCMeshElmsFromLBTNode2D3(mesh, mElm, mEdg, mNod, nPos,
      					 dstNElm, dstNEdg);
      break;
    case WLZ_LBT_NODE_CLASS_2D_4:
      errNum = WlzCMeshElmsFromLBTNode2D4(mesh, mElm, mEdg, mNod, nPos,
      					 dstNElm, dstNEdg);
      break;
    case WLZ_LBT_NODE_CLASS_2D_5:
      errNum = WlzCMeshElmsFromLBTNode2D5(mesh, mElm, mEdg, mNod, nPos,
      					 dstNElm, dstNEdg);
      break;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 2 mesh elements for a WLZ_LBT_NODE_CLASS_2D_0
*		LBT node.
*		\verbatim
                         nod3                 nod2
                          O                    O
                            +---------------
                           |       0       +
                           |              / /
                           |             / / +
                           |            / /  |
                           |           / /   |
                           |          / /    |
                  elm1 --------      / /     |
                           |       2/ /      |
                           |1      / /       |
                           |      / /2       |
                           |     / /         |
                           |    / /         1|
                           |   / /           |
                           |  / /       --------- elm0
                           + / /             |
                            / +      0       |
                              --------------+
                          O                    O
                         nod0                 nod1
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mEdg			The peripheral edges.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
* \param	dstNEdg			Destination pointer for number of
					peripheral edges.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D0(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshEdg2D **mEdg,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm,
					int *dstNEdg)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[2], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[2], mNod[3], mNod[0], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 2;
    /* Set inter-element edge connectivities. */
    WlzCMeshEdgSetOpp2D(&(mElm[0]->edg[2]), &(mElm[1]->edg[2]));
    /* Set peripheral edges. */
    *dstNEdg = 4;
    mEdg[0] = &(mElm[0]->edg[0]);
    mEdg[1] = &(mElm[0]->edg[1]);
    mEdg[2] = &(mElm[1]->edg[0]);
    mEdg[3] = &(mElm[1]->edg[1]);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_1
*		LBT node.
*		\verbatim
                          nod4              nod3           nod2
			   O                 O              O
                             +--------------   +------------ 
                           |       0        /\       1       
                           |              +/ +\             +
                           |             //   \\            |
                           |            //     \\       -------- elm 1
                   elm2 -------        //       \\          |
                           |          //         \\        0|         
                           |         //           \\        |          
                           |1      2//2           1\\2      |           
                           |       //               \\      |            
                           |      //                 \\     |             
                           |     //                   \\    |              
                           |    //                     \\   |               
                           |   //                       \\  |                
                           |  //                         \+ |                 
                           + /+                 |         \ |                  
                            /              0    |           |
                             -------------------|---------+  
		          O                     |            O
                         nod0                 elm0          nod1
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mEdg			The peripheral edges.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
* \param	dstNEdg			Destination pointer for number of
					peripheral edges.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D1(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshEdg2D **mEdg,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm,
					int *dstNEdg)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[0], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 3;
    /* Set inter-element edge connectivities. */
    WlzCMeshEdgSetOpp2D(&(mElm[0]->edg[2]), &(mElm[2]->edg[2]));
    WlzCMeshEdgSetOpp2D(&(mElm[0]->edg[1]), &(mElm[1]->edg[2]));
    /* Set peripheral edges. */
    *dstNEdg = 5;
    mEdg[0] = &(mElm[0]->edg[0]);
    mEdg[1] = &(mElm[1]->edg[0]);
    mEdg[2] = &(mElm[1]->edg[1]);
    mEdg[3] = &(mElm[2]->edg[0]);
    mEdg[4] = &(mElm[2]->edg[1]);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 4 mesh elements for a WLZ_LBT_NODE_CLASS_2D_2
*		LBT node.
*		\verbatim
                          nod5              nod4           nod3
			   O                 O              O
                             +--------------   +------------ 
                           |        0      +/  +\     1     +
                           |              //     \\         |
                           |             //        \\      0|
                           |            //          1\\2  ----- elm1  
                   elm2 ------         //              \\   |
                           |          //                 \+ |         
                           |         //      elm3           O nod2     
                           |1      2//2                                 
                           |       //                   +/  +            
                           |      //                //      |             
                           |     //             //          |              
                           |    //         0//2             |               
                           |   //       //                 1|                
                           |  //    //                      |                 
                           + /+ /+                          |                  
                                              0 |           |
                              ------------------|---------+  
		          O                     |            O
                         nod0                 elm0          nod1
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mEdg			The peripheral edges.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
* \param	dstNEdg			Destination pointer for number of
					peripheral edges.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D2(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshEdg2D **mEdg,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm,
					int *dstNEdg)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[2], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[2], mNod[3], mNod[4], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[4], mNod[5], mNod[0], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[2], mNod[4], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 4;
    /* Set inter-element edge connectivities. */
    WlzCMeshEdgSetOpp2D(&(mElm[0]->edg[2]), &(mElm[3]->edg[0]));
    WlzCMeshEdgSetOpp2D(&(mElm[1]->edg[2]), &(mElm[3]->edg[1]));
    WlzCMeshEdgSetOpp2D(&(mElm[2]->edg[2]), &(mElm[3]->edg[2]));
    /* Set peripheral edges. */
    *dstNEdg = 6;
    mEdg[0] = &(mElm[0]->edg[0]);
    mEdg[1] = &(mElm[0]->edg[1]);
    mEdg[2] = &(mElm[1]->edg[0]);
    mEdg[3] = &(mElm[1]->edg[1]);
    mEdg[4] = &(mElm[2]->edg[0]);
    mEdg[5] = &(mElm[2]->edg[1]);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_3
*		LBT node.
*		\verbatim
                          nod5             nod4             nod3
			   O                O                O
                             +-------------    +------------- 
                           |       0         |       0        
                           |                +|               +
                           |             +/ ||             +/|
                           |            //  ||            // |         
                           |    elm3   //   ||    elm2   //  |
                           |          //    ||          //   |         
                           |         //     ||         //    |          
                           |1      2//      ||1      2//     |           
                           |       //       ||       //      |            
                           |      //2      1||      //       |             
                           |     //         ||     //2      1|              
                           |    //          ||    //         |               
                           |   //           ||   //          |                
                           |  //   elm0     ||  //  elm1     |                 
                           + /+             |+ //            |                  
                                    0       |        0       |
                              -----------+    -------------+  
		          O                 O                O
                         nod0              nod1             nod2
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mEdg			The peripheral edges.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
* \param	dstNEdg			Destination pointer for number of
					peripheral edges.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D3(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshEdg2D **mEdg,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm,
					int *dstNEdg)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[4], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[1], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[4], mNod[5], mNod[0], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 4;
    /* Set inter-element edge connectivities. */
    WlzCMeshEdgSetOpp2D(&(mElm[0]->edg[1]), &(mElm[2]->edg[1]));
    WlzCMeshEdgSetOpp2D(&(mElm[1]->edg[2]), &(mElm[2]->edg[2]));
    WlzCMeshEdgSetOpp2D(&(mElm[0]->edg[2]), &(mElm[3]->edg[2]));
    /* Set peripheral edges. */
    *dstNEdg = 6;
    mEdg[0] = &(mElm[0]->edg[0]);
    mEdg[1] = &(mElm[1]->edg[0]);
    mEdg[2] = &(mElm[1]->edg[1]);
    mEdg[3] = &(mElm[2]->edg[0]);
    mEdg[4] = &(mElm[3]->edg[0]);
    mEdg[5] = &(mElm[3]->edg[1]);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_4
*		LBT node.
*		\verbatim
                          nod6             nod5             nod4
			   O                O                O
                             +-------------    +------------- 
                           |       0         | +\     1      +
                           |              +/+|  \\           |
                           |             // ||    \\      ------ elm2
                           |            //  ||      \\2      |         
                           |    elm3   //   ||      1 \\    0|
                           |          //    ||          \\   |         
                           |         //     ||            \+            
                           |1      2//      ||   elm4        O nod3      
                           |       //2      ||             +/              
                           |      //      1 ||2          //  +             
                           |     //         ||         //    |              
                           |    //          ||      0//      |               
                           |   //           ||     //2      1|                
                           |  //   elm0     ||   //          |                 
                           | /+             |+ /+         ------ elm1           
                                    0       |        0       |
                              -----------+    ------------+  
		           O                O                O
                          nod0             nod1             nod2
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mEdg			The peripheral edges.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
* \param	dstNEdg			Destination pointer for number of
					peripheral edges.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D4(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshEdg2D **mEdg,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm,
					int *dstNEdg)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[5], mNod[6], mNod[0], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[4] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[3], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 5;
    /* Set inter-element edge connectivities. */
    WlzCMeshEdgSetOpp2D(&(mElm[0]->edg[1]), &(mElm[4]->edg[2]));
    WlzCMeshEdgSetOpp2D(&(mElm[0]->edg[2]), &(mElm[3]->edg[2]));
    WlzCMeshEdgSetOpp2D(&(mElm[1]->edg[2]), &(mElm[4]->edg[0]));
    WlzCMeshEdgSetOpp2D(&(mElm[2]->edg[2]), &(mElm[4]->edg[1]));
    /* Set peripheral edges. */
    *dstNEdg = 7;
    mEdg[0] = &(mElm[0]->edg[0]);
    mEdg[1] = &(mElm[1]->edg[0]);
    mEdg[2] = &(mElm[1]->edg[1]);
    mEdg[3] = &(mElm[2]->edg[0]);
    mEdg[4] = &(mElm[2]->edg[1]);
    mEdg[5] = &(mElm[3]->edg[0]);
    mEdg[6] = &(mElm[3]->edg[1]);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_5
*		LBT node.
*		\verbatim
                          nod6             nod5             nod4
			   O                O                O
                             +-------------    +------------- 
                           |       0     +/  | +\      1     +
                           |1          //   +|  \\          0|
                           |        2//     ||    \\         |
                     elm3 ---      //2      ||      \\2    ---- elm2   
                           |     //         ||       1\\     |
                           +   //           ||          \\   |         
                             /+             ||            \+            
                      nod7 O       elm4    1||2  elm5        O nod3      
                             +              ||             +/              
                           |  \\            ||           //  +             
                           |    \\          ||         //    |              
                           |      \\0       ||      0//      |               
                           |2     1 \\      ||     //2      1|                
                           |          \\    ||   //          |                 
                           +            \+  |+ /+            |                  
                                 | 0        |        | 0     |
                              ---|-------+    -------|----+  
		           O     |          O        |       O
                          nod0             nod1             nod2
		                elm0                elm1
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mEdg			The peripheral edges.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
* \param	dstNEdg			Destination pointer for number of
					peripheral edges.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D5(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshEdg2D **mEdg,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm,
					int *dstNEdg)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[7], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[5], mNod[6], mNod[7], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[4] = WlzCMeshNewElm2D(mesh, mNod[7], mNod[1], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[5] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[3], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 6;
    /* Set inter-element edge connectivities. */
    WlzCMeshEdgSetOpp2D(&(mElm[0]->edg[1]), &(mElm[4]->edg[0]));
    WlzCMeshEdgSetOpp2D(&(mElm[5]->edg[2]), &(mElm[4]->edg[1]));
    WlzCMeshEdgSetOpp2D(&(mElm[3]->edg[2]), &(mElm[4]->edg[2]));
    WlzCMeshEdgSetOpp2D(&(mElm[1]->edg[2]), &(mElm[5]->edg[0]));
    WlzCMeshEdgSetOpp2D(&(mElm[2]->edg[2]), &(mElm[5]->edg[1]));
    /* Set peripheral edges. */
    *dstNEdg = 8;
    mEdg[0] = &(mElm[0]->edg[0]);
    mEdg[1] = &(mElm[1]->edg[0]);
    mEdg[2] = &(mElm[1]->edg[1]);
    mEdg[3] = &(mElm[2]->edg[0]);
    mEdg[4] = &(mElm[2]->edg[1]);
    mEdg[5] = &(mElm[3]->edg[0]);
    mEdg[6] = &(mElm[3]->edg[1]);
    mEdg[7] = &(mElm[0]->edg[2]);
  }
  return(errNum);
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Sets the two edges to be opposite to each other.
* \param	edg0			First edge.
* \param	edg1			Secon edge.
*/
static void	WlzCMeshEdgSetOpp2D(WlzCMeshEdg2D *edg0, WlzCMeshEdg2D *edg1)
{
  edg0->opp = edg1;
  edg1->opp = edg0;
}

#ifdef WLZ_CMESH_DEBUG_MAIN

/*!
* \return	void
* \ingroup      WlzTransform
* \brief	Debuging function for 2D mesh output in VTK format.
* \param	fP			Given file pointer.
* \param	mesh			Given mesh.
*/
void		WlzCMeshDbgOutVTK2D(FILE *fP, WlzCMesh2D *mesh)
{
  int		idE,
		idN,
		bCnt,
		nElm,
		nVElm,
  		nNod;
  WlzCMeshElm2D  *elm;
  WlzCMeshNod2D	*nod;

  if(mesh && (mesh->type == WLZ_CMESH_TRI2D) &&
    ((nNod = mesh->res.nod.maxEnt) > 0) &&
    ((nElm = mesh->res.elm.maxEnt) > 0))
  {
    (void )fprintf(fP,
		   "# vtk DataFile Version 1.0\n"
		   "WlzCMesh2D 2D\n"
		   "ASCII\n"
		   "DATASET POLYDATA\n"
		   "POINTS %d float\n",
		   nNod);
    for(idN = 0; idN < nNod; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	(void )fprintf(fP, "%g %g 0\n",
		       nod->pos.vtX, nod->pos.vtY);
      }
      else
      {
	(void )fprintf(fP, "0 0 0\n");
      }
    }
    nVElm = 0;
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
        ++nVElm;
      }
    }
    (void )fprintf(fP, "POLYGONS %d %d\n",
		   nVElm, nVElm * 4);
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
	(void )fprintf(fP, "3 %d %d %d\n",
		       elm->edg[0].nod->idx, elm->edg[1].nod->idx, 
		       elm->edg[2].nod->idx);
      }
    }
  }
}

extern char 	*optarg;
extern int 	optind,
		opterr,
		optopt;

int		main(int argc, char *argv[])
{
  int		ok = 1,
  		option,
  		usage = 0;
  double	minElmSz = 25.0,
  		maxElmSz = 100.0;
  FILE		*fP = NULL;
  char		*inObjFileStr,
  		*outFileStr;
  const char	*errMsgStr;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  WlzObject	*obj = NULL;
  WlzCMesh2D 	*mesh = NULL;
  static char   optList[] = "hm:M:o:";
  const char    inObjFileStrDef[] = "-",
  	        outFileStrDef[] = "-";

  opterr = 0;
  inObjFileStr = (char *)inObjFileStrDef;
  outFileStr = (char *)outFileStrDef;
  while((usage == 0) && ((option = getopt(argc, argv, optList)) != EOF))
  {
    switch(option)
    {
      case 'm':
        if(sscanf(optarg, "%lg", &minElmSz) != 1)
	{
	  usage = 1;
	}
	break;
      case 'M':
        if(sscanf(optarg, "%lg", &maxElmSz) != 1)
	{
	  usage = 1;
	}
        break;
      case 'o':
        outFileStr = optarg;
	break;
      case 'h':
      default:
	usage = 1;
	break;
    }
  }
  ok = usage == 0;
  if(ok)
  {
    if((inObjFileStr == NULL) || (*inObjFileStr == '\0') ||
       (outFileStr == NULL) || (*outFileStr == '\0'))
    {
      ok = 0;
      usage = 1;
    }
    if(ok && (optind < argc))
    {
      if((optind + 1) != argc)
      {
        usage = 1;
        ok = 0;
      }
      else
      {
        inObjFileStr = *(argv + optind);
      }
    }
  }
  if(ok)
  {
    if((inObjFileStr == NULL) ||
       (*inObjFileStr == '\0') ||
       ((fP = (strcmp(inObjFileStr, "-")?
              fopen(inObjFileStr, "r"): stdin)) == NULL) ||
       ((obj = WlzAssignObject(WlzReadObj(fP, &errNum), NULL)) == NULL) ||
       (errNum != WLZ_ERR_NONE))
    {
      ok = 0;
      (void )fprintf(stderr,
                     "%s: failed to read object from file %s\n",
                     *argv, inObjFileStr);
    }
    if(fP && strcmp(inObjFileStr, "-"))
    {
      (void )fclose(fP); fP = NULL;
    }
  }
  if(ok)
  {
    (void )WlzAssignObject(obj, NULL);
    mesh = WlzCMeshFromObj2D(obj, minElmSz, maxElmSz, NULL, &errNum);
    if(errNum != WLZ_ERR_NONE)
    {
      ok = 0;
      (void )WlzStringFromErrorNum(errNum, &errMsgStr);
      (void )fprintf(stderr,
      		     "%s Failed to create conforming mesh, %s.\n",
      		     argv[0],
		     errMsgStr);
    }
  }
  if(ok)
  {
    if((fP = (strcmp(outFileStr, "-")?
	     fopen(outFileStr, "w"): stdout)) == NULL)
    {
      ok = 0;
      (void )fprintf(stderr,
		     "%s: Failed to open output file %s.\n",
		     argv[0], outFileStr);
    }
  }
  if(ok)
  {
    WlzCMeshDbgOutVTK2D(fP, mesh);
  }
  if(fP && strcmp(outFileStr, "-"))
  {
    (void )fclose(fP); fP = NULL;
  }
  (void )WlzFreeObj(obj);
  if(usage)
  {
    fprintf(stderr,
            "Usage: %s [-h] [-o<output file>] [-m#] [-M#] [<input object>]\n"
    	    "Computes a conforming mesh for the given input object.\n"
	    "Options are:\n"
	    "  -h  Help, prints this usage message.\n"
	    "  -o  Output file.\n"
	    "  -m  Minimum mesh element size.\n"
	    "  -M  Maximum mesh element size.\n",
	    argv[0]);

  }
  return(!ok);
}
#endif /* WLZ_CMESH_DEBUG_MAIN */
