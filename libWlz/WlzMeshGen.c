#pragma ident "MRC HGU $Id$"
/*!
* \file         WlzMeshGen.c
* \author       Bill Hill
* \date         June 2003
* \version      $Id$
* \note
*               Copyright
*               2002 Medical Research Council, UK.
*               All rights reserved.
*               All rights reserved.
* \par Address:
*               MRC Human Genetics Unit,
*               Western General Hospital,
*               Edinburgh, EH4 2XU, UK.
* \brief	Functions for 2D and 3D simplical mesh generation.
*		Meshes generated by these functions will be convex and
*		conform to object boundaries. All elements that are
*		outside a domain will have at least one node which has
*		the outside bit of it's flags set.
* \todo         Shuffle vertices before insertion for efficiency.
*		Replace WLZ_MESH_NODE_FLAGS_POLY with WLZ_..._BND.
* \bug          None known.
*/
#include <stdio.h>
#include <float.h>
#include <Wlz.h>

#define WLZ_MESH_DEBUG

/*!
* \enum		_WlzMeshType
* \ingroup	WlzMesh
* \brief	Type of graph based mesh model.
*		Typedef: ::WlzMeshType.
*/
typedef enum _WlzMeshType
{
  WLZ_MESH_TRI2D,			/*!< Planar mesh with triangular
  					     mesh elements. */
  WLZ_MESH_TET3D			/*!< Volumetric mesh with tetrahedral
  					     mesh elements. */

} WlzMeshType;

/*!
* \struct	_WlzMeshNod2D
* \ingroup	WlzMesh
* \brief	A node of a 2D mesh.
*		Typedef: ::WlzMeshNod2D.
*/
typedef struct _WlzMeshNod2D
{
  int		idx;			/*!< The node index. */
  unsigned int	flags;			/*!< Bitwise description of node. */
  WlzDVertex2	pos;			/*!< Node position. */
  struct _WlzMeshEdg2D *edg;		/*!< One of many edges which is
  					     directed from the node. A
					     node is shared by many parents. */
  struct _WlzMeshNodProp2D *prop;	/*!< Node properties. */
} WlzMeshNod2D;

/*!
* \struct	_WlzMeshNod3D
* \ingroup	WlzMesh
* \brief	A node of a 3D mesh.
*		Typedef: ::WlzMeshNod3D.
*/
typedef struct _WlzMeshNod3D
{
  int		idx;			/*!< The node index. */
  unsigned int	flags;			/*!< Bitwise description of node. */
  WlzDVertex3	pos;			/*!< Node position. */
  struct _WlzMeshEdg3D *edg;		/*!< One of many edges which is
  					     directed from the node. A
					     node is shared by many parents. */
  struct _WlzMeshNodProp3D *prop;	/*!< Node properties. */
} WlzMeshNod3D;

/*!
* \struct	_WlzMeshEdg2D
* \ingroup	WlzMesh
* \brief	A 2D CCW directed edge within the parent simplex.
*		Typedef: ::WlzMeshEdg2D.
*/
typedef struct _WlzMeshEdg2D
{
  struct _WlzMeshNod2D *nod;		/*!< Node form which this edge is
    					     directed. */
  struct _WlzMeshEdg2D *next;		/*!< Next directed edge, previous
  					     can be found using next->next. */
  struct _WlzMeshEdg2D *opp;		/*!< Opposite directed edge. */
  struct _WlzMeshElm2D *elm;		/*!< Parent element. */
  struct _WlzMeshSeg2D *seg;		/*!< Boundary edge segment which runs
  					     along this edge or NULL if there
					     is no segment along this edge. */
} WlzMeshEdg2D;

/*!
* \struct	_WlzMeshEdg3D
* \ingroup	WlzMesh
* \brief	A 3D directed edge within the parent face.
*		Typedef: ::WlzMeshEdg3D.
*/
typedef struct _WlzMeshEdg3D
{
  struct _WlzMeshNod3D *nod;		/*!< Node form which this edge is
    					     directed. */
  struct _WlzMeshEdg3D *next;		/*!< Next directed edge, previous
  					     can be found using next->next. */
  struct _WlzMeshEdg3D *opp;		/*!< Opposite directed edge on
  					     neighboring face. */
  struct _WlzMeshFace *face;		/*!< Parent face. */
} WlzMeshEdg3D;

/*!
* \struct	_WlzMeshFace
* \ingroup	WlzMesh
* \brief	A directed face within the parent simplex.
*		Typedef: ::WlzMeshFace.
*/
typedef struct _WlzMeshFace
{
  struct _WlzMeshEdg3D edg[3];		/*!< Directed edges of the face. */
  struct _WlzMeshFace *opp;		/*!< Opposite face on neighboring
  					     mesh element. */
  struct _WlzMeshElm3D *elm;		/*!< Parent mesh element. */
} WlzMeshFace;

/*!
* \struct	_WlzMeshElm2D
* \ingroup 	WlzMesh
* \brief	A single 2D triangular mesh element.
*		Typedef: ::WlzMeshElm2D.
*/
typedef struct _WlzMeshElm2D
{
  int		idx;			/*!< The element index. */
  unsigned int	flags;			/*!< Element flags. */
  struct _WlzMeshEdg2D edg[3];		/*!< Edges of the mesh element. */
  struct _WlzMeshEdgProp2D *prop;	/*!< Element properties. */
} WlzMeshElm2D;

/*!
* \struct	_WlzMeshElm3D
* \ingroup	WlzMesh
* \brief	A single 3D tetrahedral mesh element.
*		Typedef: ::WlzMeshElm3D
*/
typedef struct _WlzMeshElm3D
{
  int		idx;			/*!< The element index. */
  unsigned int	flags;			/*!< Element flags. */
  struct _WlzMeshFace face[4];		/*!< Faces of the mesh element. */
  struct _WlzMeshEdgProp3D *prop;	/*!< Element properties. */
} WlzMeshElm3D;

/*!
* \struct	_WlzMeshSeg2D
* \ingroup	WlzMesh
* \brief	A 2D mesh boundary segment.
*		The segments are mesh boundary segments to which the mesh must
*		conform, with the segments maintained in a doubly linked
*		circular list.
*		Typedef: ::WlzMeshSeg2D.
*/

typedef struct	_WlzMeshSeg2D
{
  int		idx;			/*!< The segment index. */
  struct _WlzMeshNod2D *nod;		/*!< Node form which this boundary
  					     segment is directed. */
  struct _WlzMeshEdg2D *edg;		/*!< An edge that coresponds to this
  					     segment, may be NULL. */
  struct  _WlzMeshSeg2D *next;		/*!< Next segment in boundary. */
  struct _WlzMeshSeg2D *prev;		/*!< Previous segment in boundary. */
} WlzMeshSeg2D;

/*!
* \struct	_WlzMeshBnd2D
* \ingroup	WlzMesh
* \brief	A 2D mesh boundary.
*		Each boundary is composed of a doubly linked circular list of
*		boundary segments, with the mesh boundaries themselves
*		beingmaintained in a doubly linked circular list.
*		Typedef: ::WlzMeshBnd2D
*/
typedef struct _WlzMeshBnd2D
{
  int		idx;			/*!< The boundary index. */
  struct  _WlzMeshSeg2D *seg;		/*!< A segment of this boundary. */
  struct _WlzMeshBnd2D *next;		/*!< Next mesh boundary. */
  struct _WlzMeshBnd2D *prev;		/*!< Previous mesh boundary. */
} WlzMeshBnd2D;

/*!
* \struct	_WlzMeshEntRes
* \ingroup	WlzMesh
* \brief	Resources used for efficient allocation and recycling of
*		mesh entities.
*		Typedef: ::WlzMeshEntRes.
*/
typedef struct _WlzMeshEntRes
{
  unsigned int	numEnt;			/*!< Number of valid entities in
  					     vector. */
  unsigned int	maxEnt;			/*!< Space allocated in vector. */
  unsigned int	nextIdx;		/*!< Index of next free mesh entity
  					     in vector. */
  AlcVector	*vec;			/*!< Vector (extensible array) of
  					     mesh entities. */
} WlzMeshEntRes;

/*!
* \struct	_WlzMeshRes
* \ingroup	WlzMesh
* \brief	Resources used for efficient allocation, recycling and
*		location of mesh elements and nodes.
*		Typedef: ::WlzMeshRes.
*/
typedef struct _WlzMeshRes
{
  struct _WlzMeshEntRes	nod;		/*!< Node resources. */
  struct _WlzMeshEntRes	elm;		/*!< Element resources. */
  struct _WlzMeshEntRes seg;		/*!< Segment resources. */
  struct _WlzMeshEntRes bnd;		/*!< Boundary resources. */
} WlzMeshRes;

/*!
* \struct	_WlzMesh2D
* \ingroup	WlzMesh
* \brief	A graph based mesh model that can be used to represent
*		a 2D meshe based on simplices.
*		The mesh inherits it's core fields from the Woolz core
*		domain.
*		Typedef: ::WlzMesh2D.
*/
typedef struct _WlzMesh
{
  int		type;			/*!< Type of mesh. */
  int		linkcount;		/*!< Core. */
  void		*freeptr;		/*!< Core. */
  struct _WlzMeshElm2D *elm;		/*!< First of the mesh elements,
  					     others can be reached by
					     walking the adjacencies. */
  struct _WlzMeshBnd2D *bnd;		/*!< First of the mesh boundaries
   					     in a circular list of mesh
					     boundaries. */
  WlzDBox2	bBox;			/*!< Bounding box within which all
  					     mesh nodes must lie. */
  struct _WlzMeshRes res;		/*!< Mesh resources. */
} WlzMesh2D;

/*!
* \struct	_WlzMesh3D
* \ingroup	WlzMesh
* \brief	A graph based mesh model that can be used to represent
*		a 3D volumetric meshe based on simplices.
*		The mesh inherits it's core fields from the Woolz core
*		domain.
*		Typedef: ::WlzMesh3D.
*/
typedef struct _WlzMesh3D
{
  int		type;			/*!< Type of mesh. */
  int		linkcount;		/*!< Core. */
  void		*freeptr;		/*!< Core. */
  struct _WlzMeshElm3D *elm;		/*!< First of the mesh elements,
  					     others can be reached by
					     walking the adjacencies. */
  WlzDBox2	bBox;			/*!< Bounding box within which all
  					     mesh nodes must lie. */
  struct _WlzMeshRes res;		/*!< Mesh resources. */
} WlzMesh3D;

/*!
* \struct	_WlzMeshWSp2D
* \ingroup	WlzMesh
* \brief	A work space data structure used in maintaining a 2D mesh.
*		Typedef: ::WlzMeshWSp2D.
*/
typedef struct _WlzMeshWSp2D
{
  int		cCnt;
  AlcVector	*cElmVec;
  AlcVector	*cNodVec;
  AlcVector	*cOppVec;
  AlcVector	*cSegVec;
} WlzMeshWSp2D;

WlzMesh2D			*WlzMeshNew2D(
				  int nElm,
				  int nNod,
				  int nSeg,
				  int nBnd,
				  WlzErrorNum *dstErr);
WlzMeshWSp2D			*WlzMeshNewWSp2D(
				  void);
WlzErrorNum			WlzMeshFree2D(
				  WlzMesh2D *mesh);
WlzErrorNum			WlzMeshFreeWSp2D(
				  WlzMeshWSp2D *wSp);
WlzMesh2D			*WlzMeshFromObjBnd2D(
				  WlzObject *obj,
				  double minArea,
				  double maxArea,
				  double minAng,
				  WlzErrorNum *dstErr);
WlzErrorNum 			WlzMeshConform2D(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  double minArea,
				  double maxArea,
				  double minAng);
WlzErrorNum 			WlzMeshSplitElm2D(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  WlzMeshElm2D *elm,
				  unsigned int flags);
WlzErrorNum 			WlzMeshSplitSeg2D(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  WlzMeshSeg2D *seg);
WlzMeshElm2D 			*WlzMeshNewElm2D(
				  WlzMesh2D *mesh,
				  WlzMeshNod2D *nod0,
				  WlzMeshNod2D *nod1,
				  WlzMeshNod2D *nod2,
				  WlzErrorNum *dstErr);
WlzMeshNod2D			*WlzMeshNewNod2D(
				  WlzMesh2D *mesh,
				  WlzDVertex2 pos,
				  WlzErrorNum *dstErr);
WlzMeshSeg2D			*WlzMeshNewSeg2D(
				  WlzMesh2D *mesh,
				  WlzErrorNum *dstErr);
WlzMeshBnd2D			*WlzMeshNewBnd2D(
				  WlzMesh2D *mesh,
				  WlzErrorNum *dstErr);
void				WlzMeshElmFree(
				  WlzMesh2D *mesh,
				  WlzMeshElm2D *elm);
void 				WlzMeshNodFree(
				  WlzMesh2D *mesh,
				  WlzMeshNod2D *nod);
void				WlzMeshSegFree(
				  WlzMesh2D *mesh,
				  WlzMeshSeg2D *seg);
void				WlzMeshBndFree(
				  WlzMesh2D *mesh,
				  WlzMeshBnd2D *bnd);
WlzMeshNod2D			*WlzMeshMatchNodAndElm2D(
				  WlzMesh2D *mesh,
				  WlzDVertex2 pos,
				  WlzMeshElm2D *sElm,
				  WlzMeshElm2D **dstElm,
				  double *dstElmSA2,
				  WlzErrorNum *dstErr);
WlzDVertex2			WlzMeshElmCentroid2D(
				  WlzMeshElm2D *elm);
WlzMeshNod2D			*WlzMeshElmOtherNod(
				  WlzMeshElm2D *elm,
				  WlzMeshNod2D *nod0,
				  WlzMeshNod2D *nod1);
WlzMeshEdg2D			*WlzMeshEdgShareNod2D(
				  WlzMeshNod2D *nod0,
				  WlzMeshNod2D *nod1);
WlzErrorNum			WlzMeshVerify2D(
				  WlzMesh2D *mesh,
				  WlzMeshElm2D **dstElm);
WlzErrorNum			WlzMeshAddBBox2D(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  double meshMaxDst,
				  WlzDBox2 bBox);
WlzErrorNum			WlzMeshVtxAddD2(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  WlzMeshBnd2D *bnd,
				  int nVtx,
				  WlzDVertex2 *vtx,
				  double minDistSq,
				  unsigned int flags);
WlzErrorNum			WlzMeshAddNod2D(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  WlzMeshNod2D *nod,
				  WlzMeshElm2D *elm);

static WlzErrorNum  		WlzMeshSetElm2D(
				  WlzMeshElm2D *elm,
				  WlzMeshNod2D *nod0,
				  WlzMeshNod2D *nod1,
				  WlzMeshNod2D *nod2);
static void			WlzMeshEntMarkFree(
				  int *idx);
static void			WlzMeshEntUnmarkFree(
				  int *idx);
static void			WlzMeshMarkOutsideElm(
				  WlzMesh2D *mesh,
				  WlzObject *obj);
static void			WlzMeshInsertBnd2D(
				  WlzMesh2D *mesh,
				  WlzMeshBnd2D *bnd);
static void			WlzMeshBndInsertSeg2D(
				  WlzMeshBnd2D *bnd,
				  WlzMeshSeg2D *seg);
static void			WlzMeshSegAppendSeg2D(
				  WlzMeshSeg2D *seg,
				  WlzMeshSeg2D *nSeg);
static double			WlzMeshElmSnArea2D(
				  WlzMeshElm2D *elm);
static double			WlzMeshQuality2D(
				  double cosAng,
				  double areaSq,
				  double maxAreaSq);
static double			WlzMeshElmQuality2D(
				  WlzMeshElm2D *elm,
				  double maxAreaSq,
				  double cosMinAng,
				  WlzErrorNum *dstErr);
static WlzErrorNum 		WlzMeshBoundAdd(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  int *bufSz,
				  WlzDVertex2 **buf,
				  WlzBoundList *bnd);
static WlzErrorNum 		WlzMeshBndPolyAdd(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  int *bufSz,
				  WlzDVertex2 **buf,
				  WlzPolygonDomain *poly);
static WlzErrorNum 		WlzMeshBuildVtxConfElmVec2D(
				  WlzMeshWSp2D *wSp,
				  WlzMeshElm2D *sElm,
				  WlzMeshElm2D *tElm,
				  WlzDVertex2 vtx);
static WlzErrorNum 		WlzMeshReplaceNElm2D(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  WlzMeshNod2D *nNod);
static WlzErrorNum 		WlzMeshReplace1Elm2D(
				  WlzMesh2D *mesh,
				  WlzMeshElm2D *elm,
				  WlzMeshNod2D *nNod);
static WlzErrorNum		WlzMeshReplace1With2Elm2D(
				  WlzMesh2D *mesh,
				  WlzMeshElm2D *eElm,
				  WlzMeshNod2D *sNod,
				  WlzMeshNod2D *nNod);
static WlzErrorNum 		WlzMeshReplace1With3Elm2D(
				  WlzMesh2D *mesh,
				  WlzMeshElm2D *eElm,
				  WlzMeshNod2D *nNod);
static WlzErrorNum 		WlzMeshReplaceNWithNElm2D(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  WlzMeshNod2D *nNod);
static WlzErrorNum		WlzMeshConformBnd2D(
				  WlzMesh2D *mesh,
				  WlzMeshWSp2D *wSp,
				  int *nSplit);
static WlzMeshElm2D		*WlzMeshAllocElm2D(
				  WlzMesh2D *mesh,
				  WlzErrorNum *dstErr);
static WlzMeshNod2D		*WlzMeshAllocNod2D(
				  WlzMesh2D *mesh,
				  WlzErrorNum *dstErr);
static WlzMeshSeg2D		*WlzMeshAllocSeg2D(
				  WlzMesh2D *mesh,
				  WlzErrorNum *dstErr);
static WlzMeshSeg2D 		*WlzMeshNodConfSeg(
				  WlzMesh2D *mesh,
				  WlzMeshElm2D *sElm,
				  WlzDVertex2 vtx,
				  WlzErrorNum *dstErr);
static WlzMeshBnd2D		*WlzMeshAllocBnd2D(
				  WlzMesh2D *mesh,
				  WlzErrorNum *dstErr);

/*!
* \return	New mesh.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh data structure with the resources
*		optimized for the given number of mesh elements and nodes.
*		It is better to under estimate the number of elements and
*		nodes rather than over estimate and if zero is given some
*		reasonable default will be used.
* \param	nElm			Expected number of mesh elements.
* \param	nNod			Expected number of mesh nodes.
* \param	nSeg			Expected number of mesh segments.
* \param	nBnd			Expected number of mesh boundaries.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzMesh2D	*WlzMeshNew2D(int nElm, int nNod, int nSeg, int nBnd,
			      WlzErrorNum *dstErr)
{
  int		blkSz;
  unsigned int	nodSz,
		elmSz,
		segSz,
		bndSz;
  WlzMesh2D	*nMesh = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	minBlkSz = 1024,
  		minNNod = 1024;

  nodSz = sizeof(WlzMeshNod2D);
  elmSz = sizeof(WlzMeshElm2D);
  segSz = sizeof(WlzMeshSeg2D);
  bndSz = sizeof(WlzMeshBnd2D);
  if((nMesh = (WlzMesh2D *)AlcCalloc(1, sizeof(WlzMesh2D))) == NULL)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    nMesh->type = WLZ_MESH_TRI2D;
    blkSz = ALG_MIN(nElm, nNod);
    if(blkSz < minBlkSz)
    {
      blkSz = minBlkSz;
    }
    if(((nMesh->res.nod.vec = AlcVectorNew(1, nodSz, blkSz, NULL)) == NULL) ||
       ((nMesh->res.elm.vec = AlcVectorNew(1, elmSz, blkSz, NULL)) == NULL) ||
       ((nMesh->res.seg.vec = AlcVectorNew(1, segSz, blkSz, NULL)) == NULL) ||
       ((nMesh->res.bnd.vec = AlcVectorNew(1, bndSz, blkSz, NULL)) == NULL))
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum != WLZ_ERR_NONE)
  {
    (void )WlzMeshFree2D(nMesh);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nMesh);
}

/*!
* \return	New mesh node.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D mesh node and sets it's index. 
* \param	mesh			Mesh with resources.
* \param	dstErr			Destination error pointer, may be NULL.
*/
static WlzMeshNod2D *WlzMeshAllocNod2D(WlzMesh2D *mesh, WlzErrorNum *dstErr)
{
  WlzMeshNod2D	*nNod = NULL;
  WlzMeshEntRes	*nRes;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  
  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    nRes = &(mesh->res.nod);
    if((nNod = (WlzMeshNod2D *)
    	       (AlcVectorExtendAndGet(nRes->vec, nRes->nextIdx))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    ++(nRes->numEnt);
    ++(nRes->maxEnt);
    nNod->idx = nRes->nextIdx++;
  }
  return(nNod);
}

/*!
* \return	New mesh node.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D mesh element and sets it's index. 
* \param	mesh			Mesh with resources.
* \param	dstErr			Destination error pointer, may be NULL.
*/
static WlzMeshElm2D *WlzMeshAllocElm2D(WlzMesh2D *mesh, WlzErrorNum *dstErr)
{
  WlzMeshElm2D	*nElm = NULL;
  WlzMeshEntRes	*eRes;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  
  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    eRes = &(mesh->res.elm);
    if((nElm = (WlzMeshElm2D *)
    	       (AlcVectorExtendAndGet(eRes->vec, eRes->nextIdx))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    ++(eRes->numEnt);
    ++(eRes->maxEnt);
    nElm->idx = eRes->nextIdx++;
  }
  return(nElm);
}

/*!
* \return	New mesh node.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D mesh boundary segment and sets it's index. 
* \param	mesh			Mesh with resources.
* \param	dstErr			Destination error pointer, may be NULL.
*/
static WlzMeshSeg2D *WlzMeshAllocSeg2D(WlzMesh2D *mesh, WlzErrorNum *dstErr)
{
  WlzMeshSeg2D	*nSeg = NULL;
  WlzMeshEntRes	*eRes;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  
  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    eRes = &(mesh->res.seg);
    if((nSeg = (WlzMeshSeg2D *)
    	       (AlcVectorExtendAndGet(eRes->vec, eRes->nextIdx))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    ++(eRes->numEnt);
    ++(eRes->maxEnt);
    nSeg->idx = eRes->nextIdx++;
  }
  return(nSeg);
}

/*!
* \return	New mesh node.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D mesh boundary and sets it's index. 
* \param	mesh			Mesh with resources.
* \param	dstErr			Destination error pointer, may be NULL.
*/
static WlzMeshBnd2D *WlzMeshAllocBnd2D(WlzMesh2D *mesh, WlzErrorNum *dstErr)
{
  WlzMeshBnd2D	*nBnd = NULL;
  WlzMeshEntRes	*eRes;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  
  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    eRes = &(mesh->res.bnd);
    if((nBnd = (WlzMeshBnd2D *)
    	       (AlcVectorExtendAndGet(eRes->vec, eRes->nextIdx))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    ++(eRes->numEnt);
    ++(eRes->maxEnt);
    nBnd->idx = eRes->nextIdx++;
  }
  return(nBnd);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's the mesh and all it's elements.
* \param	mesh			Mesh to free.
*/
WlzErrorNum	WlzMeshFree2D(WlzMesh2D *mesh)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    (void )AlcVectorFree(mesh->res.elm.vec);
    (void )AlcVectorFree(mesh->res.nod.vec);
    (void )AlcVectorFree(mesh->res.seg.vec);
    (void )AlcVectorFree(mesh->res.bnd.vec);
    AlcFree(mesh);
  }
  return(errNum);
}

/*!
* \return	New workspace or NULL on error.
* \ingroup	WlzMesh
* \brief	Makes a new 2D mesh workspace.
*/
WlzMeshWSp2D	*WlzMeshNewWSp2D(void)
{
  WlzMeshWSp2D	*wSp;

  if(((wSp = (WlzMeshWSp2D *)AlcCalloc(1, sizeof(WlzMeshWSp2D))) == NULL) ||
     ((wSp->cElmVec = AlcVectorNew(1, sizeof(WlzMeshElm2D),
     				   64, NULL)) == NULL) ||
     ((wSp->cNodVec = AlcVectorNew(1, sizeof(WlzMeshNod2D),
     				   64, NULL)) == NULL) ||
     ((wSp->cOppVec = AlcVectorNew(1, sizeof(WlzMeshEdg2D),
     				   64, NULL)) == NULL) ||
     ((wSp->cSegVec = AlcVectorNew(1, sizeof(WlzMeshSeg2D),
     				   64, NULL)) == NULL))
  {
    (void )WlzMeshFreeWSp2D(wSp);
  }
  return(wSp);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's a 2D mesh workspace.
* \param	wSp			Given workspace.
*/
WlzErrorNum	WlzMeshFreeWSp2D(WlzMeshWSp2D *wSp)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(wSp == NULL)
  {
    errNum = WLZ_ERR_PARAM_NULL;;
  }
  else
  {
    (void )AlcVectorFree(wSp->cElmVec);
    (void )AlcVectorFree(wSp->cNodVec);
    (void )AlcVectorFree(wSp->cOppVec);
    (void )AlcVectorFree(wSp->cSegVec);
  }
  return(errNum);
}

/*!
* \return	<void>
* \ingroup	WlzMesh
* \brief	Sets the index to indicate that the mesh entity is free.
* \param	idx			Entity index pointer.
*/
static void	WlzMeshEntMarkFree(int *idx)
{
  if(*idx >= 0)
  {
    *idx = -(*idx + 1);
  }
}

/*!
* \return	<void>
* \ingroup	WlzMesh
* \brief	Sets the index to indicate that the mesh entity is not free.
* \param	idx			Entity index pointer.
*/
static void	WlzMeshEntUnmarkFree(int *idx)
{
  if(*idx < 0)
  {
    *idx = -*idx - 1;
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given mesh node. Actually just sets the
*		node's index to mark it freed and then decrements
*		the number of mesh nodes.
* \param	mesh	Input mesh
* \param	nod			Given mesh node.
*/
void 		WlzMeshNodFree(WlzMesh2D *mesh, WlzMeshNod2D *nod)
{
  if(nod && (nod->idx >= 0))
  {
    WlzMeshEntMarkFree(&(nod->idx));
    --(mesh->res.nod.numEnt);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given mesh element. Actually just sets the
*		element's index to mark it freed and then decrements
*		the number of mesh elements.
* \param	mesh	Input mesh
* \param	elm			Given mesh element.
*/
void		WlzMeshElmFree(WlzMesh2D *mesh, WlzMeshElm2D *elm)
{
  if(elm && (elm->idx >= 0))
  {
    WlzMeshEntMarkFree(&(elm->idx));
    --(mesh->res.elm.numEnt);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given mesh segment. Actually just sets the
*		segment's index to mark it freed and then decrements
*		the number of mesh boundary segments.
* \param	mesh	Input mesh
* \param	seg			Given mesh element.
*/
void		WlzMeshSegFree(WlzMesh2D *mesh, WlzMeshSeg2D *seg)
{
  if(seg && (seg->idx >= 0))
  {
    WlzMeshEntMarkFree(&(seg->idx));
    --(mesh->res.seg.numEnt);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given mesh boundary. Actually just sets the
*		boundary's index to mark it freed and then decrements
*		the number of mesh boundaries.
* \param	mesh	Input mesh
* \param	bnd			Given mesh element.
*/
void		WlzMeshBndFree(WlzMesh2D *mesh, WlzMeshBnd2D *bnd)
{
  if(bnd && (bnd->idx >= 0))
  {
    WlzMeshEntMarkFree(&(bnd->idx));
    --(mesh->res.bnd.numEnt);
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Check that the mesh has valid connectivities.
* \param	mesh			Given mesh.
* \param	dstElm			Destination mesh element pointer
*					for last mesh element, may be NULL.
*/
WlzErrorNum	WlzMeshVerify2D(WlzMesh2D *mesh, WlzMeshElm2D **dstElm)
{
  int		idE,
  		idN;
  WlzMeshElm2D	*elm;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(mesh->type != WLZ_MESH_TRI2D)
  {
    errNum = WLZ_ERR_DOMAIN_TYPE;
  }
  else
  {
    idE = 0;
    while((errNum == WLZ_ERR_NONE) && (idE < mesh->res.elm.maxEnt))
    {
      elm = (WlzMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
	idN = 0;
	while((errNum == WLZ_ERR_NONE) && (idN < 3))
	{
	  if((elm->edg[idN].next != &(elm->edg[(idN + 1) % 3])) ||
	     (elm->edg[idN].nod == NULL) ||
	     (elm->edg[idN].nod->idx < 0) ||
	     (elm->edg[idN].nod->edg->nod != elm->edg[idN].nod) ||
	     (elm->edg[idN].opp &&
	      ((elm->edg[idN].opp->elm == elm) ||
	       (elm->edg[idN].opp->opp != &(elm->edg[idN])))))
	  {
	    errNum = WLZ_ERR_DOMAIN_DATA;
	  }
	  ++idN;
	}
	if(errNum == WLZ_ERR_NONE)
	{
	  if(WlzMeshElmSnArea2D(elm) < WLZ_MESH_TOLERANCE_SQ)
	  {
	    errNum = WLZ_ERR_DOMAIN_DATA;
	  }
	}
      }
      ++idE;
    }
  }
  if(dstElm)
  {
    *dstElm = elm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets up the edge and node connectivities within the given
*		2D mesh element. No opposites are changed.
*		The geometry of the element is checked to make sure that
*		it's area is greater than the mesh tolerance and that
*		the nodes are in CCW order. If this test fails an error
*		is returned.
* \param	elm			Given mesh element.
* \param	nod0			First mesh node of element.
* \param	nod1			Second mesh node of element.
* \param	nod2			Third mesh node of element.
*/
static WlzErrorNum  WlzMeshSetElm2D(WlzMeshElm2D *elm,
				    WlzMeshNod2D *nod0, WlzMeshNod2D *nod1,
				    WlzMeshNod2D *nod2)
{
  double	sA2;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  sA2 = WlzGeomTriangleSnArea2(nod0->pos, nod1->pos, nod2->pos);
  if(sA2 < WLZ_MESH_TOLERANCE_SQ)
  {
    /* Element either has a very small area or is CW. */
    errNum = WLZ_ERR_PARAM_DATA;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    elm->edg[1].nod = nod1;
    nod1->edg = &(elm->edg[1]);
    elm->edg[0].nod = nod0;
    nod0->edg = &(elm->edg[0]);
    elm->edg[2].nod = nod2;
    nod2->edg = &(elm->edg[2]);
    elm->edg[0].next = &(elm->edg[1]);
    elm->edg[0].elm = elm;
    elm->edg[1].next = &(elm->edg[2]);
    elm->edg[1].elm = elm;
    elm->edg[2].next = &(elm->edg[0]);
    elm->edg[2].elm = elm;
  }
  return(errNum);
}

/*!
* \return	New 2D mesh element.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh element connecting the given
*		mesh nodes but does not connect this new mesh element
*		to the rest of the mesh apart from changing the parent
*		edges of the mesh nodes.
* \param	mesh			The mesh for resources.
* \param	nod0			First mesh node.
* \param	nod1			Second mesh node.
* \param	nod2			Third mesh node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzMeshElm2D 	*WlzMeshNewElm2D(WlzMesh2D *mesh,
				 WlzMeshNod2D *nod0, WlzMeshNod2D *nod1,
				 WlzMeshNod2D *nod2, WlzErrorNum *dstErr)
{
  WlzMeshElm2D	*nElm = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((nod0 == NULL) || (nod1 == NULL) || (nod2 == NULL))
  {
    errNum = WLZ_ERR_PARAM_NULL;
  }
  else
  {
    nElm = WlzMeshAllocElm2D(mesh, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzMeshSetElm2D(nElm, nod0, nod1, nod2);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nElm);
}

/*!
* \return	New 2D mesh node.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh node at the given position. A node
*		must not already exist at this position.
* \param	mesh			The mesh for resources.
* \param	pos			Position for the node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzMeshNod2D	*WlzMeshNewNod2D(WlzMesh2D *mesh, WlzDVertex2 pos,
				 WlzErrorNum *dstErr)
{
  WlzMeshNod2D	*nNod = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;


  nNod = WlzMeshAllocNod2D(mesh, &errNum);
  if(errNum == WLZ_ERR_NONE)
  {
    nNod->pos = pos;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nNod);
}

/*!
* \return	New 2D mesh boundary segment.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh boundary segment.
* \param	mesh			The mesh for resources.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzMeshSeg2D	*WlzMeshNewSeg2D(WlzMesh2D *mesh, WlzErrorNum *dstErr)
{
  WlzMeshSeg2D	*nSeg = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  nSeg = WlzMeshAllocSeg2D(mesh, &errNum);
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nSeg);
}

/*!
* \return	New 2D mesh boundary.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh boundary.
* \param	mesh			The mesh for resources.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzMeshBnd2D	*WlzMeshNewBnd2D(WlzMesh2D *mesh, WlzErrorNum *dstErr)
{
  WlzMeshBnd2D	*nBnd = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;


  nBnd = WlzMeshAllocBnd2D(mesh, &errNum);
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nBnd);
}

/*!
* \return	<void>
* \ingroup	WlzMesh
* \brief	Inserts the given boundary into the list of mesh boundaries.
* \param	mesh
* \param	bnd
*/
static void	WlzMeshInsertBnd2D(WlzMesh2D *mesh, WlzMeshBnd2D *bnd)
{
  if(mesh->bnd)
  {
    bnd->next = mesh->bnd;
    bnd->prev = mesh->bnd->prev;
    bnd->next->prev = bnd;
    bnd->prev->next = bnd;
    mesh->bnd = bnd;
  }
  else
  {
    mesh->bnd = bnd;
    bnd->next = bnd->prev = bnd;
  }
}

/*!
* \return	<void>
* \ingroup	WlzMesh
* \brief	Inserts the given boundary segment into the given boundary.
* \param	bnd
* \param	seg
*/
static void	WlzMeshBndInsertSeg2D(WlzMeshBnd2D *bnd, WlzMeshSeg2D *seg)
{
  if(bnd->seg)
  {
    seg->next = bnd->seg;
    seg->prev = bnd->seg->prev;
    seg->next->prev = seg;
    seg->prev->next = seg;
    bnd->seg = seg;
  }
  else
  {
    bnd->seg = seg;
    seg->next = seg->prev = seg;
  }
}

/*!
* \return	<void>
* \ingroup	WlzMesh
* \brief	Appends the new boundary segment after the first.
* \param	seg			First boundary segment.
* \param	nSeg			New boundary segment.
*/
static void	WlzMeshSegAppendSeg2D(WlzMeshSeg2D *seg, WlzMeshSeg2D *nSeg)
{
    nSeg->next = seg->next;
    nSeg->prev = seg;
    nSeg->next->prev = nSeg;
    seg->next = nSeg;
}

/*!
* \return	Matched node or NULL if there is no matching node in the mesh.
* \ingroup	WlzMesh
* \brief	Finds the node which matches the given node position and
*		a mesh element which either uses the node or encloses the
*		given position within it. These are found by walking
*		through the mesh towards it. Because meshes are always
*		convex (when all mesh elements are considered) the walk
*		will always find an element (or node if it exists) provided
*		that the position is within the mesh.
*		Either the mached node or the mached element may be NULL on
*		return. If the mached node is NULL then the node does not
*		exist within the mesh. If the matched element is NULL the
*		the position is outside the mesh.
* \param	mesh			The given mesh.
* \param	pos			Position.
* \param	sElm			Starting element for the walk to
*					improve efficiency, may be NULL.
* \param	dstElm			Destination pointer for an element
*					which contains with the given
*					position or NULL if the position is
*					outside the mesh.
* \param	dstElmSA2		Destination pointer for twice the
*					signed area of the matched element.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzMeshNod2D	*WlzMeshMatchNodAndElm2D(WlzMesh2D *mesh, WlzDVertex2 pos,
				   WlzMeshElm2D *sElm,
				   WlzMeshElm2D **dstElm, double *dstElmSA2,
				   WlzErrorNum *dstErr)
{
  int		fndFlg;
  WlzMeshNod2D	*mNod = NULL;
  WlzMeshElm2D	*elm0,
  		*elm1;
  double	eArea[3];
  WlzDVertex2	ePos[3];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(sElm == NULL)
  {
    sElm = mesh->elm;
  }
  fndFlg = 0;
  elm0 = elm1 = sElm;
  while(elm0 && (fndFlg == 0) && (errNum == WLZ_ERR_NONE))
  {
    ePos[0] = elm0->edg[0].nod->pos;
    ePos[1] = elm0->edg[1].nod->pos;
    ePos[2] = elm0->edg[2].nod->pos;
    if((eArea[0] = WlzGeomTriangleSnArea2(ePos[0], ePos[1],
    				          ePos[2])) < WLZ_MESH_TOLERANCE_SQ)
    {
      errNum = WLZ_ERR_DOMAIN_DATA;
    }
    else
    {
      if((ALG_SQR(ePos[0].vtX - pos.vtX) +
	  ALG_SQR(ePos[0].vtY - pos.vtY)) < WLZ_MESH_TOLERANCE_SQ)
      {
	fndFlg = 1;
        mNod = elm0->edg[0].nod;
      }
      else if((ALG_SQR(ePos[1].vtX - pos.vtX) +
	       ALG_SQR(ePos[1].vtY - pos.vtY)) < WLZ_MESH_TOLERANCE_SQ)
      {
	fndFlg = 1;
        mNod = elm0->edg[1].nod;
      }
      else if((ALG_SQR(ePos[2].vtX - pos.vtX) +
	       ALG_SQR(ePos[2].vtY - pos.vtY)) < WLZ_MESH_TOLERANCE_SQ)
      {
	fndFlg = 1;
        mNod = elm0->edg[2].nod;
      }
      else if((eArea[1] = WlzGeomTriangleSnArea2(ePos[1], ePos[2], pos)) < 0.0)
      {
	elm1 = (elm0->edg[1].opp)? elm0->edg[1].opp->elm: NULL;
      }
      else if((eArea[2] = WlzGeomTriangleSnArea2(ePos[2], ePos[0], pos)) < 0.0)
      {
	elm1 = (elm0->edg[2].opp)? elm0->edg[2].opp->elm: NULL;
      }
      else if(eArea[0] - eArea[1] - eArea[2] < 0.0)
      {
	elm1 = (elm0->edg[0].opp)? elm0->edg[0].opp->elm: NULL;
      }
      else
      {
        fndFlg = 1;
      }
      if(elm1 == NULL)
      {
        /* Check if the vertex is within the mesh as it may be on the
	 * boundary of the mesh. */
	if((pos.vtX >= mesh->bBox.xMin) && (pos.vtX <= mesh->bBox.xMax) &&
	   (pos.vtY >= mesh->bBox.yMin) && (pos.vtY <= mesh->bBox.yMax))
        {
	  fndFlg = 1;
	}
	else
	{
	  elm0 = NULL;
	}
      }
      else
      {
        elm0 = elm1;
      }
    }
  }
  if(dstElm)
  {
    *dstElm = elm0;
  }
  if(dstElmSA2)
  {
    *dstElmSA2 = eArea[0];
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mNod);
}

/*!
* \return	Element centroid.
* \ingroup      WlzMesh
* \brief	Computes the centroid of the given mesh element.
* \param	elm			Given element.
*/
WlzDVertex2	WlzMeshElmCentroid2D(WlzMeshElm2D *elm)
{
  WlzDVertex2	ctr;
  WlzDVertex2	*pos0,
  		*pos1,
		*pos2;

  pos0 = &(elm->edg[0].nod->pos);
  pos1 = &(elm->edg[1].nod->pos);
  pos2 = &(elm->edg[2].nod->pos);
  ctr.vtX = (pos0->vtX + pos1->vtX + pos2->vtX) / 3.0;
  ctr.vtY = (pos0->vtY + pos1->vtY + pos2->vtY) / 3.0;
  return(ctr);
}


/*!
* \return	Other node of element.
* \ingroup	WlzMesh
* \brief	Finds a mesh node of the given element which is not one of
*		the two given nodes.
* \param	elm			Mesh element.
* \param	nod0			First mesh node.
* \param	nod1			Second mesh node.
*/

WlzMeshNod2D	*WlzMeshElmOtherNod(WlzMeshElm2D *elm,
				WlzMeshNod2D *nod0, WlzMeshNod2D *nod1)
{
  int		idE;
  WlzMeshNod2D	*nod2;

  idE = 0;
  while((idE < 3) &&
        ((nod2 = elm->edg[idE].nod) != nod0) && (nod2 != nod1))
  {
    ++idE;
  }
  return(nod2);
}

/*!
* \return	Mesh edge or NULL if there is no edge between the pair of
* 		nodes.
* \ingroup	WlzMesh
* \brief	Finds a mesh edge which runs between the two given mesh nodes.
* \param	nod0			First mesh node.
* \param	nod1			Second mesh node.
*/
WlzMeshEdg2D	*WlzMeshEdgShareNod2D(WlzMeshNod2D *nod0, WlzMeshNod2D *nod1)
{
  int		status;
  WlzMeshEdg2D	edg0,
  		*edg = NULL;

  status = 0;
  edg = nod0->edg;
  /* Search CW around nod0 for an opposite edge directed from nod1. */
  while(status == 0)
  {
    if(edg->opp)
    {
      if(edg->opp->nod == nod1)
      {
	status = 1; 						/* Found it. */
      }
      else
      {
        edg = edg->opp->next;
	if(edg == nod0->edg)
	{
	  status = 2;		     /* Completed the circuit and not found. */
	}
      }
    }
    else
    {
      status = 3;				/* Have hit a mesh boundary. */
    }
  }
  if(status == 3)
  {
    /* Have hit a mesh boundary so try looking CCW for a edge directed from
     * nod1. */
    status = 0;
    edg = nod0->edg->next->next;
    while(status == 0)
    {
      if(edg->nod == nod1)
      {
        status = 1;						/* Found it. */
      }
      else
      {
        if(edg->opp) 
	{
	  edg = edg->opp->next->next;
	}
	else
	{
	  status = 3;				/* Have hit a mesh boundary. */
	}
      }
    }
  }
  if(status != 1)
  {
    edg = NULL;
  }
  return(edg);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Initialises a new mesh by adding a 2D bounding box with
*		additional vertices along the box edges to keep the
*		inter node distance below the given value.
* \param	mesh			The given mesh.
* \param	wSp			Mesh workspace pointer
* \param	meshMaxDst		Maximum distance between mesh nodes.
* \param	bBox			The bounding box.
*/
WlzErrorNum	WlzMeshAddBBox2D(WlzMesh2D *mesh, WlzMeshWSp2D *wSp,
				 double meshMaxDst, WlzDBox2 bBox)
{
  int		idN,
  		edgVtxCntTot;
  WlzDVertex2	pos[4];
  WlzMeshNod2D	*nod[4];
  WlzMeshEdg2D	*edg[2];
  WlzMeshElm2D	*elm[2];
  WlzIVertex2	edgVtxCnt;
  WlzDVertex2	edgVtxStep;
  WlzDVertex2	*edgVtxP,
  		*edgVtxBuf = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    mesh->bBox = bBox;
    /* Create the new nodes at the corners of the bounding box. */
    (pos + 0)->vtX = (pos + 3)->vtX = bBox.xMin;
    (pos + 0)->vtY = (pos + 1)->vtY = bBox.yMin;
    (pos + 1)->vtX = (pos + 2)->vtX = bBox.xMax;
    (pos + 2)->vtY = (pos + 3)->vtY = bBox.yMax;
    idN = 0;
    do
    {
      nod[idN] = WlzMeshNewNod2D(mesh, pos[idN], &errNum);
      if(errNum == WLZ_ERR_NONE)
      {
        nod[idN]->flags = WLZ_MESH_NODE_FLAGS_BBOX;
      }
    } while((++idN < 4) && (errNum == WLZ_ERR_NONE));
  }
  /* Create a pair of new elements. */
  if(errNum == WLZ_ERR_NONE)
  {
    elm[0] = WlzMeshNewElm2D(mesh, nod[0], nod[1], nod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    elm[1] = WlzMeshNewElm2D(mesh, nod[1], nod[2], nod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    /* Join the elements. */
    edg[0] = nod[0]->edg->next;
    edg[1] = nod[2]->edg->next;
    edg[0]->opp = edg[1];
    edg[1]->opp = edg[0];
    mesh->elm = elm[0];
    /* Allocate a buffer for vertices along the edges of the bounding box. */
    edgVtxCnt.vtX = (int )floor((bBox.xMax - bBox.xMin) / meshMaxDst);
    edgVtxCnt.vtY = (int )floor((bBox.yMax - bBox.yMin) / meshMaxDst);
    edgVtxCntTot = 2 * (edgVtxCnt.vtX + edgVtxCnt.vtY);
    if((edgVtxBuf = (WlzDVertex2 *)
    		    AlcMalloc(sizeof(WlzDVertex2) * edgVtxCntTot)) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    edgVtxStep.vtX = (bBox.xMax - bBox.xMin) / (edgVtxCnt.vtX + 1);
    edgVtxStep.vtY = (bBox.yMax - bBox.yMin) / (edgVtxCnt.vtY + 1);
    edgVtxP = edgVtxBuf;
    for(idN = 1; idN <= edgVtxCnt.vtX; ++idN)
    {
      (edgVtxP + 1)->vtX = edgVtxP->vtX = bBox.xMin + (idN * edgVtxStep.vtX);
      edgVtxP->vtY = bBox.yMin;
      (edgVtxP + 1)->vtY = bBox.yMax;
      edgVtxP += 2;
    }
    for(idN = 1; idN <= edgVtxCnt.vtY; ++idN)
    {
      (edgVtxP + 1)->vtY = edgVtxP->vtY = bBox.yMin + (idN * edgVtxStep.vtY);
      edgVtxP->vtX = bBox.xMin;
      (edgVtxP + 1)->vtX = bBox.xMax;
      edgVtxP += 2;
    }
    errNum = WlzMeshVtxAddD2(mesh, wSp, NULL, edgVtxCntTot, edgVtxBuf, 0.5,
    			     WLZ_MESH_NODE_FLAGS_BBOX);
  }
  AlcFree(edgVtxBuf);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup 	WlzMesh
* \brief	Creates mesh boundaries with chains of linked boundary
*		segments and adds the boundary vertices to the given mesh.
*		This is a recursive function.
* \param	mesh			Given mesh.
* \param	wSp			Mesh workspace.
* \param	bufSz			Current size of buffer.
* \param	buf			Buffer for polyline vertex type
*					conversion which is reallocated and
*					reused as required.
* \param	bnd			Given boundary list.
*/
static WlzErrorNum WlzMeshBoundAdd(WlzMesh2D *mesh, WlzMeshWSp2D *wSp,
				   int *bufSz, WlzDVertex2 **buf,
				   WlzBoundList *bnd)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzMeshBndPolyAdd(mesh, wSp, bufSz, buf, bnd->poly);
  if(bnd->next && (errNum == WLZ_ERR_NONE))
  {
    errNum = WlzMeshBoundAdd(mesh, wSp, bufSz, buf, bnd->next);
  }
  if(bnd->down && (errNum == WLZ_ERR_NONE))
  {
    errNum = WlzMeshBoundAdd(mesh, wSp, bufSz, buf, bnd->down);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup 	WlzMesh
* \brief	Creates a new mesh boundary with a chain of linked boundary
* 		segments and adds the boundary vertices to the given mesh.
* \param	mesh			Given mesh.
* \param	wSp			Mesh workspace.
* \param	bufSz			Current size of buffer.
* \param	buf			Buffer for polyline vertex type
*					conversion which is reallocated and
*					reused as required.
* \param	poly			Given polygon domain.
*/
static WlzErrorNum WlzMeshBndPolyAdd(WlzMesh2D *mesh, WlzMeshWSp2D *wSp,
				     int *bufSz, WlzDVertex2 **buf,
				     WlzPolygonDomain *poly)
{
  WlzMeshBnd2D	*nBnd = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  nBnd = WlzMeshNewBnd2D(mesh, &errNum);
  if(errNum == WLZ_ERR_NONE)
  {
    WlzMeshInsertBnd2D(mesh, nBnd);
    switch(poly->type)
    {
      case WLZ_POLYGON_INT:
      case WLZ_POLYGON_FLOAT:
	if(*bufSz < poly->nvertices)
	{
	  *bufSz = poly->nvertices * 2;
	  if((*buf = (WlzDVertex2 *)AlcRealloc(*buf, sizeof(WlzDVertex2) *
						     *bufSz)) == NULL)
	  {
	    errNum = WLZ_ERR_MEM_ALLOC;
	  }
	}
	if(errNum == WLZ_ERR_NONE)
	{
	  if(WLZ_POLYGON_INT)
	  {
	    WlzValueCopyIVertexToDVertex(*buf, poly->vtx, poly->nvertices);
	  }
	  else
	  {
	    WlzValueCopyFVertexToDVertex(*buf, (WlzFVertex2 *)(poly->vtx),
					 poly->nvertices);
	  }
	  errNum = WlzMeshVtxAddD2(mesh, wSp, nBnd,
				   poly->nvertices, *buf,
				   0.5, WLZ_MESH_NODE_FLAGS_POLY);
	}
	break;
      case WLZ_POLYGON_DOUBLE:
	errNum = WlzMeshVtxAddD2(mesh, wSp, nBnd,
				 poly->nvertices, (WlzDVertex2 *)(poly->vtx),
				 0.5, WLZ_MESH_NODE_FLAGS_POLY);
	break;
      default:
	errNum = WLZ_ERR_DOMAIN_TYPE;
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds the given buffer of vertices to the given mesh
*		creating new nodes for and vertices that are not in the
*		mesh and setting the flags of each node.
*		If a boundary is given new boundary segments are created
*		and added to the boundary.
* \param	mesh			Given mesh.
* \param	wSp			Mesh workspace.
* \param	bnd			New boundary, may be NULL.
* \param	nVtx			Number of vertices.
* \param	vtxP			Vertices.
* \param	minDistSq		Square of minimum distance between
* 					nodes.
* \param	flags			Flags to set for each node.
*/
WlzErrorNum	WlzMeshVtxAddD2(WlzMesh2D *mesh, WlzMeshWSp2D *wSp,
				WlzMeshBnd2D *bnd,
				int nVtx, WlzDVertex2 *vtxP,
				double minDistSq, unsigned int flags)
/* TODO e flags too */
{
  int		idE,
		idN,
		idV,
		insFlg,
		tstVtxFlag,
		fstVtxFlg = 1;
  double	elmSA2;
  WlzMeshNod2D	*nod;
  WlzMeshElm2D	*elm,
  		*sElm;
  WlzMeshSeg2D	*seg;
  WlzDVertex2	vtx,
  		tstVtx,
		lstVtx;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
#ifdef WLZ_MESH_DEBUG
  WlzMeshElm2D	*badElm = NULL;
#endif /* WLZ_MESH_DEBUG */

  idV = 0;
  sElm = NULL;
  lstVtx= *vtxP;				 /* Just to keep lint happy. */
  while((errNum == WLZ_ERR_NONE) && (idV < nVtx))
  {
    vtx = *(vtxP + idV);
    if(fstVtxFlg)
    {
      insFlg = 1;
      fstVtxFlg = 0;
    }
    else
    {
      WLZ_VTX_2_SUB(tstVtx, lstVtx, vtx);
      insFlg = WLZ_VTX_2_SQRLEN(tstVtx) >= minDistSq;
    }
    if(insFlg)
    {
      /* Ignore all vertices outside the bounding box of the mesh. */
      insFlg = (vtx.vtX >= mesh->bBox.xMin) && (vtx.vtY >= mesh->bBox.yMin) &&
               (vtx.vtX <= mesh->bBox.xMax) && (vtx.vtY <= mesh->bBox.yMax);
    }
    if(insFlg)
    {
      /* Find element within which the new node position is contained and
       * a possible existing node which matches the new node position. */
      nod = WlzMeshMatchNodAndElm2D(mesh, vtx, sElm, &elm, &elmSA2, &errNum);
      if((errNum == WLZ_ERR_NONE) && (elm == NULL))
      {
	errNum = WLZ_ERR_DOMAIN_DATA;
      }
      if((errNum == WLZ_ERR_NONE) && (nod == NULL) && (elmSA2 >= minDistSq))
      {
	/* Check new vertex is outside of minimum distance from a node. */
	idE = 0;
	while(insFlg && (idE < 3))
	{
	  nod = elm->edg[idE].nod;
	  if((nod->flags & WLZ_MESH_NODE_FLAGS_BBOX) == 0)
	  {
	    WLZ_VTX_2_SUB(tstVtx, nod->pos, vtx);
	    insFlg = WLZ_VTX_2_SQRLEN(tstVtx) >= minDistSq;
	  }
	  ++idE;
	}
	if(insFlg)
	{
	  /* Make a new node. */
	  if((nod = WlzMeshNewNod2D(mesh, vtx, &errNum)) != NULL)
	  {
	    nod->flags = flags;
	  }
	  if(errNum == WLZ_ERR_NONE)
	  {
	    if(bnd)
	    {
	      /* Make a new boundary segment. */
	      if((seg = WlzMeshNewSeg2D(mesh, &errNum)) != NULL)
	      {
		seg->nod = nod;
	        /* Add segment to mesh boundary. */
		WlzMeshBndInsertSeg2D(bnd, seg);
	      }
	    }
	  }
	  if(errNum == WLZ_ERR_NONE)
	  {
	    errNum = WlzMeshAddNod2D(mesh, wSp, nod, elm);
	  }
          lstVtx = vtx;
	}
        sElm = elm;
      }
    }
#ifdef WLZ_MESH_DEBUG
    if((errNum = WlzMeshVerify2D(mesh, &badElm)) != WLZ_ERR_NONE)
    {
      (void )fprintf(stderr, "Invalid mesh! Element %d, idV %d\n",
      		     badElm->idx, idV);
    }
#endif /* WLZ_MESH_DEBUG */
    ++idV;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds the given node to the existing 2D mesh.
* \param	mesh			Given mesh.
* \param	wSp			Mesh workspace.
* \param	nod			New node to add.
* \param	elm			Element which contains the new node.
*/
WlzErrorNum	WlzMeshAddNod2D(WlzMesh2D *mesh, WlzMeshWSp2D *wSp,
				WlzMeshNod2D *nod, WlzMeshElm2D *elm)
{
  int		idE;
  WlzErrorNum	errNum = WLZ_ERR_NONE; 

  /* Find elements in conflict with the new node vertex. Each
   * conflicting element will be marked as zombies. */
  wSp->cCnt = 0;
  errNum = WlzMeshBuildVtxConfElmVec2D(wSp, elm, elm, nod->pos);
  if(errNum == WLZ_ERR_NONE)
  {
    /* Replace conflicting elements. */
    errNum = WlzMeshReplaceNElm2D(mesh, wSp, nod);
  }
  /* Clear the zombie flag bits. */
  for(idE = 0; idE < wSp->cCnt; ++idE)
  {
    elm = *(WlzMeshElm2D **)AlcVectorItemGet(wSp->cElmVec, idE);
    elm->flags &= ~(WLZ_MESH_ELEM_FLAGS_ZOMBIE);
  }
  return(errNum);
}

/*!
* \return	Conflicting mesh boundary segment or NULL.
* \ingroup	WlzMesh
* \brief	Finds a boundary segement which conflicts with the given
*		vertex. A segment conflicts with a vertex if the vertex
*		lies within the diametral circle of the edge segment.
*		Given two mesh elements which have no nodes within
*		their circumcircles \f$C_1\f$ and \f$C_2\f$ (the Delaunay
*		open ball criterion) and a diametral circle \f$C\f$ for
*		the edge shared by the two elements then
*		\f$ B_1 \cap B_2 \subset B \subset B_1 \cup B_2 \f$.
* \param	mesh			Given mesh.
* \param	sElm			Element from which to search for
*					segment.
* \param	pos			Given vertex position.
* \param        dstErr                  Destination error pointer may be NULL.
*/
static WlzMeshSeg2D *WlzMeshNodConfSeg(WlzMesh2D *mesh,
				       WlzMeshElm2D *sElm, WlzDVertex2 vtx,
				       WlzErrorNum *dstErr)
{
  int		idE,
  		idN;
  WlzMeshEdg2D	*edg0,
  		*edg1;
  WlzMeshElm2D	*elm0 = NULL;
  WlzMeshSeg2D	*seg = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Find element which encloses the vertex. */
  (void )WlzMeshMatchNodAndElm2D(mesh, vtx, sElm, &elm0, NULL, &errNum);
  if(errNum == WLZ_ERR_NONE)
  {
    /* Conflicting segment will lie along an edge of either this element
     * or one of it's neighbours. */
    idE = 0;
    do
    {
      if((edg0 = elm0->edg[idE].opp) != NULL)
      {
	idN = 0;
	do
	{
	  edg1 = edg0->next;
	  if(edg0->seg &&
	     WlzGeomVertexInDiamCircle(edg0->nod->pos, edg1->nod->pos, vtx))
	  {
	    seg = edg0->seg;
	  }
	  edg0 = edg1;
	} while((seg == NULL) && (++idN < 3));
      }
    } while((seg == NULL) && (++idE < 3));
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(seg);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Recursively builds a vector of elements in conflict with the
*		given vertex. An element is in conflict with a vertex if
*		it lies within the circumcircle of an element. Each
*		conflicting element will have it's index made negative
*		on return.
*		The last element of the conflicting element vector will
*		have at least one edge wich is either on the boundary of
*		the mesh or is shared with a non-conflicting mesh element.
* \param	wSp			Mesh workspace.
* \param	sElm			Element which contains the vertex.
* \param	tElm			Element to test and possibly add to
*					the vector.
* \param	vtx			Given vertex.
*/
static WlzErrorNum WlzMeshBuildVtxConfElmVec2D(WlzMeshWSp2D *wSp,
				WlzMeshElm2D *sElm, WlzMeshElm2D *tElm,
				WlzDVertex2 vtx)
{
  int		idN;
  WlzMeshElm2D	*nElm;
  WlzMeshElm2D	**cElmP;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((sElm == tElm) ||
     WlzGeomInTriangleCircumcircle(tElm->edg[0].nod->pos,
     				   tElm->edg[1].nod->pos,
				   tElm->edg[2].nod->pos, vtx))
  {
    if((tElm->flags & WLZ_MESH_ELEM_FLAGS_ZOMBIE) == 0)
    {
      if((cElmP = (WlzMeshElm2D **)
                  AlcVectorExtendAndGet(wSp->cElmVec, wSp->cCnt)) == NULL)
      {
        errNum = WLZ_ERR_MEM_ALLOC;
      }
      else
      {
	++(wSp->cCnt);
	*cElmP = tElm;
	tElm->flags |= WLZ_MESH_ELEM_FLAGS_ZOMBIE;
	idN = 0;
	while((idN < 3) && (errNum == WLZ_ERR_NONE))
	{
	  if(tElm->edg[idN].opp &&
	     ((nElm = tElm->edg[idN].opp->elm) != NULL) &&
	     ((nElm->flags & WLZ_MESH_ELEM_FLAGS_ZOMBIE) == 0))
	  {
	    errNum = WlzMeshBuildVtxConfElmVec2D(wSp, sElm, nElm, vtx);
	  }
	  ++idN;
	}
      }
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Replaces those 2D mesh elements that are in the given vector
*		with the given new node.
* \param	mesh			Given mesh.
* \param	wSp			Mesh workspace.
* \param	nNod			New node.
*/
static WlzErrorNum WlzMeshReplaceNElm2D(WlzMesh2D *mesh, WlzMeshWSp2D *wSp,
					WlzMeshNod2D *nNod)
{
  WlzMeshElm2D	**cElmP;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(wSp->cCnt == 1)
  {
    cElmP = (WlzMeshElm2D **)AlcVectorItemGet(wSp->cElmVec, 0);
    errNum = WlzMeshReplace1Elm2D(mesh, *cElmP, nNod);
  }
  else
  {
    errNum = WlzMeshReplaceNWithNElm2D(mesh,  wSp, nNod);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Replaces a single 2D mesh element with 1 element (no action),
*		2 elements (1 new and 1 recycled) or 3 elements (2 new and 1
*		recycled) using the new node to split the element.
* \param	mesh			Given mesh.
* \param	elm			Element containing the new node
*					vertex.
* \param	nNod			New node.
*/
static WlzErrorNum WlzMeshReplace1Elm2D(WlzMesh2D *mesh,
				       WlzMeshElm2D *elm, WlzMeshNod2D *nNod)
{
  int		idE,
  		invId,
		withCnt = 0;
  WlzMeshEdg2D	*edg;
  WlzMeshNod2D	*sNod;
  WlzDVertex2	nVtx;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  nVtx = nNod->pos;
  edg = elm->edg[0].next;
  for(idE = 0; idE < 3; ++idE)
  {
    if(WlzGeomTriangleSnArea2(edg->nod->pos, edg->next->nod->pos,
			      nVtx) <= WLZ_MESH_TOLERANCE_SQ)
    {
      sNod = edg->next->next->nod;
    }
    else
    {
      ++withCnt;
    }
    edg = edg->next;
  }
  switch(withCnt)
  {
    case 2:
      errNum = WlzMeshReplace1With2Elm2D(mesh, elm, sNod, nNod);
      break;
    case 3:
      errNum = WlzMeshReplace1With3Elm2D(mesh, elm, nNod);
      break;
    default:
      errNum = WLZ_ERR_DOMAIN_DATA;
      break;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Replaces a single mesh element with 2 mesh elements,
*		(1 new and 1 recycled) which include the given new node.
*               \verbatim
                             sNod ----> O
                                       /|\
                                      / | \
                                     /  |  \
                                    /   |   \
                                   /    |    \
                                  /     |     \
                                 /      |<---------- New edges including
                        eEdg -> /0     2|1     0\    nEdg in nElm
                               /        |        \
                       eElm ----->      |      <----- nElm
                             /          |          \
                            /    1      |    2      \
                           O------------o------------O
                           ^            ^            ^
                           |            |            |
                         eNod1        nNod         eNod2
                \endverbatim
* \param	mesh			Given mesh transform.
* \param	eElm			Existing element containing the
*					new node.
* \param	sNod			Which of the existing elements nodes is
* 					shared between the two new elements.
* \param	nNod			New node to build into mesh.
*/
static WlzErrorNum WlzMeshReplace1With2Elm2D(WlzMesh2D *mesh,
					  WlzMeshElm2D *eElm,
					  WlzMeshNod2D *sNod,
					  WlzMeshNod2D *nNod)
{
  WlzMeshEdg2D 	*eEdg;
  WlzMeshElm2D	*nElm;
  WlzMeshNod2D	*eNod1,
  		*eNod2;
  WlzMeshEdg2D	*eOpp0,
  		*eOpp2;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Find nodes and opposites. */
  if(sNod == eElm->edg[0].nod)
  {
    eEdg = &(eElm->edg[0]);
  }
  else if(sNod == eElm->edg[1].nod)
  {
    eEdg = &(eElm->edg[1]);
  }
  else
  {
    eEdg = &(eElm->edg[2]);
  }
  eOpp0 = eEdg->opp;
  eNod1 = eEdg->next->nod;
  eNod2 = eEdg->next->next->nod;
  eOpp2 = eEdg->next->next->opp;
  /* Set the new node edge and it's flags depending on those of
   * eNod0 and eNod1 */
  nNod->edg = &(eElm->edg[2]);
  nNod->flags |= eNod1->flags & eNod2->flags &
                 (WLZ_MESH_NODE_FLAGS_POLY | WLZ_MESH_NODE_FLAGS_BBOX);
  nElm = WlzMeshNewElm2D(mesh, eNod2, sNod, nNod, &errNum);
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzMeshSetElm2D(eElm, sNod, eNod1, nNod);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    /* Set opposites outside the two elements. */
    eElm->edg[1].opp = nElm->edg[2].opp = NULL;
    if((eElm->edg[0].opp = eOpp0) != NULL)
    {
      eOpp0->opp = &(eElm->edg[0]);
    }
    if((nElm->edg[0].opp = eOpp2) != NULL)
    {
      eOpp2->opp = &(nElm->edg[0]);
    }
    /* Set opposites between the two elements. */
    eElm->edg[2].opp = &(nElm->edg[1]);
    nElm->edg[1].opp = &(eElm->edg[2]);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Replaces a single mesh element with 3 mesh elements,
*		(2 new and 1 recycled) which include the given new node.
*               \verbatim
                               eNod2 -> O
                                       /|\
                                      / | \
                             nElm1 ---> |  \
                                    /  2|1  \
                                   /    |  <---- nElm0
                           nNod ------> o    0\
                                 /0    / \     \
                                /    /     \2   \
                               /  1/         \   \
                              /  /2           1\  \
                             / /           ^     \ \
                            //          0  |       \\
                           O---------------|---------O
                           ^               |         ^
			   |                         |
			 eNod0           eElm      eNod1
                \endverbatim
* \param	mesh			Given mesh transform.
* \param	eElm			Existing element to split.
* \param	nNod			New node which splits the existing
*					element.
*/
static WlzErrorNum WlzMeshReplace1With3Elm2D(WlzMesh2D *mesh,
				WlzMeshElm2D *eElm, WlzMeshNod2D *nNod)
{
  int		idE;
  WlzMeshNod2D	*eNod[3];
  WlzMeshEdg2D	*eOpp[3];
  WlzMeshElm2D	*nElm0,
  		*nElm1;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  for(idE = 0; idE < 3; ++idE)
  {
    eNod[idE] = eElm->edg[idE].nod;
    eOpp[idE] = eElm->edg[idE].opp;
  }
  /* Create new elements nElm0 and nElm1. */
  if(((nElm0 = WlzMeshNewElm2D(mesh, eNod[1], eNod[2],
			       nNod, &errNum)) != NULL) &&
     ((nElm1 = WlzMeshNewElm2D(mesh, eNod[2], eNod[0],
			       nNod, &errNum)) != NULL))
  {
    errNum = WlzMeshSetElm2D(eElm, eNod[0], eNod[1], nNod);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    /* Set opposite edges outside of the element. */
    if((eElm->edg[0].opp = eOpp[0]) != NULL)
    {
      eOpp[0]->opp = &(eElm->edg[0]);
    }
    if((nElm0->edg[0].opp = eOpp[1]) != NULL)
    {
      eOpp[1]->opp = &(nElm0->edg[0]);
    }
    if((nElm1->edg[0].opp = eOpp[2]) != NULL)
    {
      eOpp[2]->opp = &(nElm1->edg[0]);
    }
    /* Set opposite edges inside of the element. */
    eElm->edg[1].opp = &(nElm0->edg[2]);
    eElm->edg[2].opp = &(nElm1->edg[1]);
    nElm0->edg[1].opp = &(nElm1->edg[2]);
    nElm0->edg[2].opp = &(eElm->edg[1]);
    nElm1->edg[1].opp = &(eElm->edg[2]);
    nElm1->edg[2].opp = &(nElm0->edg[1]);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Replaces all queued mesh elements (which always have a
*		convex hull) with elements that use the new node vertex.
*		This function is only ever called with more than one mesh
*		element enqueued.
*		Computing the number of nodes in the enqueued elements is
*		easy because the region is always convex with all it's
*		nodes on it's boundary. However the new node may lie
*		on one of the boundary edges, in which case one of
*		the resulting elements would have zero area. This is
*		checked for. The boundary of the conflicting elements
*		is found using the index of the conficting elements
*		which has been marked as free'd.
*		The last element of the conflicting element vector is known
*		to have at least one edge which is either on the boundary of
*		the mesh or is shared with a non-conflicting element.
*		The number of conflicting and resolved elements is known
*		because every triangulation of a polygon with N nodes has
*		N - 2 elements.
* \param	mesh			Given mesh.
* \param	wSp			Mesh workspace.
* \param	nNod			The new node.
*/
static WlzErrorNum WlzMeshReplaceNWithNElm2D(WlzMesh2D *mesh,
				WlzMeshWSp2D *wSp, WlzMeshNod2D *nNod)
{
  int		idE,
  		idN,
		nCnt;
  WlzMeshEdg2D	*edg0;
  WlzMeshElm2D	*elm0,
  		*elm1;
  WlzMeshNod2D	*nod0,
  		*nod1;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  nCnt = wSp->cCnt + 2;
  /* Extend the node and opposite element vectors ready for gathering
   * adjacencies around the conflicting element boundary polygon. */
  if((AlcVectorExtend(wSp->cNodVec, nCnt) != ALC_ER_NONE) ||
     (AlcVectorExtend(wSp->cOppVec, nCnt) != ALC_ER_NONE))
  {
     errNum = WLZ_ERR_MEM_ALLOC;
  }
  /* Find an edge of the conflicting elements boundary polygon, which will
   * have an opposite edge which is either NULL (boundary edge) or a
   * element which doesn't have it's zombie bit set. */
  idE = 0;
  elm0 = *(WlzMeshElm2D **)AlcVectorItemGet(wSp->cElmVec, wSp->cCnt - 1);
  while((idE < 3) &&
        (elm0->edg[idE].opp) &&
        ((elm0->edg[idE].opp->elm->flags & WLZ_MESH_ELEM_FLAGS_ZOMBIE) != 0))
  {
    ++idE;
  }
  if(idE > 2)
  {
    errNum = WLZ_ERR_DOMAIN_DATA;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    /* Find the circuit of opposite edges (those in non-conflicting elements)
     * on the boundary of the conflicting element polygon. */
    edg0 = &(elm0->edg[idE]);
    *(WlzMeshEdg2D **)AlcVectorItemGet(wSp->cOppVec, 0) = edg0->opp;
    *(WlzMeshNod2D **)AlcVectorItemGet(wSp->cNodVec, 0) = edg0->nod;
    for(idE = 1; idE < nCnt; ++idE)
    {
      do
      {
        if(edg0->opp &&
	   ((edg0->opp->elm->flags & WLZ_MESH_ELEM_FLAGS_ZOMBIE) != 0))
	{
	  edg0 = edg0->opp->next;
	}
	else
	{
	  edg0 = edg0->next;
	}
      } while(edg0->opp &&
              ((edg0->opp->elm->flags & WLZ_MESH_ELEM_FLAGS_ZOMBIE) != 0));
      *(WlzMeshEdg2D **)AlcVectorItemGet(wSp->cOppVec, idE) = edg0->opp;
      *(WlzMeshNod2D **)AlcVectorItemGet(wSp->cNodVec, idE) = edg0->nod;
    }
    /* Set adjacencies in the elements to fill the polygon, recycling the
     * conflicting elements and creating new ones as required. A zero
     * area element may occur if the new node lies along an edge of the
     conflicting element boundary polygon. */
    idE = 0;
    idN = 0;
    elm0 = NULL;
    nod1 = *(WlzMeshNod2D **)AlcVectorItemGet(wSp->cNodVec, 0);
    while(idN < nCnt)
    {
      nod0 = nod1;
      nod1 = *(WlzMeshNod2D **)
      	     AlcVectorItemGet(wSp->cNodVec, (idN + 1) % nCnt);
      if(WlzGeomTriangleSnArea2(nod0->pos, nod1->pos,
				nNod->pos) <= WLZ_MESH_TOLERANCE_SQ)
      {
	/* The new node lies on an edge of the conflicting element boundary
	 * polygon. Set it's flags depending on those of nod0 and nod1.
	 * Set the previous elm0->edg[1].opp = NULL.*/
	nNod->flags |= nod0->flags & nod1->flags &
		       (WLZ_MESH_NODE_FLAGS_POLY | WLZ_MESH_NODE_FLAGS_BBOX);
	if(elm0)
	{
	  elm0->edg[1].opp = NULL;
        }
      }
      else
      {
	/* Add element either recycling old or creating new. */
	if(idE < wSp->cCnt)
	{
	  elm1 = *(WlzMeshElm2D **)AlcVectorItemGet(wSp->cElmVec, idE);
	  errNum = WlzMeshSetElm2D(elm1, nod0, nod1, nNod);
	}
	else
	{
	  elm1 = WlzMeshNewElm2D(mesh, nod0, nod1, nNod, &errNum);
	}
	if(errNum == WLZ_ERR_NONE)
	{
	  elm1->edg[0].opp = *(WlzMeshEdg2D **)
	  		     AlcVectorItemGet(wSp->cOppVec, idN);
	  if(elm1->edg[0].opp != NULL)
	  {
	    elm1->edg[0].opp->opp = &(elm1->edg[0]);
	  }
	  if(elm0)
	  {
	    if(elm0->edg[1].nod == elm1->edg[0].nod)
	    {
	      elm0->edg[1].opp = &(elm1->edg[2]);
	      elm1->edg[2].opp = &(elm0->edg[1]);
	    }
	    else
	    {
	      elm1->edg[2].opp = NULL;
	    }
	  }
	}
	elm0 = elm1;
	++idE;
      }
      ++idN;
    }
    if(errNum == WLZ_ERR_NONE)
    {
      elm1 = *(WlzMeshElm2D **)AlcVectorItemGet(wSp->cElmVec, 0);
      if(elm0->edg[1].nod == elm1->edg[0].nod)
      {
	elm0->edg[1].opp = &(elm1->edg[2]);
	elm1->edg[2].opp = &(elm0->edg[1]);
      }
      else
      {
        elm1->edg[2].opp = NULL;
      }
    }
  }
  return(errNum);
}

/*!
* \return       New mesh.
* \ingroup      WlzMesh
* \brief        Creates a new 2D mesh from the given 2D spatial domain
*		object's boundary.
* \param        obj                     Given 2D domain object.
* \param	minArea			Minimum mesh element area.
* \param	maxArea			Maximum mesh element area.
* \param	minAng			Minimum mesh element angle.
* \param        dstErr                  Destination error pointer may be NULL.
*/
WlzMesh2D	*WlzMeshFromObjBnd2D(WlzObject *obj,
				     double minArea, double maxArea,
				     double minAng, WlzErrorNum *dstErr)
{
  int		tI0,
  		bufSz = 0;
  WlzMesh2D	*mesh = NULL;
  WlzMeshWSp2D	*wSp = NULL;
  WlzObject	*bndObj = NULL;
  WlzBoundList	*bnd = NULL;
  WlzDVertex2	*buf = NULL;
  WlzDVertex2	bdr;
  WlzDBox2	bBox;
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  if(obj->domain.core == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(maxArea < 1.0)
  {
    errNum = WLZ_ERR_PARAM_DATA;
  } else if((wSp = WlzMeshNewWSp2D()) == NULL)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  /* Compute decimated boundary list. */
  if(errNum == WLZ_ERR_NONE)
  {
    bndObj = WlzObjToBoundary(obj, 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    bnd = WlzBoundDecimate(bndObj->domain.b, 1.0, &errNum);
  }
  (void )WlzFreeObj(bndObj);
  /* Create a new mesh. */
  if(errNum == WLZ_ERR_NONE)
  {
    tI0 = WlzBoundVtxCount(bnd, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh = WlzMeshNew2D(tI0, tI0, tI0, 0, &errNum);
  }
  /* Add the bounding box of the boundary to the mesh. */
  if(errNum == WLZ_ERR_NONE)
  {
    bBox = WlzBoundingBox2D(obj, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    bdr.vtX = (bBox.xMax + 10.0 - bBox.xMin) / 10.0;
    bdr.vtY = (bBox.yMax + 10.0 - bBox.yMin) / 10.0;
    bBox.xMin -= bdr.vtX;
    bBox.yMin -= bdr.vtY;
    bBox.xMax += bdr.vtX;
    bBox.yMax += bdr.vtY;
    errNum = WlzMeshAddBBox2D(mesh, wSp, sqrt(maxArea), bBox);
  }
  /* Add boundary vertices to the mesh. */
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzMeshBoundAdd(mesh, wSp, &bufSz, &buf, bnd);
  }
  (void )WlzFreeBoundList(bnd);
  /* Refine the mesh for the required element geometry. */
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzMeshConform2D(mesh, wSp, minArea, maxArea, minAng);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    /* Mark elements which are outside the object's domain. */
    WlzMeshMarkOutsideElm(mesh, obj);
  }
  AlcFree(buf);
  (void )WlzMeshFreeWSp2D(wSp);
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	<void>
* \ingroup	WlzMesh
* \brief	Mark elements by setting the flags to indicate which
*		elements are outside the objects domain. This is done
*		by examining each of the boundary segments. Each of
*		the boundary segments must have two mesh elements
*		with one in and one outside the domain.
* \param	mesh			Given mesh.
* \param	obj			Object used to create the given mesh.
*/
static void	WlzMeshMarkOutsideElm(WlzMesh2D *mesh, WlzObject *obj)
{

  int		idE,
  		idN,
		bCnt,
		pCnt,
		nCnt,
		nElm,
  		inside;
  WlzDVertex2	pos;
  WlzMeshElm2D	*elm;
  WlzMeshNod2D	*nod;
  WlzMeshNod2D	*tNod[3];

  nElm = mesh->res.elm.maxEnt;
  for(idE = 0; idE < nElm; ++idE)
  {
    elm = (WlzMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
    if(elm->idx >= 0)
    {
      bCnt = pCnt = nCnt = inside = 0;
      for(idN = 0; idN < 3; ++idN)
      {
        nod = elm->edg[idN].nod;
	if(nod->flags & WLZ_MESH_NODE_FLAGS_BBOX)
	{
	  ++bCnt;
	}
	else if(nod->flags & WLZ_MESH_NODE_FLAGS_POLY)
	{
	  ++pCnt;
	}
	else
	{
	  tNod[nCnt++] = nod;
	}
      }
      if(bCnt == 0)
      {
        if(pCnt == 0)
	{
          pos = WlzMeshElmCentroid2D(elm);
	  inside = WlzInsideDomain(obj, 0.0, WLZ_NINT(pos.vtY),
	  			   WLZ_NINT(pos.vtX), NULL);
	}
	else
	{
	  switch(nCnt)
	  {
	    case 1:
	      inside = WlzInsideDomain(obj, 0.0,
	      			       WLZ_NINT(tNod[0]->pos.vtY),
				       WLZ_NINT(tNod[0]->pos.vtX), NULL);
	      break;
	    case 2:
	      inside = (WlzInsideDomain(obj, 0.0,
	      				WLZ_NINT(tNod[0]->pos.vtY),
	      				WLZ_NINT(tNod[0]->pos.vtX),
					NULL) != 0) &&
	               (WlzInsideDomain(obj, 0.0,
		       			WLZ_NINT(tNod[1]->pos.vtY),
	      				WLZ_NINT(tNod[1]->pos.vtX),
					NULL) != 0);
	      break;
	    case 3:
	      idN = 0;
	      inside = 1;
	      while(inside && (idN < 3))
	      {
	        pos.vtX = tNod[idN]->pos.vtX + tNod[(idN + 1) % 3]->pos.vtX;
	        pos.vtY = tNod[idN]->pos.vtY + tNod[(idN + 1) % 3]->pos.vtY;
		inside = WlzInsideDomain(obj, 0.0,
					 WLZ_NINT(pos.vtX), WLZ_NINT(pos.vtY),
					 NULL);
	        ++idN;
	      }
	      break;
	  }
	}
      }
      if(inside)
      {
	elm->flags &= ~(WLZ_MESH_ELEM_FLAGS_OUTSIDE);
      }
      else
      {
        elm->flags |= WLZ_MESH_ELEM_FLAGS_OUTSIDE;
      }
    }
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Makes the mesh conform to it's boundary and element
*		constraints.
* \param	mesh			Given mesh.
* \param	wSp			Mesh workspace.
* \param	minArea			Minimum mesh element area.
* \param	maxArea			Maximum mesh element area.
* \param	minAng			Minimum angle within a mesh element.
*/
WlzErrorNum 	WlzMeshConform2D(WlzMesh2D *mesh, WlzMeshWSp2D *wSp,
				 double minArea, double maxArea,
				 double minAng)
{
  int		idE,
		split,
		nElm,
  		nSplit;
  double	elmQ,
  		minQ,
		elmArea,
  		minAreaSq,
  		maxAreaSq,
  		cosMinAng;
  WlzDVertex2	cC;
  WlzMeshNod2D	*nNod;
  WlzMeshElm2D	*elm;
  WlzMeshSeg2D	*seg;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
#ifdef WLZ_MESH_DEBUG
  int		pass = 0;
#endif /* WLZ_MESH_DEBUG */

  minAreaSq = minArea * minArea;
  maxAreaSq = maxArea * maxArea;
  cosMinAng = 2.0 * cos(minAng);
  minQ = WlzMeshQuality2D(cosMinAng, maxAreaSq, maxAreaSq);
  do
  {
    nSplit = 0;
    errNum = WlzMeshConformBnd2D(mesh, wSp, &nSplit);
    /* TODO Use a priority que instead of testing every element. */
    idE = 0;
    nElm = mesh->res.elm.maxEnt;
    while((errNum == WLZ_ERR_NONE) && (idE < nElm))
    {
      elm = (WlzMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
	/* Test mesh element quality and refine if required. */
	elmQ = WlzMeshElmQuality2D(elm, maxAreaSq, cosMinAng, &errNum);
	if((errNum == WLZ_ERR_NONE) && (elmQ < minQ))
	{
	  if(WlzGeomTriangleCircumcentre(&cC, elm->edg[0].nod->pos,
					 elm->edg[1].nod->pos,
					 elm->edg[2].nod->pos) == 0)
	  {
	    errNum = WLZ_ERR_DOMAIN_DATA;
	  }
	  if((cC.vtX > mesh->bBox.xMin) &&
	     (cC.vtY > mesh->bBox.yMin) &&
	     (cC.vtX < mesh->bBox.xMax) &&
	     (cC.vtY < mesh->bBox.yMax))
	  {
	    /* If circumcentre falls within a mesh boundary segment
	     * diametral circle then split the boundary segment,
	     * otherwise split the mesh element. */
            if((nNod = WlzMeshNewNod2D(mesh, cC, &errNum)) != NULL)
	    {
	      if(((seg = WlzMeshNodConfSeg(mesh, elm, cC, &errNum)) == NULL) ||
	         (errNum == WLZ_ERR_NONE))
	      {
		elmArea = WlzMeshElmSnArea2D(elm);
		if((elmArea * elmArea) > minAreaSq)
		{
	          errNum = WlzMeshAddNod2D(mesh, wSp, nNod, elm);
	          ++nSplit;
		}
	      }
	      else
	      {
		do
		{
		  errNum = WlzMeshSplitSeg2D(mesh, wSp, seg);
	          ++nSplit;
	        } while((errNum == WLZ_ERR_NONE) &&
		        ((seg = WlzMeshNodConfSeg(mesh, elm, cC,
						  &errNum)) != NULL));
	      }
	    }
          }
	}
      }
      ++idE;
    }
#ifdef WLZ_MESH_DEBUG
      (void )fprintf(stderr,
		     "WlzMeshConform2D() pass = %d, nSplit = %d\n",
		     pass++, nSplit);
#endif /* WLZ_MESH_DEBUG */
  } while((errNum == WLZ_ERR_NONE) && (nSplit > 0) && (pass < 1000));
  return(errNum);
}

/*!
* \return	Twice the signed area.
* \ingroup	WlzMesh
* \brief	Computes twice the signed area of the 2D mesh element.
* \param	elm			Given mesh element.
*/
static double	WlzMeshElmSnArea2D(WlzMeshElm2D *elm)
{
  double	snA2;

  snA2 = WlzGeomTriangleSnArea2(elm->edg[0].nod->pos, elm->edg[1].nod->pos,
			        elm->edg[2].nod->pos);
  return(snA2);
}

/*!
* \return	A measure of the 2D mesh element quality.
* \ingroup	WlzMesh
* \brief	Computes a measure of 2D mesh element quality using:
*		\f$q = (1 - \cos{\theta})(\frac{a}{A})^2\f$
*		Where: \f$\cos{\theta}\f$ is the cosine of the minimum
*		mesh angle; \f$a\f$ is the area of the mesh element and
*		\f$A\f$ is the maximum area.
* \param	cosAng			Twice the cosine of elements
*					minimum internal angle.
* \param	areaSq			Square of element area.
* \param	maxAreaSq		Square of maximum area.
*/
static double	WlzMeshQuality2D(double cosAng, double areaSq,
				 double maxAreaSq)
{
  double 	quality;

  quality = 0.5 * (2.0 - cosAng) * (maxAreaSq / areaSq);
  return(quality);
}

/*!
* \return	A measure of the 2D mesh element quality.
* \ingroup	WlzMesh
* \brief	Computes a measure of the 2D mesh element quality from
*		the given element.
* \param	elm			Given element.
* \param	maxAreaSq		Square of minimum mesh element area.
* \param	cosMinAng		Twice the cosine of the minimum
* 					element minimum internal angle.
* \param        dstErr                  Destination error pointer may be NULL.
*/
static double	WlzMeshElmQuality2D(WlzMeshElm2D *elm,
				      double maxAreaSq, double cosMinAng,
				      WlzErrorNum *dstErr)
{
  int		idN,
		minIdx;
  double	lAA,
  		lBB,
		lCC,
		lBC,
		area,
		cosAng,
		quality = 0.0;
  double	lenSq[3];
  WlzDVertex2	dv;
  WlzMeshEdg2D	*edg;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  minIdx = 0;
  edg = &(elm->edg[1]);
  WLZ_VTX_2_SUB(dv, edg->nod->pos, edg->next->nod->pos);
  lenSq[0] = WLZ_VTX_2_SQRLEN(dv);
  for(idN = 1; idN < 3; ++idN)
  {
    edg = edg->next;
    WLZ_VTX_2_SUB(dv, edg->nod->pos, edg->next->nod->pos);
    lenSq[idN] = WLZ_VTX_2_SQRLEN(dv);
    if(lenSq[idN] < lenSq[minIdx])
    {
      minIdx = idN;
    }
  }
  if((area = WlzMeshElmSnArea2D(elm)) <= WLZ_MESH_TOLERANCE_SQ)
  {
    errNum = WLZ_ERR_DOMAIN_DATA;
  }
  else
  {
    cosAng = (lBB + lCC - lAA)  / lBC;
    quality = WlzMeshQuality2D(cosAng, area * area, maxAreaSq);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(quality);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Checks all boundary segments and splits any that
*		have any mesh nodes within their diametral circle.
* \param 	mesh			Given mesh.
* \param	wSp			Mesh workspace.
* \param	dstNSplit		Destination pointer for the number
*					of segments split, may be NULL.
*/
WlzErrorNum	WlzMeshConformBnd2D(WlzMesh2D *mesh, WlzMeshWSp2D *wSp,
				    int *dstNSplit)
{
  int		nSplit;
  WlzMeshBnd2D	*bnd;
  WlzMeshSeg2D	*seg;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  nSplit = 0;
  bnd = mesh->bnd;
  do
  {
    seg = bnd->seg;
    do
    {
      /* Check segment. */
#ifdef WLZ_MESH_DEBUG
      (void )fprintf(stderr,
		     "WlzMeshConformBnd2D() seg->nod->idx = %d\n",
		     seg->nod->idx);
#endif /* WLZ_MESH_DEBUG */
      if((seg->edg == NULL) ||
         (seg->nod != seg->edg->nod) ||
         (seg->next->nod != seg->edg->opp->nod))
      {
        if((seg->edg = WlzMeshEdgShareNod2D(seg->nod, seg->next->nod)) == NULL)
	{
          errNum = WlzMeshSplitSeg2D(mesh, wSp, seg);
          ++nSplit;
	}
	else
	{
	  seg->edg->seg = seg->edg->opp->seg = seg;
	}
      }
      seg = seg->next;
    } while(seg != bnd->seg);
    bnd = bnd->next;
  } while(bnd != mesh->bnd);
  if(dstNSplit)
  {
    *dstNSplit = nSplit;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Splits a mesh element by inserting a new node at it's
*		circumcentre.
* \param	mesh			Given mesh.
* \param	wSp			Mesh workspace.
* \param	elm			Mesh element to split.
* \param	flags			New node flags.
*/
WlzErrorNum 	WlzMeshSplitElm2D(WlzMesh2D *mesh, WlzMeshWSp2D *wSp,
				  WlzMeshElm2D *elm, unsigned int flags)
{
  WlzDVertex2	cC;
  WlzMeshNod2D	*nNod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(WlzGeomTriangleCircumcentre(&cC, elm->edg[0].nod->pos,
  				 elm->edg[1].nod->pos,
				 elm->edg[2].nod->pos) == 0)
  {
    errNum = WLZ_ERR_DOMAIN_DATA;
  }
  else
  {
    nNod = WlzMeshNewNod2D(mesh, cC, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    nNod->flags = flags;
    errNum = WlzMeshAddNod2D(mesh, wSp, nNod, elm);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Splits a mesh boundary segment by inserting a new node
*		at it's midpoint.
* \param	mesh			Given mesh.
* \param	wSp			Mesh workspace.
* \param	seg			Mesh segment to split.
*/
WlzErrorNum 	WlzMeshSplitSeg2D(WlzMesh2D *mesh, WlzMeshWSp2D *wSp,
				  WlzMeshSeg2D *seg)
{
  WlzDVertex2	mP;
  WlzMeshElm2D	*elm;
  WlzMeshSeg2D	*nSeg;
  WlzMeshNod2D	*nod0,
  		*nod1,
		*eNod,
  		*nNod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  nod0 = seg->nod;
  nod1 = seg->next->nod;
  mP.vtX = (nod0->pos.vtX + nod1->pos.vtX) / 2.0;
  mP.vtY = (nod0->pos.vtY + nod1->pos.vtY) / 2.0;
  elm = seg->nod->edg->elm;
  eNod = WlzMeshMatchNodAndElm2D(mesh, mP, elm, &elm, NULL, &errNum);
  if(elm && (eNod == NULL) && (errNum == WLZ_ERR_NONE))
  {
    if(((nSeg = WlzMeshNewSeg2D(mesh, &errNum)) != NULL) &&
       ((nNod = WlzMeshNewNod2D(mesh, mP, &errNum)) != NULL))
    {
      nSeg->nod = nNod;
      WlzMeshSegAppendSeg2D(seg, nSeg);
      nNod->flags |= nod0->flags & nod1->flags &
                     (WLZ_MESH_NODE_FLAGS_BBOX | WLZ_MESH_NODE_FLAGS_POLY);
      errNum = WlzMeshAddNod2D(mesh, wSp, nNod, elm);
    }
    if(errNum == WLZ_ERR_NONE)
    {
      seg->edg = WlzMeshEdgShareNod2D(seg->nod, seg->next->nod);
      if(seg->edg)
      {
        seg->edg->seg = seg->edg->opp->seg = seg;
      }
      nSeg->edg = WlzMeshEdgShareNod2D(nSeg->nod, nSeg->next->nod);
      if(nSeg->edg)
      {
        nSeg->edg->seg = nSeg->edg->opp->seg = nSeg;
      }
    }
  }
  return(errNum);
}

#ifdef WLZ_MESH_DEBUG_MAIN

/*!
* \return	<void>
* \ingroup      WlzTransform
* \brief	Debuging function for 2D mesh output in VTK format.
* \param	fP			Given file pointer.
* \param	mesh			Given mesh.
* \param	allElm			Output all elements if non zero.
*/
void		WlzMeshDbgOutVTK2D(FILE *fP, WlzMesh2D *mesh, int allElm)
{
  int		idE,
		idN,
		bCnt,
		nElm,
		nVElm,
  		nNod;
  WlzMeshElm2D  *elm;
  WlzMeshNod2D	*nod;

  if(mesh && (mesh->type == WLZ_MESH_TRI2D) &&
    ((nNod = mesh->res.nod.numEnt) > 0) &&
    ((nElm = mesh->res.elm.numEnt) > 0))
  {
    (void )fprintf(fP,
		   "# vtk DataFile Version 1.0\n"
		   "WlzMesh2D 2D\n"
		   "ASCII\n"
		   "DATASET POLYDATA\n"
		   "POINTS %d float\n",
		   nNod);
    for(idN = 0; idN < nNod; ++idN)
    {
      nod = (WlzMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	(void )fprintf(fP, "%g %g 0\n",
		       nod->pos.vtX, nod->pos.vtY);
      }
      else
      {
	(void )fprintf(fP, "0 0 0\n");
      }
    }
    nVElm = 0;
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if((elm->idx >= 0) &&
	 (allElm || ((elm->flags & WLZ_MESH_ELEM_FLAGS_OUTSIDE) == 0)))
      {
        ++nVElm;
      }
    }
    (void )fprintf(fP, "POLYGONS %d %d\n",
		   nVElm, nVElm * 4);
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if((elm->idx >= 0) &&
	 (allElm || ((elm->flags & WLZ_MESH_ELEM_FLAGS_OUTSIDE) == 0)))
      {
	(void )fprintf(fP, "3 %d %d %d\n",
		       elm->edg[0].nod->idx, elm->edg[1].nod->idx, 
		       elm->edg[2].nod->idx);
      }
    }
  }
}

extern char 	*optarg;
extern int 	optind,
		opterr,
		optopt;

int		main(int argc, char *argv[])
{
  int		ok = 1,
  		option,
  		usage = 0,
		allElm = 0;
  double	meshMinArea = 10.0,
  		meshMaxArea = 500.0,
  		meshMinAng = 20 * (WLZ_M_PI/ 180.0);
  FILE		*fP = NULL;
  char		*inObjFileStr,
  		*outFileStr;
  const char	*errMsgStr;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  WlzObject	*obj = NULL;
  WlzMesh2D 	*mesh = NULL;
  static char   optList[] = "ahm:M:o:";
  const char    inObjFileStrDef[] = "-",
  	        outFileStrDef[] = "-";

  opterr = 0;
  inObjFileStr = (char *)inObjFileStrDef;
  outFileStr = (char *)outFileStrDef;
  while((usage == 0) && ((option = getopt(argc, argv, optList)) != EOF))
  {
    switch(option)
    {
      case 'a':
        allElm = 1;
	break;
      case 'o':
        outFileStr = optarg;
	break;
      case 'M':
	if((sscanf(optarg, "%lg", &meshMaxArea) != 1) || (meshMaxArea < 1.0))
	{
	  usage = 1;
	}
	break;
      case 'h':
      default:
	usage = 1;
	break;
    }
  }
  ok = usage == 0;
  if(ok)
  {
    if((inObjFileStr == NULL) || (*inObjFileStr == '\0') ||
       (outFileStr == NULL) || (*outFileStr == '\0'))
    {
      ok = 0;
      usage = 1;
    }
    if(ok && (optind < argc))
    {
      if((optind + 1) != argc)
      {
        usage = 1;
        ok = 0;
      }
      else
      {
        inObjFileStr = *(argv + optind);
      }
    }
  }
  if(ok)
  {
    if((inObjFileStr == NULL) ||
       (*inObjFileStr == '\0') ||
       ((fP = (strcmp(inObjFileStr, "-")?
              fopen(inObjFileStr, "r"): stdin)) == NULL) ||
       ((obj = WlzAssignObject(WlzReadObj(fP, &errNum), NULL)) == NULL) ||
       (errNum != WLZ_ERR_NONE))
    {
      ok = 0;
      (void )fprintf(stderr,
                     "%s: failed to read object from file %s\n",
                     *argv, inObjFileStr);
    }
    if(fP && strcmp(inObjFileStr, "-"))
    {
      (void )fclose(fP); fP = NULL;
    }
  }
  if(ok)
  {
    mesh = WlzMeshFromObjBnd2D(obj, meshMinArea, meshMaxArea, meshMinAng,
    			       &errNum);
    if(errNum != WLZ_ERR_NONE)
    {
      ok = 0;
      (void )WlzStringFromErrorNum(errNum, &errMsgStr);
      (void )fprintf(stderr,
      		     "%s Failed to create conforming mesh transform, %s.\n",
      		     argv[0],
		     errMsgStr);
    }
  }
  if(ok)
  {
    if((fP = (strcmp(outFileStr, "-")?
	     fopen(outFileStr, "w"): stdout)) == NULL)
    {
      ok = 0;
      (void )fprintf(stderr,
		     "%s: Failed to open output file %s.\n",
		     argv[0], outFileStr);
    }
  }
  if(ok)
  {
    WlzMeshDbgOutVTK2D(fP, mesh, allElm);
  }
  if(fP && strcmp(outFileStr, "-"))
  {
    (void )fclose(fP); fP = NULL;
  }
  (void )WlzFreeObj(obj);
  if(usage)
  {
    fprintf(stderr,
            "Usage: %s [-h] [-o<output file>] [-M#] [-a] [<input object>]\n"
    	    "Computes a conforming mesh for the given input object.\n"
	    "Options are:\n"
	    "  -h  Help, prints this usage message.\n"
	    "  -M  Maximum mesh distance.\n"
	    "  -a  Output all elements not just those inside the object's\n"
	    "	   domain.\n"
	    "  -o  Output file.\n",
	    argv[0]);

  }
  return(!ok);
}
#endif /* WLZ_MESH_DEBUG_MAIN */
