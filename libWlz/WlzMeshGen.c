#if defined(__GNUC__)
#ident "MRC HGU $Id$"
#else
#if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
#pragma ident "MRC HGU $Id$"
#else
static char _WlzMeshGen_c[] = "MRC HGU $Id$";
#endif
#endif
/*!
* \file         libWlz/WlzMeshGen.c
* \author       Bill Hill
* \date         June 2003
* \version      $Id$
* \par
* Address:
*               MRC Human Genetics Unit,
*               Western General Hospital,
*               Edinburgh, EH4 2XU, UK.
* \par
* Copyright (C) 2005 Medical research Council, UK.
* 
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be
* useful but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
* PURPOSE.  See the GNU General Public License for more
* details.
*
* You should have received a copy of the GNU General Public
* License along with this program; if not, write to the Free
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA  02110-1301, USA.
* \brief	Functions for 2D and 3D conforming simplical mesh generation.
* 		Meshes generated by these functions will conform approximately
* 		to an objects boundaries.
*
* \ingroup	WlzMesh
* \todo         -
* \bug          None known.
*/

#include <stdio.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <Wlz.h>

static void			WlzCMeshAddNodToGrid2D(
				  WlzCMesh2D *mesh,
				  WlzCMeshNod2D *nod);
static void			WlzCMeshAddNodToGrid3D(
				  WlzCMesh3D *mesh,
				  WlzCMeshNod3D *nod);
static void			WlzCMeshRemNodFromGrid2D(
				  WlzCMesh2D *mesh,
				  WlzCMeshNod2D *nod);
static void			WlzCMeshRemNodFromGrid3D(
				  WlzCMesh3D *mesh,
				  WlzCMeshNod3D *nod);
static void			WlzCMeshEntMarkFree(
				  int *idx);
static void 			WlzCMeshRemEntCb(
				  WlzCMeshCbEntry **list,
				  WlzCMeshCbFn fn,
				  void *data);
static void			WlzCMeshNodAddEdu3D(
				  WlzCMeshNod3D *nod,
				  WlzCMeshEdgU3D *edu);
static WlzCMeshNod2D 		*WlzCMeshComputeBoundNod2D(
				  WlzCMesh2D *mesh,
				  WlzObject *obj,
				  WlzCMeshNod2D *nod0,
				  WlzCMeshNod2D *nod1,
				  double tol,
				  WlzErrorNum *dstErr);
static WlzCMeshNod3D 		*WlzCMeshComputeBoundNod3D(
				  WlzCMesh3D *mesh,
				  WlzObject *obj,
				  WlzCMeshNod3D *nod0,
				  WlzCMeshNod3D *nod1,
				  double tol,
				  WlzErrorNum *dstErr);
static WlzErrorNum 		WlzCMeshBoundConformElm2D1(
				  WlzCMesh2D *mesh,
				  WlzObject *obj,
				  WlzCMeshElm2D *elm,
				  WlzCMeshNod2D **nodBuf,
				  int nIdx0,
				  int nIdx1,
				  int nIdx2,
				  double tol);
static WlzErrorNum 		WlzCMeshBoundConformElm2D2(
				  WlzCMesh2D *mesh,
				  WlzObject *obj,
				  WlzCMeshElm2D *elm,
				  WlzCMeshNod2D **nodBuf,
				  int nIdx0,
				  int nIdx1,
				  int nIdx2,
				  double tol);
static WlzErrorNum 		WlzCMeshBoundConformElm3D1(
				  WlzCMesh3D *mesh,
				  WlzObject *obj,
				  WlzCMeshElm3D *elm,
				  WlzCMeshNod3D **nodBuf,
				  int nIdx0,
				  int nIdx1,
				  int nIdx2,
				  int nIdx3,
				  double tol);
static WlzErrorNum 		WlzCMeshBoundConformElm3D2(
				  WlzCMesh3D *mesh,
				  WlzObject *obj,
				  WlzCMeshElm3D *elm,
				  WlzCMeshNod3D **nodBuf,
				  int nIdx0,
				  int nIdx1,
				  int nIdx2,
				  int nIdx3,
				  double tol);
static WlzErrorNum 		WlzCMeshBoundConformElm3D3(
				  WlzCMesh3D *mesh,
				  WlzObject *obj,
				  WlzCMeshElm3D *elm,
				  WlzCMeshNod3D **nodBuf,
				  int nIdx0,
				  int nIdx1,
				  int nIdx2,
				  int nIdx3,
				  double tol);
static int			WlzCMeshCompLBTNodPos2D(
				  WlzDVertex2 *nPos,
				  WlzLBTDomain2D *lDom,
				  int idN,
				  WlzLBTNodeClass2D cls,
				  int rot);
static int			WlzCMeshCompLBTFceNodPos3D(
				  WlzDVertex3 *nPos,
				  WlzLBTDomain3D *lDom,
				  int idN,
				  int idF,
				  WlzLBTNodeClass2D cls,
				  int rot);
static int			WlzCMeshElmWalkPos2D(
				  WlzCMesh2D *mesh,
				  int elmIdx,
				  WlzDVertex2 gPos);
static int			WlzCMeshElmWalkPos3D(
				  WlzCMesh3D *mesh,
				  int elmIdx,
				  WlzDVertex3 gPos);
static int			WlzCMeshElmJumpPos2D(
				  WlzCMesh2D *mesh,
				  WlzDVertex2 gPos,
				  int *dstCloseNod);
static int			WlzCMeshElmJumpPos3D(
				  WlzCMesh3D *mesh,
				  WlzDVertex3 gPos,
				  int *dstCloseNod);
static double			WlzCMeshCompGridBSz2D(
				  int tnn,
				  double npb,
				  double sz0,
				  double sz1);
static double			WlzCMeshCompGridBSz3D(
				  int tnn,
				  double npb,
				  double sz0,
				  double sz1,
				  double sz2);
static WlzErrorNum 		WlzCMeshAddLBTNode2D(
				  WlzCMesh2D *mesh,
				  WlzLBTDomain2D *lDom,
				  WlzGreyValueWSpace *iGVWSp,
				  int idN);
static WlzErrorNum 		WlzCMeshAddLBTNode3D(
				  WlzCMesh3D *mesh,
				  WlzLBTDomain3D *lDom,
				  WlzGreyValueWSpace *iGVWSp,
				  int idN);
static WlzErrorNum 		WlzCMeshAddEntCb(
				  WlzCMeshCbEntry **list,
				  WlzCMeshCbFn fn,
				  void *data);
static WlzErrorNum 		WlzCMeshCallCallbacks(
				  void *meshP,
				  void *entP,
				  WlzCMeshCbEntry *entry);
static WlzErrorNum 		WlzCMeshElmFromLBTNode2D(
				  WlzCMesh2D *mesh,
				  WlzDVertex2 *nPos,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzLBTNodeClass2D cls,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmFromLBTNode3D(
				  WlzCMesh3D *mesh,
				  WlzDVertex3 *nPos,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzLBTNodeClass2D cls);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D0(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D1(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D2(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D3(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D4(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D5(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D0(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D1(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D2(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D3(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D4(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D5(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzIVertex2 		WlzCMeshBucketIdxVtx2D(
				  WlzCMesh2D *mesh,
				  WlzDVertex2 vtx);
static WlzIVertex3 		WlzCMeshBucketIdxVtx3D(
				  WlzCMesh3D *mesh,
				  WlzDVertex3 vtx);
static WlzCMeshElm2D 		*WlzCMeshAllocElm2D(
				  WlzCMesh2D *mesh);
static WlzCMeshElm3D 		*WlzCMeshAllocElm3D(
				  WlzCMesh3D *mesh);
static WlzCMeshEdgU2D 		*WlzCMeshEdgUseFindOpp2D(
				  WlzCMeshEdgU2D *gEdu);
static WlzCMeshFace 		*WlzCMeshFindOppFce(
				  WlzCMeshFace *gFce);

/*!
* \return	New 2D mesh.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh data structure with the resources
*		optimized for the given number of mesh elements and nodes.
*		It is better to under estimate the number of elements and
*		nodes rather than over estimate and if zero is given some
*		reasonable defaults will be used.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMesh2D	*WlzCMeshNew2D(WlzErrorNum *dstErr)
{
  WlzCMesh2D	*mesh = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	blkSz = 1024;

  if(errNum == WLZ_ERR_NONE)
  {
    if((mesh = (WlzCMesh2D *)AlcCalloc(1, sizeof(WlzCMesh2D))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->type = WLZ_CMESH_TRI2D;
    if(((mesh->res.nod.vec = AlcVectorNew(1, sizeof(WlzCMeshNod2D),
    					  blkSz, NULL)) == NULL) ||
       ((mesh->res.elm.vec = AlcVectorNew(1, sizeof(WlzCMeshElm2D),
       					  blkSz, NULL)) == NULL))
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum != WLZ_ERR_NONE)
  {
    (void )WlzCMeshFree2D(mesh);
    mesh = NULL;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	New 3D mesh.
* \ingroup	WlzMesh
* \brief	Creates a new 3D mesh data structure with the resources
*		optimized for the given number of mesh elements and nodes.
*		It is better to under estimate the number of elements and
*		nodes rather than over estimate and if zero is given some
*		reasonable defaults will be used.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMesh3D	*WlzCMeshNew3D(WlzErrorNum *dstErr)
{
  WlzCMesh3D	*mesh = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	blkSz = 1024;

  if(errNum == WLZ_ERR_NONE)
  {
    if((mesh = (WlzCMesh3D *)AlcCalloc(1, sizeof(WlzCMesh3D))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->type = WLZ_CMESH_TET3D;
    if(((mesh->res.nod.vec = AlcVectorNew(1, sizeof(WlzCMeshNod3D),
    					  blkSz, NULL)) == NULL) ||
       ((mesh->res.elm.vec = AlcVectorNew(1, sizeof(WlzCMeshElm3D),
       					  blkSz, NULL)) == NULL))
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum != WLZ_ERR_NONE)
  {
    (void )WlzCMeshFree3D(mesh);
    mesh = NULL;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 2D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 3D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewNodCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 2D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 3D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewElmCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \brief	Adds a 2D deleted node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \brief	Adds a 3D deleted node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelNodCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a 2D deleted element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a 3D deleted element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelElmCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new 2D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new 3D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewNodCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new 2D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new 3D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewElmCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted 2D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted 3D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelNodCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted 2D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted 3D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelElmCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds an entity callback to the given 2D mesh callback list.
* \param	list			Given callback list.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
static WlzErrorNum WlzCMeshAddEntCb(WlzCMeshCbEntry **list, WlzCMeshCbFn fn,
				    void *data)
{
  WlzCMeshCbEntry *newCbE = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(list && fn)
  {
    if((newCbE = (WlzCMeshCbEntry *)
    		 AlcMalloc(sizeof(WlzCMeshCbEntry))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
    else
    {
      newCbE->fn = fn;
      newCbE->data = data;
      newCbE->next = *list;
      *list = newCbE;
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes an entity callback from the given 2D mesh callback
*		list.
* \param	list			Given callback list.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
static void 	WlzCMeshRemEntCb(WlzCMeshCbEntry **list, WlzCMeshCbFn fn,
				 void *data)
{
  WlzCMeshCbEntry *cBE0,
  		*cBE1;

  if(list && ((cBE1 = *list) != NULL) && fn)
  {
    cBE0 = NULL;
    while((fn != cBE1->fn) && (data != cBE1->data) && cBE1->next)
    {
      cBE0 = cBE1;
      cBE1 = cBE1->next;
    }
    if((fn == cBE1->fn) && (data == cBE1->data))
    {
      if(cBE0)
      {
        cBE0->next = cBE1->next;
      }
      else
      {
        *list = NULL;
      }
      AlcFree(cBE1);
    }
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Calls all calbacks in the given list.
* \param	meshP			The mesh.
* \param	entP			The entity (node or element).
* \param	entry			Callback entry.
*/
static WlzErrorNum WlzCMeshCallCallbacks(void *meshP, void *entP,
				      WlzCMeshCbEntry *entry)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  while(entry && (errNum == WLZ_ERR_NONE))
  {
    if(entry->fn)
    {
      errNum = (*(entry->fn))(meshP, entP, entry->data);
    }
    entry = entry->next;
  }
  return(errNum);
}

/*!
* \return	New 2D mesh node.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh node at the given position. It is
*		assumed that a node does not already exist at the given
*		position but for efficiency this is not checked.
* \param	mesh			The mesh for resources.
* \param	pos			Position for the node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshNod2D	*WlzCMeshNewNod2D(WlzCMesh2D *mesh, WlzDVertex2 pos,
				  WlzErrorNum *dstErr)
{
  WlzCMeshNod2D	*nNod = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;


  if((nNod = WlzCMeshAllocNod2D(mesh)) == NULL)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  else
  {
    nNod->pos = pos;
    WlzCMeshAddNodToGrid2D(mesh, nNod);
  }
  if((errNum == WLZ_ERR_NONE) && mesh->res.nod.newEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nNod, mesh->res.nod.newEntCb);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nNod);
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Adds a new mesh node to the mesh's bucket grid.
*		It is assumed that the given node is not already in the
*		bucket grid but this is not checked for.
* \param	mesh			The mesh.
* \param	nod			New node to add.
*/
static void	WlzCMeshAddNodToGrid2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  WlzIVertex2	idx;
  WlzCMeshNod2D	**bktP;

  /* Find the bucket in the grid. */
  idx = WlzCMeshBucketIdxVtx2D(mesh, nod->pos);
  bktP = *(mesh->bGrid.buckets + idx.vtY) + idx.vtX;
  /* Add the node to the bucket. */
  nod->next = *bktP;
  *bktP = nod;
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Adds a new mesh node to the mesh's bucket grid.
*		It is assumed that the given node is not already in the
*		bucket grid but this is not checked for.
* \param	mesh			The mesh.
* \param	nod			New node to add.
*/
static void	WlzCMeshAddNodToGrid3D(WlzCMesh3D *mesh, WlzCMeshNod3D *nod)
{
  WlzIVertex3	idx;
  WlzCMeshNod3D	**bktP;

  /* Find the bucket in the grid. */
  idx = WlzCMeshBucketIdxVtx3D(mesh, nod->pos);
  bktP = *(*(mesh->bGrid.buckets + idx.vtZ) + idx.vtY) + idx.vtX;
  /* Add the node to the bucket. */
  nod->next = *bktP;
  *bktP = nod;
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Removes a mesh node from the mesh's bucket grid.
* \param	mesh			The mesh.
* \param	nod			New node to add.
*/
static void	WlzCMeshRemNodFromGrid2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  WlzCMeshNod2D	*nod0,
  		*nod1;
  WlzIVertex2	idx;
  WlzCMeshNod2D	**bktP;

  /* Find the bucket in the grid. */
  idx = WlzCMeshBucketIdxVtx2D(mesh, nod->pos);
  bktP = *(mesh->bGrid.buckets + idx.vtY) + idx.vtX;
  if(*bktP)
  {
    if(*bktP == nod)
    {
      *bktP = nod->next;
    }
    else
    {
      nod0 = *bktP;
      while(nod0)
      {
	nod1 = nod0->next;
	if(nod1 == nod)
	{
	  nod0->next = nod->next;
	  break;
	}
	nod0 = nod1;
      }
    }
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Removes a mesh node from the mesh's bucket grid.
* \param	mesh			The mesh.
* \param	nod			New node to add.
*/
static void	WlzCMeshRemNodFromGrid3D(WlzCMesh3D *mesh, WlzCMeshNod3D *nod)
{
  WlzCMeshNod3D	*nod0,
  		*nod1;
  WlzIVertex3	idx;
  WlzCMeshNod3D	**bktP;

  /* Find the bucket in the grid. */
  idx = WlzCMeshBucketIdxVtx3D(mesh, nod->pos);
  bktP = *(*(mesh->bGrid.buckets + idx.vtZ) + idx.vtY) + idx.vtX;
  if(*bktP)
  {
    if(*bktP == nod)
    {
      *bktP = nod->next;
    }
    else
    {
      nod0 = *bktP;
      while(nod0)
      {
	nod1 = nod0->next;
	if(nod1 == nod)
	{
	  nod0->next = nod->next;
	  break;
	}
	nod0 = nod1;
      }
    }
  }
}

/*!
* \return	New 3D mesh node.
* \ingroup	WlzMesh
* \brief	Creates a new 3D mesh node at the given position. A node
*		must not already exist at this position.
* \param	mesh			The mesh for resources.
* \param	pos			Position for the node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshNod3D	*WlzCMeshNewNod3D(WlzCMesh3D *mesh, WlzDVertex3 pos,
				  WlzErrorNum *dstErr)
{
  WlzCMeshNod3D	*nNod = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;


  if((nNod = WlzCMeshAllocNod3D(mesh)) == NULL)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  else
  {
    nNod->pos = pos;
    WlzCMeshAddNodToGrid3D(mesh, nNod);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nNod);
}

/*!
* \return	New 2D mesh node or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D mesh node and sets it's index. 
*		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshNod2D 	*WlzCMeshAllocNod2D(WlzCMesh2D *mesh)
{
  WlzCMeshEntRes	*nRes;
  WlzCMeshNod2D	*nod = NULL;
  
  nRes = &(mesh->res.nod);
  if((nod = (WlzCMeshNod2D *)
	    (AlcVectorExtendAndGet(nRes->vec, nRes->nextIdx))) != NULL)
  {
    ++(nRes->numEnt);
    ++(nRes->maxEnt);
    nod->idx = nRes->nextIdx++;
  }
  return(nod);
}

/*!
* \return	New 3D mesh node or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 3D mesh node and sets it's index. 
*		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshNod3D 	*WlzCMeshAllocNod3D(WlzCMesh3D *mesh)
{
  WlzCMeshEntRes	*nRes;
  WlzCMeshNod3D	*nod = NULL;
  
  nRes = &(mesh->res.nod);
  if((nod = (WlzCMeshNod3D *)
	    (AlcVectorExtendAndGet(nRes->vec, nRes->nextIdx))) != NULL)
  {
    ++(nRes->numEnt);
    ++(nRes->maxEnt);
    nod->idx = nRes->nextIdx++;
  }
  return(nod);
}
/*!
* \return	New 2D mesh element.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh element connecting the given
*		mesh nodes but does not connect this new mesh element
*		to the rest of the mesh apart from changing the parent
*		edges of the mesh nodes.
* \param	mesh			The mesh for resources.
* \param	nod0			First mesh node.
* \param	nod1			Second mesh node.
* \param	nod2			Third mesh node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshElm2D 	*WlzCMeshNewElm2D(WlzCMesh2D *mesh,
				  WlzCMeshNod2D *nod0, WlzCMeshNod2D *nod1,
				  WlzCMeshNod2D *nod2, WlzErrorNum *dstErr)
{
  WlzCMeshElm2D	*nElm = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((nod0 == NULL) || (nod1 == NULL) || (nod2 == NULL))
  {
    errNum = WLZ_ERR_PARAM_NULL;
  }
  else
  {
    if((nElm = WlzCMeshAllocElm2D(mesh)) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshSetElm2D(mesh, nElm, nod0, nod1, nod2);
  }
  if((errNum == WLZ_ERR_NONE) && mesh->res.elm.newEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nElm, mesh->res.elm.newEntCb);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nElm);
}

/*!
* \return	New 3D mesh element.
* \ingroup	WlzMesh
* \brief	Creates a new 3D mesh element connecting the given
*		mesh nodes but does not connect this new mesh element
*		to the rest of the mesh apart from changing the parent
*		edges of the mesh nodes.
* 		Each mesh element is composed of 4 faces and 4 nodes,
*		with each of the 4 faces having 3 edges. See the diagrams
*		accompanying the definition of WlzCMeshElm3D.
* \param	mesh			The mesh for resources.
* \param	nod0			First mesh node.
* \param	nod1			Second mesh node.
* \param	nod2			Third mesh node.
* \param	nod3			Fourth mesh node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshElm3D 	*WlzCMeshNewElm3D(WlzCMesh3D *mesh,
				  WlzCMeshNod3D *nod0, WlzCMeshNod3D *nod1,
				  WlzCMeshNod3D *nod2, WlzCMeshNod3D *nod3,
				  WlzErrorNum *dstErr)
{
  WlzCMeshElm3D	*nElm = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((nod0 == NULL) || (nod1 == NULL) || (nod2 == NULL) || (nod3 == NULL))
  {
    errNum = WLZ_ERR_PARAM_NULL;
  }
  else
  {
    if((nElm = WlzCMeshAllocElm3D(mesh)) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshSetElm3D(mesh, nElm, nod0, nod1, nod2, nod3);
  }
  if((errNum == WLZ_ERR_NONE) && mesh->res.elm.newEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nElm, mesh->res.elm.newEntCb);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nElm);
}
/*!
* \return	New 2D mesh element or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D mesh element and sets it's index. 
*		Internal edge connectivities are set.
* 		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
*/
static WlzCMeshElm2D *WlzCMeshAllocElm2D(WlzCMesh2D *mesh)
{
  WlzCMeshEntRes	*eRes;
  WlzCMeshElm2D	*elm = NULL;
  
  eRes = &(mesh->res.elm);
  if((elm = (WlzCMeshElm2D *)
	    (AlcVectorExtendAndGet(eRes->vec, eRes->nextIdx))) != NULL)
  {
    ++(eRes->numEnt);
    ++(eRes->maxEnt);
    elm->idx = eRes->nextIdx++;
    elm->edu[0].next = &(elm->edu[1]);
    elm->edu[1].next = &(elm->edu[2]);
    elm->edu[2].next = &(elm->edu[0]);
  }
  return(elm);
}

/*!
* \return	New 3D mesh element or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 3D mesh element and sets it's index. 
* 		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
*/
static WlzCMeshElm3D *WlzCMeshAllocElm3D(WlzCMesh3D *mesh)
{
  WlzCMeshEntRes	*eRes;
  WlzCMeshElm3D	*elm = NULL;
  
  eRes = &(mesh->res.elm);
  if((elm = (WlzCMeshElm3D *)
	    (AlcVectorExtendAndGet(eRes->vec, eRes->nextIdx))) != NULL)
  {
    ++(eRes->numEnt);
    ++(eRes->maxEnt);
    elm->idx = eRes->nextIdx++;
  }
  return(elm);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets up the edge and node connectivities within the given
*		2D mesh element.
*		The geometry of the element is checked to make sure that
*		it's area is greater than the mesh tolerance and that
*		the nodes are in CCW order. If this test fails an error
*		is returned.
* \param	mesh			The mesh.
* \param	elm			Given mesh element.
* \param	nod0			First mesh node of element.
* \param	nod1			Second mesh node of element.
* \param	nod2			Third mesh node of element.
*/
WlzErrorNum  	WlzCMeshSetElm2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm,
				     WlzCMeshNod2D *nod0, WlzCMeshNod2D *nod1,
				     WlzCMeshNod2D *nod2)
{
  int		idE,
  		idN;
  double	lenSq,
  		sA2;
  WlzCMeshEdgU2D *edu;
  WlzDVertex2	dsp;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  sA2 = WlzGeomTriangleSnArea2(nod0->pos, nod1->pos, nod2->pos);
  if(sA2 < WLZ_MESH_TOLERANCE_SQ)
  {
    /* Element either has a very small area or is CW. */
    errNum = WLZ_ERR_PARAM_DATA;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    elm->edu[0].nod = nod0;
    elm->edu[1].nod = nod1;
    elm->edu[2].nod = nod2;
    /* Set internal adjacencies and check for maximum edge length. */
    for(idE = 0; idE < 3; ++idE)
    {
      idN = (idE + 1) % 3;
      edu = &(elm->edu[idE]);
      edu->elm = elm;
      edu->next = &(elm->edu[idN]);
      if(edu->nod->edu)
      {
        edu->nnxt = edu->nod->edu->nnxt;
	edu->nod->edu->nnxt = edu;
      }
      else
      {
        edu->nnxt = edu;
	edu->nod->edu = edu;
      }
      WLZ_VTX_2_SUB(dsp, elm->edu[idE].nod->pos, elm->edu[idN].nod->pos);
      lenSq = WLZ_VTX_2_SQRLEN(dsp);
      if(lenSq > mesh->maxSqEdgLen)
      {
        mesh->maxSqEdgLen = lenSq;
      }
    }
    /* Set external adjacencies. */
    for(idE = 0; idE < 3; ++idE)
    {
      edu = &(elm->edu[idE]);
      if((edu->opp = WlzCMeshEdgUseFindOpp2D(edu)) != NULL)
      {
        edu->opp->opp = edu;
      }
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets up the edge and node connectivities within the given
*		3D mesh element. No opposites are changed.
*		The geometry of the element is checked to make sure that
*		it's volume is greater than the mesh tolerance, ie that
*		the nodes are correclty ordered and are not co planar.
*		If this test fails an error is returned.
* \param	mesh			The mesh.
* \param	elm			Given mesh element.
* \param	nod0			First mesh node of element.
* \param	nod1			Second mesh node of element.
* \param	nod2			Third mesh node of element.
* \param	nod3			Fourth mesh node of element.
*/
WlzErrorNum  	WlzCMeshSetElm3D(WlzCMesh3D *mesh, WlzCMeshElm3D *elm,
				     WlzCMeshNod3D *nod0, WlzCMeshNod3D *nod1,
				     WlzCMeshNod3D *nod2, WlzCMeshNod3D *nod3)
{
  int		idE,
  		idF,
		idN;
  double	lenSq,
  		sV6;
  WlzDVertex3	pos0,
  		pos1,
		dsp;
  WlzCMeshNod3D	*nod[4];
  WlzCMeshFace	*fce;
  WlzCMeshEdgU3D *edu;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  /* See the diagrams with the definition of WlzCMeshElm3D for the node,
   * edge and face numbering. */
  const int	edgNodTbl[4][3] = /* [fce, edu] -> node index within the
                                     element. */
		{
  		  {0, 1, 2},
  		  {0, 3, 1},
  		  {0, 2, 3},
  		  {2, 1, 3}
		};
  const int	nodTbl0[6] = {0, 0, 0, 1, 1, 2},
           	nodTbl1[6] = {1, 2, 3, 2, 3, 3};

  sV6 = WlzGeomTetraSnVolume6(nod0->pos, nod1->pos, nod2->pos, nod3->pos);
  if(sV6 < WLZ_MESH_TOLERANCE_SQ)
  {
    /* Either element has a very small volume or is colinear / coplanar. */
    errNum = WLZ_ERR_PARAM_DATA;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    nod[0] = nod0;
    nod[1] = nod1;
    nod[2] = nod2;
    nod[3] = nod3;
    /* Set up all the adjacencies. */
    for(idF = 0; idF < 4; ++idF)
    {
      fce = elm->face + idF;
      for(idE = 0; idE < 3; ++idE)
      {
        idN = (idE + 1) % 3;
        edu = fce->edu + idE;
	edu->nod = nod[edgNodTbl[idF][idE]];
	if(edu->nod->edu == NULL)
	{
	  edu->nod->edu = edu;
	}
	edu->next = fce->edu + idN;
	WlzCMeshNodAddEdu3D(edu->nod, edu); /* Sets edu->nnxt */
	edu->face = fce;
      }
      fce->opp = NULL;
      fce->elm = elm;
    }
    for(idF = 0; idF < 4; ++idF)
    {
      fce = elm->face + idF;
      if((fce->opp = WlzCMeshFindOppFce(fce)) != NULL)
      {
        fce->opp->opp = fce;
      }
    }
    /* Check for maximum edge length. */
    for(idE = 0; idE < 6; ++idE)
    {
      pos0 = nod[nodTbl0[idE]]->pos;
      pos1 = nod[nodTbl1[idE]]->pos;
      WLZ_VTX_3_SUB(dsp, pos0, pos1);
      lenSq = WLZ_VTX_3_SQRLEN(dsp);
      if(lenSq > mesh->maxSqEdgLen)
      {
        mesh->maxSqEdgLen = lenSq;
      }
    }
  }
  return(errNum);
}

/*!
* \return	Opposite face or NULL.
* \ingroup	WlzMesh
* \brief	Finds the face opposite to the given face within the mesh.
* 		This function is only needed when building a mesh.
* \param	gFce			Given face.
*/
static WlzCMeshFace *WlzCMeshFindOppFce(WlzCMeshFace *gFce)
{
  int		idM,
  		idN,
		cnt = 0;
  WlzCMeshNod3D	*tmp;
  WlzCMeshEdgU3D *fEdg,
  		*tEdg;
  WlzCMeshFace	*tFce,
  		*oFce = NULL;
  WlzCMeshNod3D *tNod[3];

  tEdg = fEdg = gFce->edu[0].nod->edu;
  do
  {
    cnt = 0;
    tFce = tEdg->face;
    if(tFce != gFce)
    {
      tNod[0] = tFce->edu[0].nod;
      tNod[1] = tFce->edu[1].nod;
      tNod[2] = tFce->edu[2].nod;
      for(idN = 0; idN < 3; ++idN)
      {
	for(idM = idN; idM < 3; ++idM)
	{
	  if(tNod[idM] == gFce->edu[idN].nod)
	  {
	    if(idN < 2)
	    {
	      tmp = tNod[idN];
	      tNod[idN] = tNod[idM];
	      tNod[idM] = tmp;
	    }
	    ++cnt;
	    break;
	  }
	}
	if(cnt != (idN + 1))
	{
	  break;
	}
      }
    }
    if(cnt == 3)
    {
      oFce = tFce;
      break;
    }
    tEdg = tEdg->nnxt;
  } while (tEdg != fEdg);
  return(oFce);
}

/*!
* \ingroup	WlzMesh
* \brief	Adds an edge use to the circular linked list of edges
* 		directed from the node. The node and edge use must both
* 		be valid and the use must not be in the list already.
* \param	nod			The node.
* \param	edu			The edge directed from the node.
*/
static void	WlzCMeshNodAddEdu3D(WlzCMeshNod3D *nod, WlzCMeshEdgU3D *edu)
{
  if(nod->edu == NULL)
  {
    nod->edu = edu->nnxt = edu;
  }
  else
  {
    edu->nnxt = nod->edu->nnxt;
    nod->edu->nnxt = edu;
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's the mesh, it's buckets, nodes and elements.
* \param	mesh			Mesh to free.
*/
WlzErrorNum	WlzCMeshFree(WlzCMeshP mesh)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh.v == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    switch(mesh.m2->type)
    {
      case WLZ_CMESH_TRI2D:
        errNum = WlzCMeshFree2D(mesh.m2);
	break;
      case WLZ_CMESH_TET3D:
        errNum = WlzCMeshFree3D(mesh.m3);
	break;
      default:
        errNum = WLZ_ERR_DOMAIN_TYPE;
	break;
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's the 2D mesh, it's buckets, nodes and elements.
* \param	mesh			Mesh to free.
*/
WlzErrorNum	WlzCMeshFree2D(WlzCMesh2D *mesh)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzUnlink(&(mesh->linkcount), &errNum))
  {
    (void )AlcVectorFree(mesh->res.elm.vec);
    (void )AlcVectorFree(mesh->res.nod.vec);
    (void )Alc2Free((void **)(mesh->bGrid.buckets));
    AlcFree(mesh);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's the 3D mesh, it's buckets, nodes and elements.
* \param	mesh			Mesh to free.
*/
WlzErrorNum	WlzCMeshFree3D(WlzCMesh3D *mesh)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzUnlink(&(mesh->linkcount), &errNum))
  {
    (void )AlcVectorFree(mesh->res.elm.vec);
    (void )AlcVectorFree(mesh->res.nod.vec);
    (void )Alc3Free((void ***)(mesh->bGrid.buckets));
    AlcFree(mesh);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 2D mesh node. This function assumes that the node
*		is no longer used by any elements.
* \param	mesh			The mesh to which the node belongs.
* \param	nod			The given node.
*/
WlzErrorNum	WlzCMeshDelNod2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (nod == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((errNum == WLZ_ERR_NONE) && mesh->res.nod.delEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nod, mesh->res.nod.delEntCb);
  }
  else
  {
    WlzCMeshRemNodFromGrid2D(mesh, nod);
    WlzCMeshNodFree2D(mesh, nod);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 3D mesh node. This function assumes that the node
*		is no longer used by any elements.
* \param	mesh			The mesh to which the node belongs.
* \param	nod			The given node.
*/
WlzErrorNum	WlzCMeshDelNod3D(WlzCMesh3D *mesh, WlzCMeshNod3D *nod)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (nod == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((errNum == WLZ_ERR_NONE) && mesh->res.nod.delEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nod, mesh->res.nod.delEntCb);
  }
  else
  {
    WlzCMeshRemNodFromGrid3D(mesh, nod);
    WlzCMeshNodFree3D(mesh, nod);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 2D mesh element and any mesh nodes that are
*		used exclusively by this mesh element. 
* \param	mesh			The mesh to which the element belongs.
* \param	elm			The given element.
*/
WlzErrorNum	WlzCMeshDelElm2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm)
{
  int		idE;
  WlzCMeshEdgU2D *edu0,
  		*edu1,
		*edu2;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

#ifdef WLZ_CMESH_DEBUG_VERIFY_DELETE
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
  }
#endif
  if((mesh == NULL) || (elm == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((errNum == WLZ_ERR_NONE) && mesh->res.elm.delEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, elm, mesh->res.elm.delEntCb);
  }
  else
  {
    for(idE = 0; idE < 3; ++idE)
    {
      edu0 = elm->edu + idE;
      /* Need to make sure that the opp - opp link is back to this
       * element and not some other that will replace it. */
      if((edu0->opp != NULL) && (edu0->opp->opp != NULL) &&
         (edu0->opp->opp->elm == elm))
      {
        edu0->opp->opp = NULL;
      }
      if(edu0 == edu0->nnxt)
      {
        (void )WlzCMeshDelNod2D(mesh, edu0->nod);
      }
      else
      {
        edu1 = edu0;
	while((edu2 = edu1->nnxt) != edu0)
	{
	  edu1 = edu2;
	}
	edu1->nnxt = edu0->nnxt;
	if(edu0->nod->edu == edu0)
	{
	  edu0->nod->edu = edu1;
	}
      }
    }
    WlzCMeshElmFree2D(mesh, elm);
  }
#ifdef WLZ_CMESH_DEBUG_VERIFY_DELETE
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 3D mesh element and any mesh nodes that are
*		used exclusively by this mesh element. 
* \param	mesh			The mesh to which the element belongs.
* \param	elm			The given element.
*/
WlzErrorNum	WlzCMeshDelElm3D(WlzCMesh3D *mesh, WlzCMeshElm3D *elm)
{
  int		idE,
  		idF;
  WlzCMeshEdgU3D *edu0,
  		*edu1,
		*edu2;
  WlzCMeshFace	*fce0;
  WlzErrorNum errNum = WLZ_ERR_NONE;

  for(idF = 0; idF < 4; ++idF)
  {
    fce0 = elm->face + idF;
    /* Unlink edge uses from the nodes. */
    for(idE = 0; idE < 3; ++idE)
    {
      edu0 = fce0->edu + idE;
      if(edu0 == edu0->nnxt)
      {
	/* Node is only used by this edge so it can be deleted. */
        (void )WlzCMeshDelNod3D(mesh, edu0->nod);
      }
      else
      {
        edu1 = edu0;
	edu2 = edu1->nnxt;
	while(edu2 != edu0)
	{
	  edu1 = edu2;
	  edu2 = edu2->nnxt;
	}
	edu1->nnxt = edu2->nnxt;
	edu1->nod->edu = edu1;
      }
    }
    /* Unlink face. Need to make sure that the opp - opp link is back to
     * this element and not some other that will replace it. */
    if((fce0->opp != NULL) && (fce0->opp->opp != NULL) &&
       (fce0->opp->opp->elm == elm))
    {
      fce0->opp->opp = NULL;
    }
  }
  WlzCMeshElmFree3D(mesh, elm);
  return(errNum);
}

/*!
* \return	<void>
* \ingroup	WlzMesh
* \brief	Sets the index to indicate that the mesh entity is free.
* \param	idx			Entity index pointer.
*/
static void	WlzCMeshEntMarkFree(int *idx)
{
  if(*idx >= 0)
  {
    *idx = -(*idx + 1);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given 2D mesh node. Actually just sets the
*		node's index to mark it freed and then decrements
*		the number of mesh nodes.
* \param	mesh			Input mesh
* \param	nod			Given mesh node.
*/
void 		WlzCMeshNodFree2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  if(nod && (nod->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(nod->idx));
    --(mesh->res.nod.numEnt);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given 3D mesh node. Actually just sets the
*		node's index to mark it freed and then decrements
*		the number of mesh nodes.
* \param	mesh			Input mesh
* \param	nod			Given mesh node.
*/
void 		WlzCMeshNodFree3D(WlzCMesh3D *mesh, WlzCMeshNod3D *nod)
{
  if(nod && (nod->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(nod->idx));
    --(mesh->res.nod.numEnt);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given 2D mesh element. Actually just sets the
*		element's index to mark it freed and then decrements
*		the number of mesh elements.
* \param	mesh			Input mesh
* \param	elm			Given mesh element.
*/
void		WlzCMeshElmFree2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm)
{
  if(elm && (elm->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(elm->idx));
    --(mesh->res.elm.numEnt);
  }
}

/*!
* \return	void
* \ingroup	WlzMesh
* \brief	Free's the given 3D mesh element. Actually just sets the
*		element's index to mark it freed and then decrements
*		the number of mesh elements.
* \param	mesh			Input mesh
* \param	elm			Given mesh element.
*/
void		WlzCMeshElmFree3D(WlzCMesh3D *mesh, WlzCMeshElm3D *elm)
{
  if(elm && (elm->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(elm->idx));
    --(mesh->res.elm.numEnt);
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Affine transforms the node positions of the given 2D mesh.
* \param	mesh			Given mesh.
* \param	tr			Affine transform.
*/
WlzErrorNum	WlzCMeshAffineTransformMesh2D(WlzCMesh2D *mesh,
					      WlzAffineTransform *tr)
{
  int		idN,
  		nNod;
  WlzCMeshNod2D	*nod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (tr == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzAffineTransformDimension(tr, NULL) != 2)
  {
    errNum = WLZ_ERR_TRANSFORM_TYPE;
  }
  else
  {
    /* Transform the nodes. */
    nNod = 0;
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	++nNod;
        nod->pos = WlzAffineTransformVertexD2(tr, nod->pos, NULL);
      }
    }
    /* Update the bounding box. */
    WlzCMeshUpdateBBox2D(mesh);
    /* Compute a new bucket grid and reassign nodes to it. */
    errNum = WlzCMeshReassignBuckets2D(mesh, nNod);
    /* Recompute maximum edge length. */
    WlzCMeshUpdateMaxSqEdgLen2D(mesh);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Affine transforms the node positions of the given 3D mesh.
* \param	mesh			Given mesh.
* \param	tr			Affine transform.
*/
WlzErrorNum	WlzCMeshAffineTransformMesh3D(WlzCMesh3D *mesh,
					      WlzAffineTransform *tr)
{
  int		idN,
  		nNod;
  WlzCMeshNod3D	*nod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (tr == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzAffineTransformDimension(tr, NULL) != 3)
  {
    errNum = WLZ_ERR_TRANSFORM_TYPE;
  }
  else
  {
    /* Transform the nodes. */
    nNod = 0;
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod3D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	++nNod;
        nod->pos = WlzAffineTransformVertexD3(tr, nod->pos, NULL);
      }
    }
    /* Update the bounding box. */
    WlzCMeshUpdateBBox3D(mesh);
    /* Recompute maximum edge length. */
    WlzCMeshUpdateMaxSqEdgLen3D(mesh);
    /* Compute a new bucket grid and reassign nodes to it. */
    errNum = WlzCMeshReassignBuckets3D(mesh, nNod);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Examines all the mesh elements deleting those with all
* 		elements outside and decomposing those on it's boundary.
* 		At the first pass boundary elements (those with between one
* 		and three nodes outside the object's domain) are decomposed
* 		into one or three new elements and elements which have all
* 		four nodes outside the domain are deleted. In the second
* 		pass new elements outside the domain are deleted.
* \param	mesh			Given mesh.
* \param	obj			Object with domain to which the
*					mesh should conform.
* \param	tol			Acceptable placement error.
*/
WlzErrorNum 	WlzCMeshBoundConform2D(WlzCMesh2D *mesh,
					WlzObject *obj,
					double tol)
{
  int		iMsk,
  		idE,
		idN,
		idM;
  WlzCMeshNod2D *nod;
  WlzCMeshElm2D	*elm;
  WlzCMeshNod2D *nodes[3];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  idE = 0;
  /* Pass 0: Classify elements by whether their nodes are inside the
   * domain of the given object. */
  idM = mesh->res.elm.maxEnt;
#ifdef WLZ_CMESH_DEBUG_VERIFY_CONFORM
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
  }
#endif
  while((errNum == WLZ_ERR_NONE) && (idE < idM))
  {
    elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
    if(elm->idx >= 0)
    {
      WlzCMeshElmGetNodes2D(elm, nodes + 0, nodes + 1, nodes + 2);
      /* Set mask depending on whether nodes are inside or outside the
       * domain. */
      iMsk = 0;
      for(idN = 0; idN < 3; ++idN)
      {
	nod = nodes[idN];
	if(WlzInsideDomain(obj,
			   0.0, nod->pos.vtY, nod->pos.vtX,
			   NULL))
	{
	  iMsk |= 1 << idN;
	}
      }
      elm->flags |= WLZ_CMESH_ELM_FLAG_OUTSIDE;
      switch(iMsk)
      {
	/* 0 nodes are inside the domain. */
	case 0:
	  (void )WlzCMeshDelElm2D(mesh, elm);
	  break;
	/* 1 node is inside the domain. */
	case  1: /*  1|001|1 */
	  errNum = WlzCMeshBoundConformElm2D2(mesh, obj, elm,
					      nodes, 1, 2, 0, tol);
	  break;
	case  2: /*  2|010|1 */
	  errNum = WlzCMeshBoundConformElm2D2(mesh, obj, elm,
					      nodes, 2, 0, 1, tol);
	  break;
	case  4: /*  4|100|1 */
	  errNum = WlzCMeshBoundConformElm2D2(mesh, obj, elm,
					      nodes, 0, 1, 2, tol);
	  break;
	  break;
	/* 2 nodes are inside the domain. */
	case  3: /*  3|011|2 */
	  errNum = WlzCMeshBoundConformElm2D1(mesh, obj, elm,
					      nodes, 2, 0, 1, tol);
	  break;
	case  5: /*  5|101|2 */
	  errNum = WlzCMeshBoundConformElm2D1(mesh, obj, elm,
					      nodes, 1, 0, 2, tol);
	  break;
	case  6: /*  6|110|2 */
	  errNum = WlzCMeshBoundConformElm2D1(mesh, obj, elm,
					      nodes, 0, 1, 2, tol);
	  break;
	case  7: /*  7|111|3 */
	  elm->flags &= ~(WLZ_CMESH_ELM_FLAG_BOUNDARY);
	  break;
	default:
	  break;
      }
    }
#ifdef WLZ_CMESH_DEBUG_VERIFY_CONFORM
    if(errNum == WLZ_ERR_NONE)
    {
      errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
    }
#endif
    ++idE;
  }
  /* Pass 1: Delete new elemets marked as boundary but outside the
   * given object's domain. */
  if(errNum == WLZ_ERR_NONE)
  {
    idE = 0;
    idM = mesh->res.elm.maxEnt;
    while((errNum == WLZ_ERR_NONE) && (idE < idM))
    {
      elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if((elm->idx >= 0) &&
         (elm->flags & WLZ_CMESH_ELM_FLAG_BOUNDARY) != 0)
      {
	WlzCMeshElmGetNodes2D(elm, nodes + 0, nodes + 1, nodes + 2);
	/* Set mask depending on whether nodes are inside or outside the
	 * domain. */
	iMsk = 0;
	for(idN = 0; idN < 3; ++idN)
	{
	  nod = nodes[idN];
	  if(WlzInsideDomain(obj,
			     0.0, nod->pos.vtY, nod->pos.vtX,
			     NULL))
	  {
	    iMsk |= 1 << idN;
	    break;
	  }
	}
	if(iMsk == 0)    /* All nodes of the element are outside the domain. */
	{
	  (void )WlzCMeshDelElm2D(mesh, elm);
	}
      } 
      ++idE;
    } 
  }
#ifdef WLZ_CMESH_DEBUG_VERIFY_CONFORM
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Examines all the mesh elements deleting those with all
* 		elements outside and decomposing those on it's boundary.
* 		At the first pass boundary elements (those with between one
* 		and three nodes outside the object's domain) are decomposed
* 		into one or three new elements and elements which have all
* 		four nodes outside the domain are deleted. In the second
* 		pass new elements outside the domain are deleted.
* \param	mesh			Given mesh.
* \param	obj			Object with domain to which the
*					mesh should conform.
* \param	tol			Acceptable placement error.
*/
WlzErrorNum 	WlzCMeshBoundConform3D(WlzCMesh3D *mesh,
					WlzObject *obj,
					double tol)
{
  int		iMsk,
  		idE,
		idN,
		idM;
  WlzCMeshNod3D *nod;
  WlzCMeshElm3D	*elm;
  WlzCMeshNod3D *nodes[4];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Pass 0: Classify elements by whether their nodes are inside the
   * domain of the given object. */
  idE = 0;
  idM = mesh->res.elm.maxEnt;
  while((errNum == WLZ_ERR_NONE) && (idE < idM))
  {
    elm = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
    if(elm->idx >= 0)
    {
      WlzCMeshElmGetNodes3D(elm,
			    nodes + 0, nodes + 1, nodes + 2, nodes + 3);
      /* Set mask depending on whether nodes are inside or outside the
       * domain. */
      iMsk = 0;
      for(idN = 0; idN < 4; ++idN)
      {
	nod = nodes[idN];
	if(WlzInsideDomain(obj,
			   nod->pos.vtZ, nod->pos.vtY, nod->pos.vtX,
			   NULL))
	{
	  iMsk |= 1 << idN;
	}
      }
      elm->flags |= WLZ_CMESH_ELM_FLAG_OUTSIDE;
      switch(iMsk)
      {
	case 0: /* 0|0000|0 */
	  (void )WlzCMeshDelElm3D(mesh, elm);
	  break;
	/* 1 node is inside the domain. */
	case  1: /*  1|0001|1 */
	  errNum = WlzCMeshBoundConformElm3D3(mesh, obj, elm,
					      nodes, 1, 2, 3, 0, tol);
	  break;
	case  2: /*  2|0010|1 */
	  errNum = WlzCMeshBoundConformElm3D3(mesh, obj, elm,
					      nodes, 2, 3, 0, 1, tol);
	  break;
	case  4: /*  4|0100|1 */
	  errNum = WlzCMeshBoundConformElm3D3(mesh, obj, elm,
					      nodes, 3, 0, 1, 2, tol);
	  break;
	case  8: /*  8|1000|1 */
	  errNum = WlzCMeshBoundConformElm3D3(mesh, obj, elm,
					      nodes, 0, 1, 2, 3, tol);
	  break;
	/* 2 nodes are inside the domain. */
	case  3: /*  3|0011|2 */
	  errNum = WlzCMeshBoundConformElm3D2(mesh, obj, elm,
					      nodes, 3, 2, 0, 1, tol);
	  break;
	case  5: /*  5|0101|2 */
	  errNum = WlzCMeshBoundConformElm3D2(mesh, obj, elm,
					      nodes, 3, 1, 0, 2, tol);
	  break;
	case  6: /*  6|0110|2 */
	  errNum = WlzCMeshBoundConformElm3D2(mesh, obj, elm,
					      nodes, 3, 0, 1, 2, tol);
	  break;
	case  9: /*  9|1001|2 */
	  errNum = WlzCMeshBoundConformElm3D2(mesh, obj, elm,
					      nodes, 2, 1, 3, 0, tol);
	  break;
	case 10: /* 10|1010|2 */
	  errNum = WlzCMeshBoundConformElm3D2(mesh, obj, elm,
					      nodes, 2, 0, 3, 1, tol);
	  break;
	case 12: /* 12|1100|2 */
	  errNum = WlzCMeshBoundConformElm3D2(mesh, obj, elm,
					      nodes, 1, 0, 3, 2, tol);
	  break;
	/* 3 nodes are inside the domain. */
	case  7: /*  7|0111|3 */
	  errNum = WlzCMeshBoundConformElm3D1(mesh, obj, elm,
					      nodes, 3, 0, 1, 2, tol);
	  break;
	case 11: /* 11|1011|3 */
	  errNum = WlzCMeshBoundConformElm3D1(mesh, obj, elm,
					      nodes, 2, 3, 0, 1, tol);
	  break;
	case 13: /* 13|1101|3 */
	  errNum = WlzCMeshBoundConformElm3D1(mesh, obj, elm,
					      nodes, 1, 2, 3, 0, tol);
	  break;
	case 14: /* 14|1110|3 */
	  errNum = WlzCMeshBoundConformElm3D1(mesh, obj, elm,
					      nodes, 0, 1, 2, 3, tol);
	  break;
	/* 4 nodes are inside the domain. */
	case 15: /* 15|1111|4 */
	  elm->flags &= ~(WLZ_CMESH_ELM_FLAG_BOUNDARY);
	  break;
	default:
	  break;
      }
    }
    ++idE;
  }
  /* Pass 1: Delete new elemets marked as boundary but outside the
   * given object's domain. */
  if(errNum == WLZ_ERR_NONE)
  {
    idE = 0;
    idM = mesh->res.elm.maxEnt;
    while((errNum == WLZ_ERR_NONE) && (idE < idM))
    {
      elm = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if((elm->idx >= 0) &&
         (elm->flags & WLZ_CMESH_ELM_FLAG_BOUNDARY) != 0)
      {
	WlzCMeshElmGetNodes3D(elm,
			      nodes + 0, nodes + 1, nodes + 2, nodes + 3);
	/* Set mask depending on whether nodes are inside or outside the
	 * domain. */
	iMsk = 0;
	for(idN = 0; idN < 4; ++idN)
	{
	  nod = nodes[idN];
	  if(WlzInsideDomain(obj,
			     nod->pos.vtZ, nod->pos.vtY, nod->pos.vtX,
			     NULL))
	  {
	    iMsk |= 1 << idN;
	    break;
	  }
	}
	if(iMsk == 0)    /* All nodes of the element are outside the domain. */
	{
	  (void )WlzCMeshDelElm3D(mesh, elm);
	}
      }
      ++idE;
    }
  }
  return(errNum);
}

/*!
* \return	New or existing mesh node.
* \ingroup	WlzMesh
* \brief	Computes the position for a node between the two given
* 		nodes (one inside the given object and the other outside
* 		it) such that the new node is outside the object. The
* 		new node is placed using the tollerance provided, because
* 		of this the new node returned may be one of the given nodes
* 		or it may be an actual new node.
* \param	mesh			Given mesh.
* \param	obj			Given object.
* \param	nod0			First given node.
* \param	nod1			Second given node.
* \param	tol			Acceptable placement error.
* \param	dstErr			Destination error pointer may be NULL.
*/
static WlzCMeshNod2D *WlzCMeshComputeBoundNod2D(WlzCMesh2D *mesh,
					WlzObject *obj,
					WlzCMeshNod2D *nod0,
					WlzCMeshNod2D *nod1,
					double tol,
					WlzErrorNum *dstErr)
{
  double	tolSq;
  WlzIVertex2	dumGrdPos;
  WlzDVertex2	pos;
  WlzDVertex2   pos0,
  		pos1;
  WlzCMeshNod2D *pNod,
  		*nod = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  pos0 = nod0->pos;
  pos1 = nod1->pos;
  tolSq = (tol * tol) + DBL_EPSILON;
  pos = WlzGeomObjLineSegIntersect2D(obj, pos0, pos1, tol, 0, NULL);
  if(WlzGeomDistSq2D(pos, pos0) < tolSq)
  {
    nod = nod0;
  }
  else if(WlzGeomDistSq2D(pos, pos1) < tolSq)
  {
    nod = nod1;
  }
  else
  {
    if(WlzCMeshLocateNod2D(mesh, pos, &dumGrdPos, &pNod, &nod) == 0)
    {
      nod = WlzCMeshNewNod2D(mesh, pos, &errNum); 
    }
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nod);
}

/*!
* \return	New or existing mesh node.
* \ingroup	WlzMesh
* \brief	Computes the position for a node between the two given
* 		nodes (one inside the given object and the other outside
* 		it) such that the new node is outside the object. The
* 		new node is placed using the tollerance provided, because
* 		of this the new node returned may be one of the given nodes
* 		or it may be an actual new node.
* \param	mesh			Given mesh.
* \param	obj			Given object.
* \param	nod0			First given node.
* \param	nod1			Second given node.
* \param	tol			Acceptable placement error.
* \param	dstErr			Destination error pointer may be NULL.
*/
static WlzCMeshNod3D *WlzCMeshComputeBoundNod3D(WlzCMesh3D *mesh,
					WlzObject *obj,
					WlzCMeshNod3D *nod0,
					WlzCMeshNod3D *nod1,
					double tol,
					WlzErrorNum *dstErr)
{
  double	tolSq;
  WlzIVertex3	dumGrdPos;
  WlzDVertex3	pos;
  WlzDVertex3   pos0,
  		pos1;
  WlzCMeshNod3D *pNod,
  		*nod = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  pos0 = nod0->pos;
  pos1 = nod1->pos;
  tolSq = (tol * tol) + DBL_EPSILON;
  pos = WlzGeomObjLineSegIntersect3D(obj, pos0, pos1, tol, 0, NULL);
  if(WlzGeomDistSq3D(pos, pos0) < tolSq)
  {
    nod = nod0;
  }
  else if(WlzGeomDistSq3D(pos, pos1) < tolSq)
  {
    nod = nod1;
  }
  else
  {
    if(WlzCMeshLocateNod3D(mesh, pos, &dumGrdPos, &pNod, &nod) == 0)
    {
      nod = WlzCMeshNewNod3D(mesh, pos, &errNum); 
    }
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nod);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Given an array of three nodes, each of which is at the
* 		vertex of a 2D conforming mesh element, such that the
* 		first node is outside the domain of the given object
* 		and the other tho are inside it. This function replaces
* 		the given element with 2 new elements.
* 		Nodes are added (if they do not already exist) at the
* 		intersection of the elements edges with the given object.
* 		These nodes are then used to create new elements by adding
* 		a single edge.
* 		When truncating the tetrahedral mesh element, the points
* 		of intersection point are choosen to be just outside the
* 		domain of the given object, with the limit on 'just'
* 		controlled by the tollerance parametrer.
* \param	mesh			Given mesh.
* \param	obj			Given object.
* \param	elm			Given element to delete and replace
* 					with a conforming element.
* \param	nodBuf			Array of four nodes.
* \param	nIdx0			Index of node outside object.
* \param	nIdx1			Index of a node on opposite face.
* \param	nIdx2			Index of a node on opposite face.
* \param	tol			Acceptable placement error.
*/
static WlzErrorNum WlzCMeshBoundConformElm2D1(WlzCMesh2D *mesh,
					WlzObject *obj, WlzCMeshElm2D *elm,
                                        WlzCMeshNod2D **nodBuf,
					int nIdx0, int nIdx1,
					int nIdx2, double tol)
{
  int		idE;
  double	area;
  WlzCMeshNod2D	*nod[5];
  WlzCMeshNod2D	*eNod[3];
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	elmNodTbl[2][3] =
  {
    {1, 2, 4},
    {1, 4, 3}
  };

  /* Nodes 0 - 3 are the nodes of the given element. */
  nod[0] = *(nodBuf + nIdx0);
  nod[1] = *(nodBuf + nIdx1);
  nod[2] = *(nodBuf + nIdx2);
  nod[3] = nod[4] = NULL;
  /* Create new (or find existing) boundary nodes: Nodes 3 - 4. */
  for(idE = 1; idE <= 2; ++idE)
  {
    nod[2 + idE] = WlzCMeshComputeBoundNod2D(mesh, obj, nod[0], nod[idE],
				             tol, &errNum);
    if(errNum != WLZ_ERR_NONE)
    {
      break;
    }
  }
  /* Create new elements and then delete the given one. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE < 2; ++idE)
    {
      eNod[0] = nod[elmNodTbl[idE][0]];
      eNod[1] = nod[elmNodTbl[idE][1]];
      eNod[2] = nod[elmNodTbl[idE][2]];
      area = WlzGeomTriangleSnArea2(eNod[0]->pos, eNod[1]->pos, eNod[2]->pos);
      if(area * area > WLZ_MESH_TOLERANCE_SQ)
      {
	if(area < 0)
	{
	  (void )WlzCMeshNewElm2D(mesh, eNod[0], eNod[2], eNod[1],
				  &errNum);
	}
	else
	{
	  (void )WlzCMeshNewElm2D(mesh, eNod[0], eNod[1], eNod[2],
				  &errNum);
	}
	if(errNum != WLZ_ERR_NONE)
	{
	  break;
	}
	else
	{
	  elm->flags |= WLZ_CMESH_ELM_FLAG_BOUNDARY;
        }
      }
    }
    if(errNum == WLZ_ERR_NONE)
    {
      (void )WlzCMeshDelElm2D(mesh, elm);
    }
  }
  /* Delete any unused nodes which may result from zero volume elements. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE <= 4; ++idE)
    {
      if(nod[idE]->edu == NULL)
      {
        (void )WlzCMeshDelNod2D(mesh, nod[idE]);
      }
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Given an array of three nodes, each of which is at the
* 		vertex of a 2D conforming mesh element, such that the
* 		first two nodes are outside the domain of the given object
* 		and the last node is inside it. This function replaces
* 		the given element with a new element in which the first
* 		two nodes are replaced with (possibly) new nodes,
* 		the positions of which are given by the intersection of
* 		the elements edges with the given object's boundary.
* 		The intersection point is choosen to be just outside the
* 		domain of the given object, with the limit on 'just'
* 		controlled by the tollerance parametrer.
* \param	mesh			Given mesh.
* \param	obj			Given object.
* \param	elm			Given element to delete and replace
* 					with a conforming element.
* \param	nodBuf			Array of four nodes.
* \param	nIdx0			Index of first node outside object.
* \param	nIdx1			Index of second node outside object.
* \param	nIdx2			Index of third node outside object.
* \param	tol			Acceptable placement error.
*/
static WlzErrorNum WlzCMeshBoundConformElm2D2(WlzCMesh2D *mesh,
					WlzObject *obj, WlzCMeshElm2D *elm,
                                        WlzCMeshNod2D **nodBuf,
					int nIdx0, int nIdx1,
					int nIdx2, double tol)
{
  int		idE;
  double	area;
  WlzCMeshNod2D	*nod[5];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  nod[0] = *(nodBuf + nIdx0);
  nod[1] = *(nodBuf + nIdx1);
  nod[2] = *(nodBuf + nIdx2);
  nod[3] = nod[4] = NULL;
  /* Create (or find existing) new boundary nodes. */
  for(idE = 0; idE < 2; ++idE)
  {
    nod[idE + 3] = WlzCMeshComputeBoundNod2D(mesh, obj, nod[2], nod[idE],
				      tol, &errNum);
    if(errNum != WLZ_ERR_NONE)
    {
      break;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    area = WlzGeomTriangleSnArea2(nod[2]->pos, nod[3]->pos, nod[4]->pos);
    if(area * area > WLZ_MESH_TOLERANCE_SQ)
    {
      /* Create new element. */
      if(area < 0)
      {
	(void )WlzCMeshNewElm2D(mesh, nod[2], nod[4], nod[3], &errNum);
      }
      else
      {
	(void )WlzCMeshNewElm2D(mesh, nod[2], nod[3], nod[4], &errNum);
      }
      if(errNum == WLZ_ERR_NONE)
      {
	elm->flags |= WLZ_CMESH_ELM_FLAG_BOUNDARY;
      }
    }
    else
    {
      /* Delete the unused new nodes. */
      for(idE = 0; idE < 5; ++idE)
      {
	if((nod[idE] != NULL) && (nod[idE]->edu == NULL))
	{
	  (void )WlzCMeshDelNod2D(mesh, nod[idE]);
	}
      }
    }
    (void )WlzCMeshDelElm2D(mesh, elm);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Given an array of four nodes, each of which is at the
* 		vertex of a 3D conforming mesh element, such that the
* 		first node is outside the domain of the given object
* 		and the other three are inside it. This function replaces
* 		the given element with 14 new elements.
* 		Nodes are added (if they do not already exist) at the
* 		intersection of the elements edges with the given object,
* 		at the centre of each quadrilateral face of the truncated
* 		tetrahedron and at the centre of the truncated tetrahedron
* 		itself. These nodes are then used to create new elements
* 		in a body centred tesselation.
* 		When truncating the tetrahedral mesh element, the points
* 		of intersection point are choosen to be just outside the
* 		domain of the given object, with the limit on 'just'
* 		controlled by the tollerance parametrer.
* \param	mesh			Given mesh.
* \param	obj			Given object.
* \param	elm			Given element to delete and replace
* 					with a conforming element.
* \param	nodBuf			Array of four nodes.
* \param	nIdx0			Index of node outside object.
* \param	nIdx1			Index of a node on opposite face.
* \param	nIdx2			Index of a node on opposite face.
* \param	nIdx3			Index of a node on opposite face.
* \param	tol			Acceptable placement error.
*/
static WlzErrorNum WlzCMeshBoundConformElm3D1(WlzCMesh3D *mesh,
					WlzObject *obj, WlzCMeshElm3D *elm,
                                        WlzCMeshNod3D **nodBuf,
					int nIdx0, int nIdx1,
					int nIdx2, int nIdx3,
					double tol)
{
  int		idE;
  double	vol;
  WlzIVertex3	dumGrdPos;
  WlzDVertex3	pos[11];
  WlzCMeshNod3D	*nod[11];
  WlzCMeshNod3D	*eNod[4];
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	quadFceNodTbl[3][4] =
  {
    {1, 2, 5, 4},
    {2, 3, 6, 5},
    {3, 1, 4, 6}
  };
  const int	elmNodTbl[14][4] =
  {
    {1, 2, 7, 10},
    {2, 5, 7, 10},
    {5, 4, 7, 10},
    {4, 1, 7, 10},
    {2, 3, 8, 10},
    {3, 6, 8, 10},
    {6, 5, 8, 10},
    {5, 2, 8, 10},
    {3, 1, 9, 10},
    {1, 4, 9, 10},
    {4, 6, 9, 10},
    {6, 3, 9, 10},
    {1, 2, 3, 10},
    {4, 5, 6, 10}
  };

  /* Nodes 0 - 3 are the nodes of the given element. */
  nod[0] = *(nodBuf + nIdx0);
  nod[1] = *(nodBuf + nIdx1);
  nod[2] = *(nodBuf + nIdx2);
  nod[3] = *(nodBuf + nIdx3);
  nod[4] = nod[5] = nod[6] = nod[7] = nod[8] = nod[9] = nod[10] = NULL;
  /* Create new (or find existing) boundary nodes: Nodes 4 - 6. */
  for(idE = 1; idE <= 3; ++idE)
  {
    nod[3 + idE] = WlzCMeshComputeBoundNod3D(mesh, obj, nod[0], nod[idE],
				             tol, &errNum);
    if(errNum != WLZ_ERR_NONE)
    {
      break;
    }
  }
  /* Create (or find existing) nodes at centres of quadrilateral faces:
   * Nodes 7 - 9. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE < 3; ++idE)
    {
      pos[0] = nod[quadFceNodTbl[idE][0]]->pos;
      pos[1] = nod[quadFceNodTbl[idE][1]]->pos;
      pos[2] = nod[quadFceNodTbl[idE][2]]->pos;
      pos[3] = nod[quadFceNodTbl[idE][3]]->pos;
      pos[idE + 7].vtX = (pos[0].vtX + pos[1].vtX +
                          pos[2].vtX + pos[3].vtX) / 4.0;
      pos[idE + 7].vtY = (pos[0].vtY + pos[1].vtY +
                          pos[2].vtY + pos[3].vtY) / 4.0;
      pos[idE + 7].vtZ = (pos[0].vtZ + pos[1].vtZ +
                          pos[2].vtZ + pos[3].vtZ) / 4.0;
      if(WlzCMeshLocateNod3D(mesh, pos[idE + 7],
                             &dumGrdPos, eNod + 1, eNod + 0) == 0)
      {
        eNod[0] = WlzCMeshNewNod3D(mesh, pos[idE + 7], &errNum); 
	if(errNum != WLZ_ERR_NONE)
	{
	  break;
	}
      }
      nod[idE + 7] = eNod[0];
    }
  }
  /* Create node at centre of truncated tetrahedron: Node 10. */
  if(errNum == WLZ_ERR_NONE)
  {
    pos[10].vtX = (pos[7].vtX + pos[8].vtX + pos[9].vtX) / 3.0;
    pos[10].vtY = (pos[7].vtY + pos[8].vtY + pos[9].vtY) / 3.0;
    pos[10].vtZ = (pos[7].vtZ + pos[8].vtZ + pos[9].vtZ) / 3.0;
    nod[10] = WlzCMeshNewNod3D(mesh, pos[10], &errNum);
  }
  /* Create new elements and then delete the given one. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE < 14; ++idE)
    {
      eNod[0] = nod[elmNodTbl[idE][0]];
      eNod[1] = nod[elmNodTbl[idE][1]];
      eNod[2] = nod[elmNodTbl[idE][2]];
      eNod[3] = nod[elmNodTbl[idE][3]];
      vol = WlzGeomTetraSnVolume6(eNod[0]->pos, eNod[1]->pos,
				  eNod[2]->pos, eNod[3]->pos);
      if(vol * vol > WLZ_MESH_TOLERANCE_SQ)
      {
	if(vol < 0)
	{
	  (void )WlzCMeshNewElm3D(mesh, eNod[0], eNod[1], eNod[3], eNod[2],
				  &errNum);
	}
	else
	{
	  (void )WlzCMeshNewElm3D(mesh, eNod[0], eNod[1], eNod[2], eNod[3],
				  &errNum);
	}
	if(errNum != WLZ_ERR_NONE)
	{
	  break;
	}
	else
	{
	  elm->flags |= WLZ_CMESH_ELM_FLAG_BOUNDARY;
	}
      }
    }
    if(errNum == WLZ_ERR_NONE)
    {
      (void )WlzCMeshDelElm3D(mesh, elm);
    }
  }
  /* Delete any unused nodes which may result from zero volume elements. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE <= 10; ++idE)
    {
      if(nod[idE]->edu == NULL)
      {
        (void )WlzCMeshDelNod3D(mesh, nod[idE]);
      }
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Given an array of four nodes, each of which is at the
* 		vertex of a 3D conforming mesh element, such that the
* 		first two nodes are outside the domain of the given
* 		object and remaining two are inside it. This function
* 		replaces the given element with new elements in which
* 		the first two nodes are replaced with (possibly) new
* 		nodes, the positions of which are given by the
* 		intersection of the elements edges with the object's
* 		boundary.
* 		The intersection points are choosen to be just outside
* 		the domain of the given object, with the limit on 'just'
* 		controlled by the tollerance parametrer.
* \param	mesh			Given mesh.
* \param	obj			Given object.
* \param	elm			Given element to delete and replace
* 					with a conforming element.
* \param	nodBuf			Array of four nodes.
* \param	nIdx0			Index of first node outside object.
* \param	nIdx1			Index of second node outside object.
* \param	nIdx2			Index of first node inside object.
* \param	nIdx3			Index of second node inside object.
* \param	tol			Acceptable placement error.
*/
static WlzErrorNum WlzCMeshBoundConformElm3D2(WlzCMesh3D *mesh,
					WlzObject *obj, WlzCMeshElm3D *elm,
                                        WlzCMeshNod3D **nodBuf,
					int nIdx0, int nIdx1,
					int nIdx2, int nIdx3,
					double tol)
{
  int		idE;
  double	vol;
  WlzIVertex3	dumGrdPos;
  WlzDVertex3	pos[12];
  WlzCMeshNod3D	*nod[12];
  WlzCMeshNod3D	*eNod[4];
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	edgNodTbl[4][2] =
  {
    {0, 2},
    {0, 3},
    {1, 2},
    {1, 3}
  };
  const int quadFceNodTbl[3][4] =
  {
    {2, 3, 5, 7},
    {4, 5, 7, 6},
    {2, 3, 7, 6}
  };
  const int	elmNodTbl[14][4] =
  {
    {2, 3,  8, 11},
    {3, 5,  8, 11},
    {5, 4,  8, 11},
    {4, 2,  8, 11},
    {4, 5,  9, 11},
    {5, 7,  9, 11},
    {7, 6,  9, 11},
    {6, 4,  9, 11},
    {2, 3, 10, 11},
    {3, 7, 10, 11},
    {7, 6, 10, 11},
    {6, 2, 10, 11},
    {2, 4,  6, 11},
    {3, 5,  7, 11}
  };

  /* Nodes 0 - 3 are the nodes of the given element. */
  nod[0] = *(nodBuf + nIdx0);
  nod[1] = *(nodBuf + nIdx1);
  nod[2] = *(nodBuf + nIdx2);
  nod[3] = *(nodBuf + nIdx3);
  nod[4] = nod[5] = nod[6] = nod[7] = nod[8] = nod[9] =
           nod[10] = nod[11] = NULL;
  /* Create new (or find existing) boundary nodes: Nodes 4 - 7. */
  for(idE = 0; idE <= 3; ++idE)
  {
    nod[idE + 4] = WlzCMeshComputeBoundNod3D(mesh, obj,
				      nod[edgNodTbl[idE][0]],
				      nod[edgNodTbl[idE][1]],
				      tol, &errNum);
    if(errNum != WLZ_ERR_NONE)
    {
      break;
    }
  }
  /* Create (or find existing) nodes at centres of quadrilateral faces:
   * Nodes 8 - 10.*/
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE < 3; ++idE)
    {
      pos[0] = nod[quadFceNodTbl[idE][0]]->pos;
      pos[1] = nod[quadFceNodTbl[idE][1]]->pos;
      pos[2] = nod[quadFceNodTbl[idE][2]]->pos;
      pos[3] = nod[quadFceNodTbl[idE][3]]->pos;
      pos[idE + 8].vtX = (pos[0].vtX + pos[1].vtX +
                          pos[2].vtX + pos[3].vtX) / 4.0;
      pos[idE + 8].vtY = (pos[0].vtY + pos[1].vtY +
                          pos[2].vtY + pos[3].vtY) / 4.0;
      pos[idE + 8].vtZ = (pos[0].vtZ + pos[1].vtZ +
                          pos[2].vtZ + pos[3].vtZ) / 4.0;
      if(WlzCMeshLocateNod3D(mesh, pos[idE + 8],
                             &dumGrdPos, eNod + 1, eNod + 0) == 0)
      {
        eNod[0] = WlzCMeshNewNod3D(mesh, pos[idE + 8], &errNum); 
	if(errNum != WLZ_ERR_NONE)
	{
	  break;
	}
      }
      nod[idE + 8] = eNod[0];
    }
  }
  /* Create node at centre of truncated tetrahedron: Node 11. */
  if(errNum == WLZ_ERR_NONE)
  {
    pos[11].vtX = (pos[8].vtX + pos[9].vtX + pos[10].vtX) / 3.0;
    pos[11].vtY = (pos[8].vtY + pos[9].vtY + pos[10].vtY) / 3.0;
    pos[11].vtZ = (pos[8].vtZ + pos[9].vtZ + pos[10].vtZ) / 3.0;
    nod[11] = WlzCMeshNewNod3D(mesh, pos[11], &errNum);
  }
  /* Create new elements and then delete the given one. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE < 14; ++idE)
    {
      eNod[0] = nod[elmNodTbl[idE][0]];
      eNod[1] = nod[elmNodTbl[idE][1]];
      eNod[2] = nod[elmNodTbl[idE][2]];
      eNod[3] = nod[elmNodTbl[idE][3]];
      vol = WlzGeomTetraSnVolume6(eNod[0]->pos, eNod[1]->pos,
				  eNod[2]->pos, eNod[3]->pos);
      if(vol * vol > WLZ_MESH_TOLERANCE_SQ)
      {
	if(vol < 0)
	{
	  (void )WlzCMeshNewElm3D(mesh, eNod[0], eNod[1], eNod[3], eNod[2],
				  &errNum);
	}
	else
	{
	  (void )WlzCMeshNewElm3D(mesh, eNod[0], eNod[1], eNod[2], eNod[3],
				  &errNum);
	}
	if(errNum != WLZ_ERR_NONE)
	{
	  break;
	}
	else
	{
	  elm->flags |= WLZ_CMESH_ELM_FLAG_BOUNDARY;
	}
      }
    }
    if(errNum == WLZ_ERR_NONE)
    {
      (void )WlzCMeshDelElm3D(mesh, elm);
    }
  }
  /* Delete any unused nodes which may result from zero volume elements. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE <= 11; ++idE)
    {
      if(nod[idE]->edu == NULL)
      {
        (void )WlzCMeshDelNod3D(mesh, nod[idE]);
      }
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Given an array of four nodes, each of which is at the
* 		vertex of a 3D conforming mesh element, such that the
* 		first three nodes are outside the domain of the given object
* 		and the last node is inside it. This function replaces
* 		the given element with a new element in which the first
* 		three nodes are replaced with (possibly) new nodes,
* 		the positions of which are given by the intersection of
* 		the elements edges with the given object's boundary.
* 		The intersection point is choosen to be just outside the
* 		domain of the given object, with the limit on 'just'
* 		controlled by the tollerance parametrer.
* \param	mesh			Given mesh.
* \param	obj			Given object.
* \param	elm			Given element to delete and replace
* 					with a conforming element.
* \param	nodBuf			Array of four nodes.
* \param	nIdx0			Index of first node outside object.
* \param	nIdx1			Index of second node outside object.
* \param	nIdx2			Index of third node outside object.
* \param	nIdx3			Index of the node inside the object.
* \param	tol			Acceptable placement error.
*/
static WlzErrorNum WlzCMeshBoundConformElm3D3(WlzCMesh3D *mesh,
					WlzObject *obj, WlzCMeshElm3D *elm,
                                        WlzCMeshNod3D **nodBuf,
					int nIdx0, int nIdx1,
					int nIdx2, int nIdx3,
					double tol)
{
  int		idE;
  double	vol;
  WlzCMeshNod3D	*nod[8];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  nod[0] = *(nodBuf + nIdx0);
  nod[1] = *(nodBuf + nIdx1);
  nod[2] = *(nodBuf + nIdx2);
  nod[3] = *(nodBuf + nIdx3);
  nod[4] = nod[5] = nod[6] = nod[7] = NULL;
  /* Create (or find existing) new boundary nodes. */
  for(idE = 0; idE < 3; ++idE)
  {
    nod[idE + 4] = WlzCMeshComputeBoundNod3D(mesh, obj, nod[3], nod[idE],
				      tol, &errNum);
    if(errNum != WLZ_ERR_NONE)
    {
      break;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    vol = WlzGeomTetraSnVolume6(nod[3]->pos, nod[4]->pos,
				nod[5]->pos, nod[6]->pos);
    if(vol * vol > WLZ_MESH_TOLERANCE_SQ)
    {
      /* Create new element. */
      if(vol < 0)
      {
	(void )WlzCMeshNewElm3D(mesh, nod[3], nod[4], nod[6], nod[5],
				&errNum);
      }
      else
      {
	(void )WlzCMeshNewElm3D(mesh, nod[3], nod[4], nod[5], nod[6],
				&errNum);
      }
      if(errNum == WLZ_ERR_NONE)
      {
	elm->flags |= WLZ_CMESH_ELM_FLAG_BOUNDARY;
      }
    }
    else
    {
      /* Delete the unused new nodes. */
      for(idE = 0; idE < 8; ++idE)
      {
	if((nod[idE] != NULL) && (nod[idE]->edu == NULL))
	{
	  (void )WlzCMeshDelNod3D(mesh, nod[idE]);
	}
      }
    }
    (void )WlzCMeshDelElm3D(mesh, elm);
  }
  return(errNum);
}

/*!
* \return	Square of the minimum edge length for the element,
*		this will be negative for invalid elements.
* \ingroup	WlzMesh
* \brief	Computes the square of the minimum edge length for
*		the element.
* \param	elm			Given element.
*/
double 		WlzCMeshElmMinEdgLnSq2D(WlzCMeshElm2D *elm)
{
  double	lenSq,
  		minLenSq = -1.0;
  WlzDVertex2	p0;
  WlzCMeshNod2D *nodBuf[3];

  if(elm && (elm->idx >= 0))
  {
    /* Collect the nodes of the element. */
    nodBuf[0] = elm->edu[0].nod;
    nodBuf[1] = elm->edu[1].nod;
    nodBuf[2] = elm->edu[2].nod;
    /* Compute and compare edge lengths. */
    WLZ_VTX_2_SUB(p0, nodBuf[0]->pos, nodBuf[1]->pos);
    minLenSq = WLZ_VTX_2_SQRLEN(p0);
    WLZ_VTX_2_SUB(p0, nodBuf[0]->pos, nodBuf[2]->pos);
    lenSq = WLZ_VTX_2_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    WLZ_VTX_2_SUB(p0, nodBuf[1]->pos, nodBuf[2]->pos);
    lenSq = WLZ_VTX_2_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
  }
  return(minLenSq);
}

/*!
* \return	Square of the minimum edge length for the element,
*		this will be negative for invalid elements.
* \ingroup	WlzMesh
* \brief	Computes the square of the minimum edge length for
*		the element.
* \param	elm			Given element.
*/
double 		WlzCMeshElmMinEdgLnSq3D(WlzCMeshElm3D *elm)
{
  double	lenSq,
  		minLenSq = -1.0;
  WlzDVertex3	p0;
  WlzCMeshNod3D *nodBuf[4];

  if(elm && (elm->idx >= 0))
  {
    /* Collect the nodes of the element. */
    WlzCMeshElmGetNodes3D(elm, nodBuf + 0, nodBuf + 1, nodBuf + 2, nodBuf + 3);
    /* Compute and compare edge lengths. */
    WLZ_VTX_3_SUB(p0, nodBuf[0]->pos, nodBuf[1]->pos);
    minLenSq = WLZ_VTX_3_SQRLEN(p0);
    WLZ_VTX_3_SUB(p0, nodBuf[0]->pos, nodBuf[2]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    WLZ_VTX_3_SUB(p0, nodBuf[0]->pos, nodBuf[3]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    WLZ_VTX_3_SUB(p0, nodBuf[1]->pos, nodBuf[2]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    WLZ_VTX_3_SUB(p0, nodBuf[1]->pos, nodBuf[3]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    WLZ_VTX_3_SUB(p0, nodBuf[2]->pos, nodBuf[3]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
  }
  return(minLenSq);
}

/*!
* \return	Wlz error code.
* \ingroup	WlzMesh
* \brief	Allocates a new bucket grid and then reassigns the nodes
*		to the buckets.
* \param	mesh			The mesh.
* \param	newNumNod		New expected number of nodes.
*/
WlzErrorNum 	WlzCMeshReassignBuckets2D(WlzCMesh2D *mesh, int newNumNod)
{
  int		idN;
  WlzIVertex2	bSz;
  WlzCMeshNod2D	*nod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const double	nodPerBucket = 2.0; /* TODO This is an efficiency tuning
  				       parameter which is to be determined. */

  if(newNumNod <= 0)
  {
    newNumNod = (mesh->res.nod.numEnt < 1024)?
                1024: mesh->res.nod.numEnt;
  }
  /* This assumes that the mesh nodes will be evenly distributed over
   * the LBT domain (which they're not). */
  bSz.vtX = mesh->bBox.xMax - mesh->bBox.xMin + 1;
  bSz.vtY = mesh->bBox.yMax - mesh->bBox.yMin + 1;
  mesh->bGrid.bSz.vtX = WlzCMeshCompGridBSz2D(newNumNod, nodPerBucket,
                                              bSz.vtX, bSz.vtY);
  mesh->bGrid.bSz.vtY = WlzCMeshCompGridBSz2D(newNumNod, nodPerBucket,
                                              bSz.vtY, bSz.vtX);
  mesh->bGrid.nB.vtX = (int )ceil(bSz.vtX / mesh->bGrid.bSz.vtX) + 1;
  mesh->bGrid.nB.vtY = (int )ceil(bSz.vtY / mesh->bGrid.bSz.vtY) + 1;
  /* Reallocate the grid buckets. */
  Alc2Free((void **)(mesh->bGrid.buckets));
  /* Allowing one more bucket in each dimension removes the need for lots of
   * boundary checks and so speeds node location significantly. */
  if(AlcPtr2Calloc((void ****)&(mesh->bGrid.buckets),
		    mesh->bGrid.nB.vtY + 1,
		    mesh->bGrid.nB.vtX + 1) != ALC_ER_NONE)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  /* Add all the nodes to the grid buckets. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	nod->next = NULL;
	WlzCMeshAddNodToGrid2D(mesh, nod);
      }
    }
  }
  return(errNum);
}

/*!
* \return	Wlz error code.
* \ingroup	WlzMesh
* \brief	Allocates a new bucket grid and then reassigns the nodes
*		to the buckets.
* \param	mesh			The mesh.
* \param	newNumNod		New expected number of nodes.
*					If zero the current number of nodes
*					or a small number (1024) will be used
*					(which ever is the greater).
*/
WlzErrorNum 	WlzCMeshReassignBuckets3D(WlzCMesh3D *mesh, int newNumNod)
{
  int		idN;
  WlzIVertex3	bSz;
  WlzCMeshNod3D	*nod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const double	nodPerBucket = 2.0; /* This is an efficiency tuning
  				       parameter which is to be determined. */

  if(newNumNod <= 0)
  {
    newNumNod = (mesh->res.nod.numEnt < 1024)?
                1024: mesh->res.nod.numEnt;
  }
  /* This assumes that the mesh nodes will be evenly distributed over
   * the LBT domain (which they're not). */
  bSz.vtX = mesh->bBox.xMax - mesh->bBox.xMin + 1;
  bSz.vtY = mesh->bBox.yMax - mesh->bBox.yMin + 1;
  bSz.vtZ = mesh->bBox.zMax - mesh->bBox.zMin + 1;
  mesh->bGrid.bSz.vtX = WlzCMeshCompGridBSz3D(newNumNod, nodPerBucket,
  					      bSz.vtX, bSz.vtY, bSz.vtZ);
  mesh->bGrid.bSz.vtY = WlzCMeshCompGridBSz3D(newNumNod, nodPerBucket,
                                              bSz.vtY, bSz.vtZ, bSz.vtX);
  mesh->bGrid.bSz.vtZ = WlzCMeshCompGridBSz3D(newNumNod, nodPerBucket,
                                              bSz.vtZ, bSz.vtX, bSz.vtY);
  mesh->bGrid.nB.vtX = (int )ceil(bSz.vtX / mesh->bGrid.bSz.vtX) + 1;
  mesh->bGrid.nB.vtY = (int )ceil(bSz.vtY / mesh->bGrid.bSz.vtY) + 1;
  mesh->bGrid.nB.vtZ = (int )ceil(bSz.vtZ / mesh->bGrid.bSz.vtZ) + 1;
  /* Reallocate the grid buckets. */
  Alc3Free((void ***)(mesh->bGrid.buckets));
  /* Allowing one more bucket in each dimension removes the need for lots of
   * boundary checks and so speeds node location significantly. */
  if(AlcPtr3Calloc((void *****)&(mesh->bGrid.buckets),
		    mesh->bGrid.nB.vtZ + 1,
		    mesh->bGrid.nB.vtY + 1,
		    mesh->bGrid.nB.vtX + 1) != ALC_ER_NONE)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  /* Add all the nodes to the grid buckets. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod3D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	nod->next = NULL;
	WlzCMeshAddNodToGrid3D(mesh, nod);
      }
    }
  }
  return(errNum);
}

/*!
* \return	Bucket size.
*		dimension.
* \ingroup	WlzMesh
* \brief	Computes the bucket size for the 2D mesh node location grid.
*		The function assumes that nodes are evenly distributed over
*		the bounding box of the mesh and uses simple scaling to
*		compute  the bucket size. The function should be called for
*		the x, and y components.
* \param	tnn			Total number of nodes in the mesh.
* \param	npb			Number of nodes per bucket.
* \param	sz0			Component of mesh size same as
*					return (eg x if x required, y if
*					y required).
* \param	sz1			Other component of mesh size.
*/
static double	WlzCMeshCompGridBSz2D(int tnn, double npb,
				    double sz0, double sz1)
{
  double	bs;
  const double	delta = WLZ_MESH_TOLERANCE; /* A small +ve number which is
  					       smaller than any expected
					       mesh node separation. */
  bs = sqrt(fabs((tnn * sz0) / ( npb * sz1)) + delta);
  return(bs);
}

/*!
* \return	Bucket size.
*		dimension.
* \ingroup	WlzMesh
* \brief	Computes the bucket size for the 3D mesh node location grid.
*		The function assumes that nodes are evenly distributed over
*		the bounding box of the mesh and uses simple scaling to
*		compute  the bucket size. The function should be called for
*		the x, y and z components.
* \param	tnn			Total number of nodes in the mesh.
* \param	npb			Number of nodes per bucket.
* \param	sz0			Component of mesh size same as
*					return (eg x if x required, y if
*					y required...).
* \param	sz1			Other component of mesh size.
* \param	sz2			Other component of mesh size.
*/
static double	WlzCMeshCompGridBSz3D(int tnn, double npb,
				    double sz0, double sz1, double sz2)
{
  double	bs;
  const double	delta = WLZ_MESH_TOLERANCE; /* A small +ve number which is
  					       smaller than any expected
					       mesh node separation. */
  bs = pow((fabs((tnn * sz0 * sz0)/(npb * sz1 * sz2)) + delta), 1.0 / 3.0);
  return(bs);
}

/*!
* \return	Mesh grid bucket indices.
* \ingroup	WlzMesh
* \brief	Computes the mesh grid bucket indices for a given
*		vertex position.
* \param	mesh			The mesh.
* \param	vtx			Given vertex.
*/
static WlzIVertex2 WlzCMeshBucketIdxVtx2D(WlzCMesh2D *mesh, WlzDVertex2 vtx)
{
  WlzIVertex2	idx;

  idx.vtX = abs((int )((vtx.vtX - mesh->bBox.xMin) / mesh->bGrid.bSz.vtX));
  idx.vtY = abs((int )((vtx.vtY - mesh->bBox.yMin) / mesh->bGrid.bSz.vtY));
  return(idx);
}

/*!
* \return	Mesh grid bucket indices.
* \ingroup	WlzMesh
* \brief	Computes the mesh grid bucket indices for a given
*		vertex position.
* \param	mesh			The mesh.
* \param	vtx			Given vertex.
*/
static WlzIVertex3 WlzCMeshBucketIdxVtx3D(WlzCMesh3D *mesh, WlzDVertex3 vtx)
{
  WlzIVertex3	idx;

  idx.vtX = abs((int )((vtx.vtX - mesh->bBox.xMin) / mesh->bGrid.bSz.vtX));
  idx.vtY = abs((int )((vtx.vtY - mesh->bBox.yMin) / mesh->bGrid.bSz.vtY));
  idx.vtZ = abs((int )((vtx.vtZ - mesh->bBox.zMin) / mesh->bGrid.bSz.vtZ));
  return(idx);
}

/*!
* \return	Non zero if there is an existing node at the given position.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_MESH_TOLERANCE distance) of
*		the given vertex. This function also gives access to the
*		grid bucket containing the node.
* \param	mesh			The mesh.
* \param	pos			Given node position.
* \param	dstGPos			Destination pointer for the grid
*					position. Must not be NULL.
* \param	dstPrev			Destination pointer for the previous
*					node in the bucket's linked list,
*					which will be NULL if either the
*					bucket is empty or the matched node
*					is the first in the bucket. Must not
*					be NULL.
* \param	dstNod			Destination pointer for the matched
*					node which will be NULL if there
*					is no node at the given position.
*					Must not be NULL.
*/
int	 	WlzCMeshLocateNod2D(WlzCMesh2D *mesh, 
				    WlzDVertex2 pos,
				    WlzIVertex2 *dstGPos,
				    WlzCMeshNod2D **dstPrev,
				    WlzCMeshNod2D **dstNod)
{
  int		found = 0;
  double	delta;
  WlzDVertex2	relPos;
  WlzIVertex2	idx;
  WlzIBox2	box;
  WlzCMeshNod2D	*nod;
  const double	eps = 0.01;

  /* Search within a box of buckets because the vertex may be on the
   * edge of a bucket. */
  relPos.vtX = pos.vtX - mesh->bBox.xMin;
  relPos.vtY = pos.vtY - mesh->bBox.yMin;
  delta = eps * mesh->bGrid.bSz.vtX;
  box.xMin = abs((int )((relPos.vtX - delta) / mesh->bGrid.bSz.vtX));
  box.xMax = abs((int )((relPos.vtX + delta) / mesh->bGrid.bSz.vtX));
  delta = eps * mesh->bGrid.bSz.vtY;
  box.yMin = abs((int )((relPos.vtY - delta) / mesh->bGrid.bSz.vtY));
  box.yMax = abs((int )((relPos.vtY + delta) / mesh->bGrid.bSz.vtY));
  for(idx.vtY = box.yMin; idx.vtY <= box.yMax; ++idx.vtY)
  {
    for(idx.vtX = box.xMin; idx.vtX <= box.xMax; ++idx.vtX)
    {
      nod = *(*(mesh->bGrid.buckets + idx.vtY) + idx.vtX);
      while(nod)
      {
	if(WLZ_VTX_2_EQUAL(nod->pos, pos, WLZ_MESH_TOLERANCE))
	{
	  found = 1;
	  goto FOUND;
	}
	nod = nod->next;
      }
    }
  }
FOUND:
  *dstNod = (found)? nod: NULL;
  return(found);
}

/*!
* \return	Non zero if there is an existing node at the given position.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_MESH_TOLERANCE distance) of
*		the given vertex. This function also gives access to the
*		grid bucket containing the node.
* \param	mesh			The mesh.
* \param	pos			Given node position.
* \param	dstGPos			Destination pointer for the grid
*					position. Must not be NULL.
* \param	dstPrev			Destination pointer for the previous
*					node in the bucket's linked list,
*					which will be NULL if either the
*					bucket is empty or the matched node
*					is the first in the bucket. Must not
*					be NULL.
* \param	dstNod			Destination pointer for the matched
*					node which will be NULL if there
*					is no node at the given position.
*					Must not be NULL.
*/
int	 	WlzCMeshLocateNod3D(WlzCMesh3D *mesh, 
				    WlzDVertex3 pos,
				    WlzIVertex3 *dstGPos,
				    WlzCMeshNod3D **dstPrev,
				    WlzCMeshNod3D **dstNod)
{
  int		found = 0;
  double	delta;
  WlzDVertex3	relPos;
  WlzIVertex3	idx;
  WlzIBox3	box;
  WlzCMeshNod3D	*nod;
  const double	eps = 0.01;

  /* Search within a box of buckets because the vertex may be on the
   * edge of a bucket. */
  relPos.vtX = pos.vtX - mesh->bBox.xMin;
  relPos.vtY = pos.vtY - mesh->bBox.yMin;
  relPos.vtZ = pos.vtZ - mesh->bBox.zMin;
  delta = eps * mesh->bGrid.bSz.vtX;
  box.xMin = abs((int )((relPos.vtX - delta) / mesh->bGrid.bSz.vtX));
  box.xMax = abs((int )((relPos.vtX + delta) / mesh->bGrid.bSz.vtX));
  delta = eps * mesh->bGrid.bSz.vtY;
  box.yMin = abs((int )((relPos.vtY - delta) / mesh->bGrid.bSz.vtY));
  box.yMax = abs((int )((relPos.vtY + delta) / mesh->bGrid.bSz.vtY));
  delta = eps * mesh->bGrid.bSz.vtZ;
  box.zMin = abs((int )((relPos.vtZ - delta) / mesh->bGrid.bSz.vtZ));
  box.zMax = abs((int )((relPos.vtZ + delta) / mesh->bGrid.bSz.vtZ));
  for(idx.vtZ = box.zMin; idx.vtZ <= box.zMax; ++idx.vtZ)
  {
    for(idx.vtY = box.yMin; idx.vtY <= box.yMax; ++idx.vtY)
    {
      for(idx.vtX = box.xMin; idx.vtX <= box.xMax; ++idx.vtX)
      {
	nod = *(*(*(mesh->bGrid.buckets + idx.vtZ) + idx.vtY) + idx.vtX);
	while(nod)
	{
	  if(WLZ_VTX_3_EQUAL(nod->pos, pos, WLZ_MESH_TOLERANCE))
	  {
	    found = 1;
	    goto FOUND;
	  }
	  nod = nod->next;
	}
      }
    }
  }
FOUND:
  *dstNod = (found)? nod: NULL;
  return(found);
}

/*!
* \return	Matched node or NULL if no node is matched.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_MESH_TOLERANCE distance) of
*		the given vertex.
* \param	mesh			The mesh.
* \param	nPos			Given vertex position.
*/
WlzCMeshNod2D 	*WlzCMeshMatchNod2D(WlzCMesh2D *mesh, WlzDVertex2 nPos)
{
  WlzIVertex2	gPos;
  WlzCMeshNod2D	*prev,
  		*mNod;

  (void )WlzCMeshLocateNod2D(mesh, nPos, &gPos, &prev, &mNod);
  return(mNod);
}

/*!
* \return	Matched node or NULL if no node is matched.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_MESH_TOLERANCE distance) of
*		the given vertex.
* \param	mesh			The mesh.
* \param	nPos			Given vertex position.
*/
WlzCMeshNod3D 	*WlzCMeshMatchNod3D(WlzCMesh3D *mesh, WlzDVertex3 nPos)
{
  WlzIVertex3	gPos;
  WlzCMeshNod3D	*prev,
  		*mNod;

  (void )WlzCMeshLocateNod3D(mesh, nPos, &gPos, &prev, &mNod);
  return(mNod);
}

/*!
* \return	Number of matched nodes.
* \ingroup	WlzMesh
* \brief	Locates the nodes matching the given vertex positions.
*		The matched nodes are the mesh nodes which have the
*		same positions (within WLZ_MESH_TOLERANCE distance) of
*		the given vertices.
* \param	mesh			The mesh.
* \param	nNod			Number of node positions to match.
* \param	nPos			Node positions.
* \param	mNod			Array for matched nodes.
*/
int		WlzCMeshMatchNNod2D(WlzCMesh2D *mesh, int nNod,
				    WlzDVertex2 *nPos, WlzCMeshNod2D **mNod)
{
  int		idN,
  		cnt = 0;

  for(idN = 0; idN < nNod; ++idN)
  {
    cnt += (*(mNod + idN) = WlzCMeshMatchNod2D(mesh, *(nPos + idN))) != NULL;
  }
  return(cnt);
}

/*!
* \return	Number of matched nodes.
* \ingroup	WlzMesh
* \brief	Locates the nodes matching the given vertex positions.
*		The matched nodes are the mesh nodes which have the
*		same positions (within WLZ_MESH_TOLERANCE distance) of
*		the given vertices.
* \param	mesh			The mesh.
* \param	nNod			Number of node positions to match.
* \param	nPos			Node positions.
* \param	mNod			Array for matched nodes.
*/
int		WlzCMeshMatchNNod3D(WlzCMesh3D *mesh, int nNod,
				    WlzDVertex3 *nPos, WlzCMeshNod3D **mNod)
{
  int		idN,
  		cnt = 0;

  for(idN = 0; idN < nNod; ++idN)
  {
    cnt += (*(mNod + idN) = WlzCMeshMatchNod3D(mesh, *(nPos + idN))) != NULL;
  }
  return(cnt);
}

/*!
* \return       Element index or negative value if there is no enclosing
*               element.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position.
*
*		If a valid last element index is given then a search is
*		made for the enclosing element both within this element
*		and then, if not found, within it's immediate edge
*		neighbours.
*		If this simple 'walk search' fails to locate the enclosing
*		element a 'jump search' is used in which the grid buckets
*		of the conforming mesh are searched.
* \param        mesh			The mesh.
* \param        lastElmIdx		Last element index to help efficient
* 					location. If negative this is ignored.
* \param        pX			Column coordinate of position.
* \param        pY			Line coordinate of position.
* \param        pZ			Plane coordinate of position (ignored
*                                       for 2D).
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
int             WlzCMeshElmEnclosingPos(WlzCMeshP mesh,
                                        int lastElmIdx,
                                        double pX, double pY, double pZ,
					int *dstCloseNod)
{
  int           elmIdx = -1;

  if(mesh.m2->type == WLZ_CMESH_TRI2D)
  {
    elmIdx = WlzCMeshElmEnclosingPos2D(mesh.m2, lastElmIdx, pX, pY,
                                       dstCloseNod);
  }
  /* WLZ_CMESH_TET3D  not implimented yet. */
  return(elmIdx);
}

/*!
* \return       Element index or negative value if there is no enclosing
*               element.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position.
*
*		If a valid last element index is given then a search is
*		made for the enclosing element both within this element
*		and then, if not found, within it's immediate edge
*		neighbours.
*		If this simple 'walk search' fails to locate the enclosing
*		element a 'jump search' is used in which the grid buckets
*		of the conforming mesh are searched.
* \param        mesh			The mesh.
* \param        lastElmIdx		Last element index to help efficient
* 					location. If negative this is ignored.
* \param        pX			Column coordinate of position.
* \param        pY			Line coordinate of position.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
int             WlzCMeshElmEnclosingPos2D(WlzCMesh2D *mesh,
                                        int lastElmIdx,
                                        double pX, double pY,
					int *dstCloseNod)
{
  WlzDVertex2	gPos;
  int           elmIdx = -1;

  gPos.vtX = pX;
  gPos.vtY = pY;
  if(lastElmIdx >= 0)
  {
    elmIdx = WlzCMeshElmWalkPos2D(mesh, lastElmIdx, gPos);
  }
  if(elmIdx < 0)
  {
    elmIdx = WlzCMeshElmJumpPos2D(mesh, gPos, dstCloseNod);
  }
  return(elmIdx);
}

/*!
* \return       Element index or negative value if there is no enclosing
*               element.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position.
*
*		If a valid last element index is given then a search is
*		made for the enclosing element both within this element
*		and then, if not found, within it's immediate edge
*		neighbours.
*		If this simple 'walk search' fails to locate the enclosing
*		element a 'jump search' is used in which the grid buckets
*		of the conforming mesh are searched.
* \param        mesh			The mesh.
* \param        lastElmIdx		Last element index to help efficient
* 					location. If negative this is ignored.
* \param        pX			Column coordinate of position.
* \param        pY			Line coordinate of position.
* \param        pZ			Plane coordinate of position.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
int             WlzCMeshElmEnclosingPos3D(WlzCMesh3D *mesh,
                                        int lastElmIdx,
                                        double pX, double pY, double pZ,
					int *dstCloseNod)
{
  WlzDVertex3	gPos;
  int           elmIdx = -1;

  gPos.vtX = pX;
  gPos.vtY = pY;
  gPos.vtZ = pZ;
  if(lastElmIdx >= 0)
  {
    elmIdx = WlzCMeshElmWalkPos3D(mesh, lastElmIdx, gPos);
  }
  if(elmIdx < 0)
  {
    elmIdx = WlzCMeshElmJumpPos3D(mesh, gPos, dstCloseNod);
  }
  return(elmIdx);
}

/*!
* \return	Element index or negative value if no enclosing element found.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position by testing the given element and it's
*		immediate edge neighbours.
* \param	mesh			The mesh.
* \param	elmIdx			Index of first element to test.
* \param	gPos			Test position.
*/
static int	WlzCMeshElmWalkPos2D(WlzCMesh2D *mesh, int elmIdx,
				     WlzDVertex2 gPos)
{
  int		idE;
  WlzCMeshElm2D	*elm0,
  		*elm1;

  if((elmIdx >= 0) && (elmIdx < mesh->res.elm.maxEnt))
  {
    elm0 = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, elmIdx);
    if(WlzCMeshElmEnclosesPos2D(elm0, gPos) == 0)
    {
      elmIdx = -1;
      for(idE = 0; idE < 3; ++idE)
      {
	if(elm0->edu[idE].opp)
	{
	  elm1 = elm0->edu[idE].opp->elm;
	  if(WlzCMeshElmEnclosesPos2D(elm1, gPos) != 0)
	  {
	    elmIdx = elm1->idx;
	    break;
	  }
	}
      }
    }
  }
  return(elmIdx);
}

/*!
* \return	Element index or negative value if no enclosing element found.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position by testing the given element and it's
*		immediate face neighbours.
* \param	mesh			The mesh.
* \param	elmIdx			Index of first element to test.
* \param	gPos			Test position.
*/
static int	WlzCMeshElmWalkPos3D(WlzCMesh3D *mesh, int elmIdx,
				     WlzDVertex3 gPos)
{
  int		idF;
  WlzCMeshElm3D	*elm0,
  		*elm1;

  if((elmIdx >= 0) && (elmIdx < mesh->res.elm.maxEnt))
  {
    elm0 = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, elmIdx);
    if(WlzCMeshElmEnclosesPos3D(elm0, gPos) == 0)
    {
      elmIdx = -1;
      for(idF = 0; idF < 4; ++idF)
      {
	if(elm0->face[idF].opp)
	{
	  elm1 = elm0->face[idF].opp->elm;
	  if(WlzCMeshElmEnclosesPos3D(elm1, gPos) != 0)
	  {
	    elmIdx = elm1->idx;
	    break;
	  }
	}
      }
    }
  }
  return(elmIdx);
}

/*!
* \return	Index of the enclosing element or < 0 if no enclosing
*		element is found.
* \ingroup	WlzMesh
* \brief	Searches for the conforming mesh element which encloses
*		the given position by jumping to the corresponding grid
*		bucket and then spiraling out from this grid bucket until
*		the maximum search distance is reached. For each of the
*		grid buckets - all the elements of it's nodes are searched.
*		The search terminates either when the enclosing element
*		is found or when the maximum search distance is reached.
* \param	mesh			The conforming  mesh.
* \param	gPos			Given position.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
static int	WlzCMeshElmJumpPos2D(WlzCMesh2D *mesh, WlzDVertex2 gPos,
				     int *dstCloseNod)
{
  int		finished,
  		elmIdx = -1,
		ring0 = -1,
		ring1 = -1,
		spiralCnt = 0;
  double	d0,
  		d1,
		minDstSq;
  WlzDVertex2	del,
  		bPos,
  		bPos0,
		bPos1;
  WlzIVertex2	idB;
  double	dstSq = 0.0;
  WlzCMeshNod2D	*nod;
  WlzCMeshEdgU2D *edu;
  WlzCMeshNod2D	**bktP;

  if(dstCloseNod)
  {
    *dstCloseNod = -1;
    minDstSq = DBL_MAX;
  }
  /* Compute extra distance to allow for search within circle rather than
   * rectangle: \f$h = \sqrt{d_0^2 + d_1^2} - d_1\f$, where \f$d_0\f$ and
   * \f$d_1\f$ are twice the maximum and minimum grid buckect cell dimensions
   * respectively. */
  d0 = ALG_MAX(mesh->bGrid.bSz.vtX, mesh->bGrid.bSz.vtY) * 0.5;
  d1 = ALG_MIN(mesh->bGrid.bSz.vtX, mesh->bGrid.bSz.vtY) * 0.5;
  /* d0 is the extra distance. */
  d0 = sqrt((d0 * d0) + (d1 * d1)) - d1;
  /* Find the grid bucket which contains the position. */
  idB = WlzCMeshBucketIdxVtx2D(mesh, gPos);
  finished = 0;
  do
  {
    if((idB.vtX >= 0) && (idB.vtY >= 0) &&
       (idB.vtX < mesh->bGrid.nB.vtX) && (idB.vtY < mesh->bGrid.nB.vtY))
    {
      bktP = *(mesh->bGrid.buckets + idB.vtY) + idB.vtX;
      /* For each node in the grid bucket. */
      nod = *bktP;
      while(nod)
      {
	if(dstCloseNod)
	{
	  WLZ_VTX_2_SUB(del, gPos, nod->pos);
	  d0 = WLZ_VTX_2_SQRLEN(del);
	  if(d0 < minDstSq)
	  {
	    *dstCloseNod = nod->idx;
	    minDstSq = d0;
	  }
	}
	edu = nod->edu;
	do
	{
	  if(WlzCMeshElmEnclosesPos2D(edu->elm, gPos))
	  {
	    elmIdx = edu->elm->idx;
	    goto FOUND;
	  }
	  if(edu->opp && WlzCMeshElmEnclosesPos2D(edu->opp->elm, gPos))
	  {
	    elmIdx = edu->opp->elm->idx;
	    goto FOUND;
	  }
	  edu = edu->nnxt;
	}
	while(edu != nod->edu);
	nod = nod->next;
      }
    }
    /* Spiral out from the initial grid bucket. */
    spiralCnt = WlzGeomItrSpiral2I(spiralCnt, &(idB.vtX), &(idB.vtY));
    if(dstCloseNod == NULL)
    {
      /* Compute squared distance from the position to the closest vertex
       * of the grid bucket's cell, then subtract the extra distance to
       * account for search in circle rather than rectangle.  If the
       * resulting squared distance is greater than the maximum square
       * edge length then stop searching. */
      bPos0.vtX = mesh->bBox.xMin + (mesh->bGrid.bSz.vtX * idB.vtX);
      bPos0.vtY = mesh->bBox.yMin + (mesh->bGrid.bSz.vtY * idB.vtY);
      bPos1.vtX = bPos0.vtX + mesh->bGrid.bSz.vtX;
      bPos1.vtY = bPos0.vtY + mesh->bGrid.bSz.vtY;
      dstSq = WlzGeomDistSq2D(gPos, bPos0);
      bPos.vtX = bPos1.vtX;
      bPos.vtY = bPos0.vtY;
      d1 = WlzGeomDistSq2D(gPos, bPos);
      if(d1 < dstSq)
      {
	dstSq = d1;
      }
      bPos.vtX = bPos0.vtX;
      bPos.vtY = bPos1.vtY;
      d1 = WlzGeomDistSq2D(gPos, bPos);
      if(d1 < dstSq)
      {
	dstSq = d1;
      }
      d1 = WlzGeomDistSq2D(gPos, bPos1);
      if(d1 < dstSq)
      {
	dstSq = d1;
      }
      finished = (dstSq  - d0) > mesh->maxSqEdgLen;
    }
    else
    {
      if(*dstCloseNod > 0)
      {
	if(ring0 < 0)
	{
	  ring0 = WlzGeomItrSpiralRing(spiralCnt);
	}
	else
	{
	  ring1 = WlzGeomItrSpiralRing(spiralCnt);
	}
	if((ring1 - ring0) > 1)
	{
	  finished = 1;
	}
      }
    }
  } while(!finished);
FOUND:
  return(elmIdx);
}

/*!
* \return	Index of the enclosing element or < 0 if no enclosing
*		element is found.
* \ingroup	WlzMesh
* \brief	Searches for the conforming mesh element which encloses
*		the given position by jumping to the corresponding grid
*		bucket and then spiraling out from this grid bucket until
*		the maximum search distance is reached. For each of the
*		grid buckets - all the elements of it's nodes are searched.
*		The search terminates either when the enclosing element
*		is found or when the maximum search distance is reached.
* \param	mesh			The conforming  mesh.
* \param	gPos			Given position.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
static int	WlzCMeshElmJumpPos3D(WlzCMesh3D *mesh, WlzDVertex3 gPos,
				     int *dstCloseNod)
{
  int		spiralCnt,
  		elmIdx = -1;
  double	d0,
  		d1,
		minDstSq;
  WlzDVertex3	bPos,
  		del;
  WlzIVertex3	idB,
		idC,
                idS;
  double	dstSq = 0.0;
  WlzCMeshNod3D	*nod;
  WlzCMeshEdgU3D *edu;
  WlzCMeshNod3D	**bktP;

  if(dstCloseNod)
  {
    *dstCloseNod = -1;
    minDstSq = DBL_MAX;
  }
  d0 = ALG_MAX3(mesh->bGrid.bSz.vtX, mesh->bGrid.bSz.vtY,
                mesh->bGrid.bSz.vtZ) * ALG_M_SQRT3;
  /* Find the grid bucket which contains the position. */
  spiralCnt = 1;
  idB = idC = WlzCMeshBucketIdxVtx3D(mesh, gPos);
  do
  {
    if((idB.vtX < 0) ||
       (idB.vtY < 0) ||
       (idB.vtZ < 0) ||
       (idB.vtX >= mesh->bGrid.nB.vtX) ||
       (idB.vtY >= mesh->bGrid.nB.vtY) ||
       (idB.vtZ >= mesh->bGrid.nB.vtZ))
    {
      nod = NULL;
    }
    else
    {
      bktP = *(*(mesh->bGrid.buckets + idB.vtZ) + idB.vtY) + idB.vtX;
      /* For each node in the grid bucket. */
      nod = *bktP;
      while(nod)
      {
	if(dstCloseNod)
	{
	  WLZ_VTX_2_SUB(del, gPos, nod->pos);
	  d0 = WLZ_VTX_2_SQRLEN(del);
	  if(d0 < minDstSq)
	  {
	    *dstCloseNod = nod->idx;
	  }
	}
	edu = nod->edu;
	do
	{
	  if(WlzCMeshElmEnclosesPos3D(edu->face->elm, gPos))
	  {
	    elmIdx = edu->face->elm->idx;
	    goto FOUND;
	  }
	  if(edu->face->opp &&
	     WlzCMeshElmEnclosesPos3D(edu->face->opp->elm, gPos))
	  {
	    elmIdx = edu->face->opp->elm->idx;
	    goto FOUND;
	  }
	  edu = edu->nnxt;
	}
	while(edu != nod->edu);
	nod = nod->next;
      }
    }
    /* Spiral out from the initial grid bucket. */
    spiralCnt = WlzGeomItrSpiral3I(spiralCnt,
                                   &(idS.vtX), &(idS.vtY), &(idS.vtZ));
    WLZ_VTX_3_ADD(idB, idC, idS);
    /* Compute squared distance from the position to the closest vertex
     * of the grid bucket's cell, then subtract the extra distance to
     * account for search in circle rather than rectangle.  If the
     * resulting squared distance is greater than the maximum square
     * edge length then stop searching. */
    bPos.vtX = mesh->bBox.xMin + (mesh->bGrid.bSz.vtX * (idB.vtX + 0));
    bPos.vtY = mesh->bBox.yMin + (mesh->bGrid.bSz.vtY * (idB.vtY + 0));
    bPos.vtZ = mesh->bBox.zMin + (mesh->bGrid.bSz.vtZ * (idB.vtZ + 0));
    dstSq = WlzGeomDistSq3D(gPos, bPos);
    bPos.vtX = mesh->bBox.xMin + (mesh->bGrid.bSz.vtX * (idB.vtX + 1));
    bPos.vtY = mesh->bBox.yMin + (mesh->bGrid.bSz.vtY * (idB.vtY + 0));
    bPos.vtZ = mesh->bBox.zMin + (mesh->bGrid.bSz.vtZ * (idB.vtZ + 0));
    d1 = WlzGeomDistSq3D(gPos, bPos);
    if(d1 < dstSq)
    {
      dstSq = d1;
    }
    bPos.vtX = mesh->bBox.xMin + (mesh->bGrid.bSz.vtX * (idB.vtX + 0));
    bPos.vtY = mesh->bBox.yMin + (mesh->bGrid.bSz.vtY * (idB.vtY + 1));
    bPos.vtZ = mesh->bBox.zMin + (mesh->bGrid.bSz.vtZ * (idB.vtZ + 1));
    d1 = WlzGeomDistSq3D(gPos, bPos);
    if(d1 < dstSq)
    {
      dstSq = d1;
    }
    bPos.vtX = mesh->bBox.xMin + (mesh->bGrid.bSz.vtX * (idB.vtX + 1));
    bPos.vtY = mesh->bBox.yMin + (mesh->bGrid.bSz.vtY * (idB.vtY + 1));
    bPos.vtZ = mesh->bBox.zMin + (mesh->bGrid.bSz.vtZ * (idB.vtZ + 1));
    d1 = WlzGeomDistSq3D(gPos, bPos);
    if(d1 < dstSq)
    {
      dstSq = d1;
    }
  } while(dstSq < (mesh->maxSqEdgLen + d0));
FOUND:
  return(elmIdx);
}

/*!
* \return	Non zero if the given vertex is in the given mesh element.
* \ingroup	WlzMesh
* \brief	Checks whether the vertex at the given position is within
* 		the given mesh element.
* \param	elm			Given mesh element.
* \param	gPos			Given vertex position.
*/
int		WlzCMeshElmEnclosesPos2D(WlzCMeshElm2D *elm, WlzDVertex2 gPos)
{
  int		inside = 0;

  if(elm)
  {
    inside = WlzGeomVxInTriangle2D(elm->edu[0].nod->pos, elm->edu[1].nod->pos,
				   elm->edu[2].nod->pos, gPos) >= 0;
  }
  return(inside);
}

/*!
* \return	Non zero if the given vertex is in the given mesh element.
* \ingroup	WlzMesh
* \brief	Checks whether the vertex at the given position is within
* 		the given mesh element.
* \param	elm			Given mesh element.
* \param	gPos			Given vertex position.
*/
int		WlzCMeshElmEnclosesPos3D(WlzCMeshElm3D *elm, WlzDVertex3 gPos)
{
  int		inside = 0;
  WlzCMeshNod3D *nod[4];

  if(elm)
  {
    WlzCMeshElmGetNodes3D(elm, nod + 0, nod + 1, nod + 2, nod + 3);
    inside = WlzGeomVxInTetrahedron(nod[0]->pos, nod[1]->pos,
    				    nod[2]->pos, nod[3]->pos, gPos) >= 0;
  }
  return(inside);
}

/*!
* \return	New mesh or NULL on error.
* \ingroup	WlzMesh
* \brief	Constructs a 2D or 3D mesh from a 2D or 3D domain object.
*		Because of the difficulty in computing a mesh which conforms
*		to the domain of the given object, the resulting mesh will
*		instead cover the given domain with some nodes of the
*		mesh outside the given domain. All mesh nodes will however
*		be within the dilated domain, where the dilation is by a sphere
*		of radius twice the minimum element size.
* \param	obj			Given domain object.
* \param	minElmSz		Minimum element size.
* \param	maxElmSz		Minimum element size.
* \param	dstDilObj		Destination pointer for the dilated
*					object used to build the mesh.
* \param	conform			If non-zero make the mesh conform to
* 					the object's domain.
*					outside the object if non-zero.
* \param	dstErr			Destination error pointer may be NULL.
*/
WlzCMeshP	WlzCMeshFromObj(WlzObject *obj,
				double minElmSz, double maxElmSz,
				WlzObject **dstDilObj, int conform,
				WlzErrorNum *dstErr)
{
  WlzCMeshP	mesh;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  mesh.v = NULL;
  if(obj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else
  {
    switch(obj->type)
    {
      case WLZ_2D_DOMAINOBJ:
        mesh.m2 = WlzCMeshFromObj2D(obj, minElmSz, maxElmSz, dstDilObj,
		                    conform, &errNum);
        break;
      case WLZ_3D_DOMAINOBJ:
        mesh.m3 = WlzCMeshFromObj3D(obj, minElmSz, maxElmSz, dstDilObj,
		                    conform, &errNum);
        break;
      default:
        errNum = WLZ_ERR_OBJECT_TYPE;
	break;
    }
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	New mesh or NULL on error.
* \ingroup	WlzMesh
* \brief	Constructs a 2D mesh from a 2D domain object.
*		Because of the difficulty in computing a mesh which conforms
*		to the domain of the given object, the resulting mesh will
*		instead cover the given domain with some nodes of the
*		mesh outside the given domain. All mesh nodes will however
*		be within the dilated domain, where the dilation is by a sphere
*		of radius twice the minimum element size.
* \param	obj			Given domain object.
* \param	minElmSz		Minimum element size.
* \param	maxElmSz		Minimum element size.
* \param	dstDilObj		Destination pointer for the dilated
*					object used to build the mesh,
*					may be NULL.
* \param	conform			If non-zero make boundary elements
* 					conform to the given domain by
* 					decomposing them. Any elements with
* 					all nodes outside the given domain
* 					are deleted.
* \param	dstErr			Destination error pointer may be NULL.
*/
WlzCMesh2D	*WlzCMeshFromObj2D(WlzObject *obj,
				   double minElmSz, double maxElmSz,
				   WlzObject **dstDilObj, int conform,
				   WlzErrorNum *dstErr)
{
  int		scale = 1,
  		maxLBTNdSz = 1;
  double	dilation,
  		invScale = 1.0;
  WlzCMesh2D	*mesh = NULL;
  WlzLBTDomain2D *lDom = NULL;
  WlzObject	*dilObj = NULL,
  		*idxObj = NULL,
  		*sclObj = NULL,
		*strObj = NULL;
  WlzAffineTransform *tr = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(obj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else if(obj->type != WLZ_2D_DOMAINOBJ)
  {
    errNum = WLZ_ERR_OBJECT_TYPE;
  }
  else if(obj->domain.core == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(minElmSz < 1.0)
  {
    errNum = WLZ_ERR_PARAM_DATA;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    if(minElmSz < 1.0)
    {
      minElmSz = 1.0;
    }
    scale = (int )ceil(minElmSz);
    dilation = scale + 1.0;
    maxLBTNdSz = (int )ceil(maxElmSz / minElmSz);
    if(maxLBTNdSz < 1)
    {
      maxLBTNdSz = 1;
    }
    invScale = 1.0 / scale;
    strObj = WlzAssignObject(
             WlzMakeRectangleObject(dilation, dilation,
	                            0.0, 0.0, &errNum), NULL);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    dilObj = WlzAssignObject(
    	     WlzStructDilation(obj, strObj, &errNum), NULL);
  }
  (void )WlzFreeObj(strObj); strObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    tr = WlzMakeAffineTransform(WLZ_TRANSFORM_2D_AFFINE, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    (void )WlzAffineTransformScaleSet(tr, invScale, invScale, invScale);
    sclObj = WlzAffineTransformObj(dilObj, tr, WLZ_INTERPOLATION_NEAREST,
				   &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    lDom = WlzLBTDomain2DFromDomain(sclObj->domain, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    idxObj = WlzLBTMakeNodeIndexObj2D(lDom, sclObj->domain.i, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzLBTBalanceDomain2D(lDom, idxObj, maxLBTNdSz, 0);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzLBTIndexObjSetAllNodes2D(lDom, idxObj);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh = WlzCMeshFromBalLBTDom2D(lDom, idxObj, &errNum);
  }
  (void )WlzFreeLBTDomain2D(lDom);
  WlzFreeObj(idxObj); idxObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    (void )WlzAffineTransformScaleSet(tr, scale, scale, scale);
    errNum = WlzCMeshAffineTransformMesh2D(mesh, tr);
  }
  (void )WlzFreeObj(sclObj);
  (void )WlzFreeAffineTransform(tr);
  WlzFreeObj(dilObj); dilObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    dilation = 1.0;
    strObj = WlzAssignObject(
             WlzMakeCircleObject(dilation, 0.0, 0.0, &errNum), NULL);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    dilObj = WlzAssignObject(
    	     WlzStructDilation(obj, strObj, &errNum), NULL);
  }
  (void )WlzFreeObj(strObj);
  if((errNum == WLZ_ERR_NONE) && (conform != 0))
  {
    errNum = WlzCMeshBoundConform2D(mesh, dilObj, 0.5);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    WlzCMeshUpdateBBox2D(mesh);
    WlzCMeshUpdateMaxSqEdgLen2D(mesh);
    errNum = WlzCMeshReassignBuckets2D(mesh, 0);
  }
  if((errNum == WLZ_ERR_NONE) && dstDilObj)
  {
    *dstDilObj = dilObj;
  }
  else
  {
    WlzFreeObj(dilObj);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	New mesh or NULL on error.
* \ingroup	WlzMesh
* \brief	Constructs a 3D mesh from a 3D domain object.
* \param	obj			Given domain object.
* \param	minElmSz		Minimum element size.
* \param	maxElmSz		Minimum element size.
* \param	dstDilObj		Destination pointer for the dilated
*					object used to build the mesh,
*					may be NULL.
* \param	conform			If non-zero make boundary elements
* 					conform to the given domain by
* 					decomposing them. Any elements with
* 					all nodes outside the given domain
* 					are deleted.
* \param	dstErr			Destination error pointer may be NULL.
*/
WlzCMesh3D	*WlzCMeshFromObj3D(WlzObject *obj,
				   double minElmSz, double maxElmSz,
				   WlzObject **dstDilObj, int conform,
			           WlzErrorNum *dstErr)
{
  int		scale = 1,
  		maxLBTNdSz = 1;
  double	dilation,
  		invScale = 1.0;
  WlzCMesh3D	*mesh = NULL;
  WlzLBTDomain3D *lDom = NULL;
  WlzAffineTransform *tr = NULL;
  WlzObject	*dilObj = NULL,
  		*idxObj = NULL,
  		*sclObj = NULL,
		*strObj = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(obj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else if(obj->type != WLZ_3D_DOMAINOBJ)
  {
    errNum = WLZ_ERR_OBJECT_TYPE;
  }
  else if(obj->domain.core == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(minElmSz < 1.0)
  {
    errNum = WLZ_ERR_PARAM_DATA;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    if(minElmSz < 1.0)
    {
      minElmSz = 1.0;
    }
    scale = (int )ceil(minElmSz);
    dilation = (scale  + 1) / 2.0;
    maxLBTNdSz = (int )ceil(maxElmSz / minElmSz);
    if(maxLBTNdSz < 1)
    {
      maxLBTNdSz = 1;
    }
    invScale = 1.0 / scale;
    strObj = WlzAssignObject(
	     WlzMakeCuboidObject(WLZ_3D_DOMAINOBJ,
				dilation, dilation, dilation,
				 0.0, 0.0, 0.0, &errNum), NULL);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    dilObj = WlzAssignObject(
	     WlzStructDilation(obj, strObj, &errNum), NULL);
  }
  (void )WlzFreeObj(strObj); strObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    tr = WlzMakeAffineTransform(WLZ_TRANSFORM_3D_AFFINE, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    (void )WlzAffineTransformScaleSet(tr, invScale, invScale, invScale);
    sclObj = WlzAffineTransformObj(dilObj, tr, WLZ_INTERPOLATION_NEAREST,
				   &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    lDom = WlzLBTDomain3DFromDomain(sclObj->domain, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    idxObj = WlzLBTMakeNodeIndexObj3D(lDom, sclObj->domain.p, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzLBTBalanceDomain3D(lDom, idxObj, maxLBTNdSz, 0);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzLBTIndexObjSetAllNodes3D(lDom, idxObj);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh = WlzCMeshFromBalLBTDom3D(lDom, idxObj, &errNum);
  }
  (void )WlzFreeLBTDomain3D(lDom);
  WlzFreeObj(idxObj); idxObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    (void )WlzAffineTransformScaleSet(tr, scale, scale, scale);
    errNum = WlzCMeshAffineTransformMesh3D(mesh, tr);
  }
  WlzFreeObj(dilObj); dilObj = NULL;
  if((errNum == WLZ_ERR_NONE) && dstDilObj)
  {
    dilObj = WlzAffineTransformObj(sclObj, tr, WLZ_INTERPOLATION_NEAREST,
    				   &errNum);
    *dstDilObj = dilObj;
  }
  (void )WlzFreeObj(sclObj);
  (void )WlzFreeAffineTransform(tr);
  if((errNum == WLZ_ERR_NONE) && (conform != 0))
  {
    errNum = WlzCMeshBoundConform3D(mesh, obj, 0.5);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    WlzCMeshUpdateBBox3D(mesh);
    WlzCMeshUpdateMaxSqEdgLen3D(mesh);
    errNum = WlzCMeshReassignBuckets3D(mesh, 0);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return       New mesh or NULL on error.
* \ingroup      WlzMesh
* \brief        Constructs a 2D mesh from a balanced 2D linear binary
*		tree domain.
* \param	lDom			Linear binary tree domain.
* \param	iObj			Index object for lDom.
* \param        dstErr			Destination error pointer may be NULL.
*/
WlzCMesh2D	*WlzCMeshFromBalLBTDom2D(WlzLBTDomain2D *lDom, WlzObject *iObj,
				         WlzErrorNum *dstErr)
{
  int		idN;
  WlzIVertex2	bSz;
  WlzCMesh2D	*mesh = NULL;
  WlzGreyValueWSpace *iGVWSp = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(lDom == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(iObj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else
  {
    mesh = WlzCMeshNew2D(&errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    iGVWSp = WlzGreyValueMakeWSp(iObj, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->bBox.xMin = lDom->kol1;
    mesh->bBox.yMin = lDom->line1;
    mesh->bBox.xMax = lDom->lastkl;
    mesh->bBox.yMax = lDom->lastln;
    bSz.vtX = mesh->bBox.xMax - mesh->bBox.xMin + 1;
    bSz.vtY = mesh->bBox.yMax - mesh->bBox.yMin + 1;
    if((lDom->nNodes <= 0) || (bSz.vtX <= 0) || (bSz.vtY <= 0))
    {
      errNum = WLZ_ERR_DOMAIN_DATA;
    }
  }
  /* Create an initial grid of buckets. */
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshReassignBuckets2D(mesh, lDom->nNodes * 4);
  }
  /* Add the LBT nodes to the mesh. */
  if(errNum == WLZ_ERR_NONE)
  {
    idN = 0;
    while((errNum == WLZ_ERR_NONE) && (idN < lDom->nNodes))
    {
      errNum = WlzCMeshAddLBTNode2D(mesh, lDom, iGVWSp, idN);
      ++idN;
    }
  }
  /* Free temporary storage. */
  WlzGreyValueFreeWSp(iGVWSp);
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return       New mesh or NULL on error.
* \ingroup      WlzMesh
* \brief        Constructs a 3D mesh from a balanced 3D linear binary
*		tree domain.
*
* For tesselation of a 3D LBT node, each node is condidered to be a cube.
* This can conviniently be represented by it's net and using this
* representation there are 10 possible node-neighbour relationships
* when the rotational degeneracy is ignored:
\verbatim
      Y ^        f1
        | v4     |        v5
        |/       |       /
        *---------------@
        |\       :      :\
        | \      :      : \     f2
        |  \     :      :  \  /
        |   \      f5   :   \/
        |    \          :   .\
     v0 |     \   v7    :  .  \   v6
       \|      \ /      :      \ /
        @...f4..@-------*-------*---->X
         \      |      / .      |
          \     |     v1  .     |
           \    |          .    |
            \   |    . f3   .   |
             \  |     .      .  |
              \ | v3   .      . | v2
               \|/      .      .|/
                @---------------@
                 \        \
                  \        \
                 Z %        f0
                 
\endverbatim
* Faces are defined to have the following orientations, when viewed from
* outside the cube:
\verbatim
          +z          +y          +y          +y          +y          +x
       3-----2     5-----4     6-----5     7-----6     4-----7     5-----6
       |     |     |     |     |     |     |     |     |     |     |     |
     -x|  0  |+x +x|  1  |-x +z|  2  |-z -x|  3  |+x -z|  4  |+z -z|  5  |+z
       |   -y|     |   -z|     |   +x|     |   +z|     |   -x|     |   +y|
       0-----1     1-----0     2-----1     3-----2     0-----3     4-----7
          -z          -y          -y          -y          -y          -x
\endverbatim
* The neighbouring nodes to each of these faces can be found using 3
* orthogonal vectors (looking from outside the cube):
\verbatim
          ^     
       o2 |     
          |        
       +--|--+               o3 = -o1
       |     |               o4 = -o2
 o3 <---     ----> o1
       |    \|    
       +--|--\    
          |   % o0  
       o4 |     
          V     
\endverbatim
* Nets of the LBT node cube looking from outside the cube
\verbatim
        3---2            +-+-+            +-+-+            +-+-+
      0 |   |          1 | | |          2 | | |          3 | | |
        | 0 |            +-+-+            +-+-+            +-+-+
        |   |            | | |            | | |            | | |
        0---1            +-+-+            +-+-+            +-+-+
        |   |            |   |            | | |            |   |
        | 1 |            |   |            +-+-+            |   |
        |   |            |   |            | | |            |   |
    0---4---5---1    +---+---+---+    +---+-+-+---+    +---+-+-+---+
    |   |   |   |    |   |   |   |    |   |   |   |    |   | | |   |
    | 4 | 5 | 2 |    |   |   |   |    |   |   |   |    |   +-+-+   |
    |   |   |   |    |   |   |   |    |   |   |   |    |   | | |   |
    3---7---6---2    +---+---+---+    +---+---+---+    +---+-+-+---+
        |   |            |   |            |   |            |   |
        | 3 |            |   |            |   |            |   |
        |   |            |   |            |   |            |   |
        3---2            +---+            +---+            +---+

        +-+-+            +-+-+            +-+-+            +-+-+
      4 | | |          5 | | |          6 | | |          7 | | |
        +-+-+            +-+-+            +-+-+            +-+-+
        | | |            | | |            | | |            | | |
        +-+-+            +---+            +-+-+            +-+-+
        | | |            | | |            | | |            | | |
        +-+-+            +-+-+            +-+-+            +-+-+
        | | |            | | |            | | |            | | |
    +---+-+-+---+    +---+---+-+-+    +---+---+---+    +---+-+-+---+
    |   | | |   |    |   |   | | |    | | |   | | |    |   | | |   |
    |   +-+-+   |    |   |   +-+-+    +-+-+   +-+-+    |   +-+-+   |
    |   | | |   |    |   |   | | |    | | |   | | |    |   | | |   |
    +---+-+-+---+    +---+---+-+-+    +---+---+---+    +---+-+-+---+
        |   |            |   |            |   |            | | |
        |   |            |   |            |   |            +-+-+
        |   |            |   |            |   |            | | |
        +---+            +---+            +---+            +-+-+

        +-+-+            +-+-+
      8 | | |          9 | | |
        +-+-+            +-+-+
        | | |            | | |
        +-+-+            +-+-+
        | | |            | | |
        +-+-+            +-+-+
        | | |            | | |
    +-+-+-+-+-+-+    +-+-+-+-+-+-+
    | | | | | | |    | | | | | | |
    +-+-+-+-+-+-+    +-+-+-+-+-+-+
    | | | | | | |    | | | | | | |
    +-+-+-+-+-+-+    +-+-+-+-+-+-+
        |   |            | | |
        |   |            +-+-+
        |   |            | | |
        +---+            +---+
\endverbatim
* By placing a mesh node at the centre of the cube, each face can be
* tesselated with tetrahedra almost independently of the other faces.
* This gives the following possible teselations, in which each facet
* on the cubes surface forms a tetrahedron with the node at the cubes
* centre. Here the cube faces which share an edge obviously influence
* the tesselation of a face and so reduce the number of classes to 6:
\verbatim
        +---+            +-+-+            +-+-+            +-+-+
  0=(0) |\ /|      1=(1) |\|/|      2=(2) |\|/|      3=(3) |\|/|
        | X |            +-X-+            +-X-+            +-X-+
        |/ \|            |/|\|            |/|\|            |/|\|
        +---+            +-+-+            +-+-+            +-+-+
        |\ /|            |\|/|            |\|/|            |\|/|
        | X |            | X |            +-X-+            | X |
        |/ \|            |/ \|            |/|\|            |/|\|
    +---+---+---+    +---+---+---+    +-+-+---+-+-+    +---+-+-+---+
    |\ /|\ /|\ /|    |\ /|\ /|\ /|    |\|/|\|/|\|/|    |\ /|\|/|\ /|
    | X | X | X |    +-X | X | X-+    +-X | X | X-+    +-X-+-X-+-X-+
    |/ \|/ \|/ \|    |/ \|/ \|/ \|    |/ \|/ \|/ \|    |/ \|/|\|/ \|
    +---+---+---+    +---+---+---+    +---+---+---+    +---+-+-+---+
        |\ /|            |\ /|            |\ /|            |\|/|
        | X |            | X |            | X |            | X |
        |/ \|            |/|\|            |/|\|            |/|\|
        +---+            +-+-+            +-+-+            +-+-+

        +-+-+            +-+-+            +-+-+            +-+-+
  4=(4) |\|/|      5=(5) |\|/|      6=(6) |\|/|  7=(7,8,9) |\|/|
        +-X-+            +-X-+            +-X-+            +-X-+
        |/|\|            |/|\|            |/|\|            |/|\|
        +-+-+            +-+-+            +-+-+            +-+-+
        |\|/|            |\|/|            |\|/|            |\|/|
        +-X-+            +-X-+            +-X-+            +-X-+
        |/|\|            |/|\|            |/|\|            |/|\|
    +-+-+-+-+-+-+    +-+-+-+-+-+-+    +---+-+-+---+    +-+-+-+-+-+-+
    |\|/|\|/|\|/|    |\|/|\|/|\|/|    |\ /|\|/|\ /|    |\|/|\|/|\|/|
    +-X-+-X-+-X-+    +-X | X-+-X-+    +-X-+-X-+-X-+    +-X-+-X-+-X-+
    |/ \|/|\|/ \|    |/ \|/ \|/|\|    |/|\|/ \|/|\|    |/|\|/|\|/|\|
    +---+-+-+---+    +---+---+-+-+    +-+-+---+-+-+    +-+-+-+-+-+-+
        |\|/|            |\ /|            |\ /|            |\|/|
        | X |            | X-+            +-X-+            +-X-+
        |/|\|            |/|\|            |/|\|            |/|\|
        +-+-+            +-+-+            +-+-+            +-+-+
\endverbatim
* These possible cube face tesselations lead to 6 possible cube face
* tesselations which define struct::_WlzLBTNodeClass2D.
*
* \param	lDom			Linear binary tree domain.
* \param	iObj			Index object for lDom.
* \param        dstErr			Destination error pointer may be NULL.
*/
WlzCMesh3D	*WlzCMeshFromBalLBTDom3D(WlzLBTDomain3D *lDom, WlzObject *iObj,
				         WlzErrorNum *dstErr)
{
  int		idN;
  WlzIVertex3	bSz;
  WlzCMesh3D	*mesh = NULL;
  WlzGreyValueWSpace *iGVWSp = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(lDom == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(iObj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else
  {
    mesh = WlzCMeshNew3D(&errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    iGVWSp = WlzGreyValueMakeWSp(iObj, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->bBox.xMin = lDom->kol1;
    mesh->bBox.yMin = lDom->line1;
    mesh->bBox.zMin = lDom->plane1;
    mesh->bBox.xMax = lDom->lastkl;
    mesh->bBox.yMax = lDom->lastln;
    mesh->bBox.zMax = lDom->lastpl;
    bSz.vtX = mesh->bBox.xMax - mesh->bBox.xMin + 1;
    bSz.vtY = mesh->bBox.yMax - mesh->bBox.yMin + 1;
    bSz.vtZ = mesh->bBox.zMax - mesh->bBox.zMin + 1;
    if((lDom->nNodes <= 0) ||
       (bSz.vtX <= 0) || (bSz.vtY <= 0) || (bSz.vtZ <= 0))
    {
      errNum = WLZ_ERR_DOMAIN_DATA;
    }
  }
  /* Create an initial grid of buckets. */
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshReassignBuckets3D(mesh, lDom->nNodes * 4);
  }
  /* Add the LBT nodes to the mesh. */
  if(errNum == WLZ_ERR_NONE)
  {
    idN = 0;
    while((errNum == WLZ_ERR_NONE) && (idN < lDom->nNodes))
    {
      errNum = WlzCMeshAddLBTNode3D(mesh, lDom, iGVWSp, idN);
      ++idN;
    }
  }
  /* Free temporary storage. */
  WlzGreyValueFreeWSp(iGVWSp);
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return       Woolz error code.
* \ingroup      WlzMesh
* \brief        Adds a balanced LBT node to a 2D mesh.
*		LBT nodes which have the boundary flag set result in
*		mesh elements which hae the boundary flag set.
* \param	mesh			The mesh.
* \param	lDom			Linear binary tree domain.
* \param	iGVWSp			Grey workspace for index object.
* \param        idN			Index of the LBT node.
*/
static WlzErrorNum WlzCMeshAddLBTNode2D(WlzCMesh2D *mesh,
					WlzLBTDomain2D *lDom,
				        WlzGreyValueWSpace *iGVWSp,
					int idN)
{
  int		rot,
  		nElm,
		nNod;
  WlzLBTNodeClass2D cls;
  WlzDVertex2	nPos[8];
  WlzCMeshNod2D	*mNod[8];
  WlzCMeshElm2D	*mElm[6];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Classify the LBT node. */
  WlzLBTClassifyNode2D(lDom, iGVWSp, idN, &cls, &rot);
  /* Compute mesh node positions. */
  nNod = WlzCMeshCompLBTNodPos2D(nPos, lDom, idN,  cls, rot);
  /* Match mesh nodes to computed positions. */
  (void )WlzCMeshMatchNNod2D(mesh, nNod, nPos, mNod);
  /* Create nodes that don't already exist. */
  for(idN = 0; idN < nNod; ++idN)
  {
    if(mNod[idN] == NULL)
    {
      mNod[idN] = WlzCMeshNewNod2D(mesh, nPos[idN], &errNum);
      if(errNum != WLZ_ERR_NONE)
      {
        break;
      }
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    /* Create new mesh elements. */
    errNum = WlzCMeshElmFromLBTNode2D(mesh, nPos, mElm, mNod, cls, &nElm);
  }
#ifdef WLZ_CMESH_DEBUG_MESH
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return       Woolz error code.
* \ingroup      WlzMesh
* \brief        Adds a balanced LBT node to a 3D mesh.
*		LBT nodes which have the boundary flag set result in
*		mesh elements which hae the boundary flag set.
* \param	mesh			The mesh.
* \param	lDom			Linear binary tree domain.
* \param	iGVWSp			Grey workspace for index object.
* \param        idN			Index of the LBT node.
*/
static WlzErrorNum WlzCMeshAddLBTNode3D(WlzCMesh3D *mesh,
					WlzLBTDomain3D *lDom,
				        WlzGreyValueWSpace *iGVWSp,
					int idN)
{
  int		idF,
		idM,
		rot,
		nNod;
  WlzIBox3	nBB;
  WlzDVertex3	vtx[8];
  WlzLBTNodeClass2D cls; /* The 2D node classification is valid for faces. */
  WlzDVertex3	nPos[27]; /* Nodes at cube vertices (8), edge midpoints (12),
                             face centres (6) and cube centre (1) = 27. */
  WlzCMeshElm3D *mElm[8];
  WlzCMeshNod3D	*mNod[10];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* For each face of the LBT node's cube:
   * Compute the tesselation of the cube face.
   * Form tetrahedra from the vertices of these triangles and the centre of
   * the cube, resulting in a pyramid of tetrahedra.
   * Join tesselated pyramids to the existing mesh.
   */
  idF = 0;
  WlzLBTKeyToBox3I((lDom->nodes + idN)->keys, &nBB);
#ifdef WLZ_CMESH_DEBUG_MESH
  (void )fprintf(stderr, "WlzCMeshAddLBTNode3D() "
                         "% 6d % 6d % 6d % 6d % 6d % 6d\n",
			 nBB.xMin, nBB.yMin, nBB.zMin,
			 nBB.xMax, nBB.yMax, nBB.zMax);
#endif
  /* These vertices are the "origin" vertices for the faces of the
   * LBT node as defined in the comments for WlzCMeshFromBalLBTDom3D(). */
  vtx[0].vtX = nBB.xMin;       /* face = 0, vertex = 0 */
  vtx[0].vtY = nBB.yMin;
  vtx[0].vtZ = nBB.zMin;
  vtx[1].vtX = nBB.xMax + 1.0; /* face = 1, vertex = 1 */
  vtx[1].vtY = nBB.yMin;
  vtx[1].vtZ = nBB.zMin;
  vtx[2].vtX = nBB.xMax + 1.0; /* face = 2, vertex = 2 */
  vtx[2].vtY = nBB.yMin;
  vtx[2].vtZ = nBB.zMax + 1.0;
  vtx[3].vtX = nBB.xMin;       /* face = 3, vertex = 3 */
  vtx[3].vtY = nBB.yMin;
  vtx[3].vtZ = nBB.zMax + 1.0;
  vtx[4].vtX = nBB.xMin;       /* face = 4, vertex = 0 */
  vtx[4].vtY = nBB.yMin;
  vtx[4].vtZ = nBB.zMin;
  vtx[5].vtX = nBB.xMin;       /* face = 5, vertex = 4 */
  vtx[5].vtY = nBB.yMax + 1.0;
  vtx[5].vtZ = nBB.zMin;
  while((errNum == WLZ_ERR_NONE) && (idF < 6))
  {
    /* Classify the cube face. */
    WlzLBTClassifyNodeFace3D(lDom, iGVWSp, idN, idF, vtx, &cls, &rot);
    /* Compute the positions of the mesh nodes. */
    nNod = WlzCMeshCompLBTFceNodPos3D(nPos, lDom, idN,  idF, cls, rot);
    /* Match mesh nodes to computed positions. */
    (void )WlzCMeshMatchNNod3D(mesh, nNod, nPos, mNod);
    /* Create nodes that don't already exist. */
    for(idM = 0; idM < nNod; ++idM)
    {
      if(mNod[idM] == NULL)
      {
	mNod[idM] = WlzCMeshNewNod3D(mesh, nPos[idM], &errNum);
	if(errNum != WLZ_ERR_NONE)
	{
	  break;
	}
      }
    }
    if(errNum == WLZ_ERR_NONE)
    {
      /* Create new mesh elements. */
      errNum = WlzCMeshElmFromLBTNode3D(mesh, nPos, mElm, mNod, cls);
    }
    ++idF;
  }
#ifdef WLZ_CMESH_DEBUG_MESH
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify3D(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return	Number of nodes for the given LBT domain node.
* \ingroup	WlzMesh
* \brief	Computes the positions of the mesh nodes for the given
*		2D LBT domain node.
* \param	nPos			Array for node positions.
* \param	lDom			LBT domain.
* \param	idN			Index of LBT node.
* \param	cls			LBT node adjacency class.
* \param	rot			LBT node rotation from class.
*/
static int	WlzCMeshCompLBTNodPos2D(WlzDVertex2 *nPos,
				      WlzLBTDomain2D *lDom,
				      int idN,  WlzLBTNodeClass2D cls, int rot)
{
  int		nNod = 0;
  double	tD0,
  		hWidth,
		width;
  WlzIVertex2	lPos;

  /* Compute LBT node's position and size / 2. */
  WlzLBTKeyToPos2I((lDom->nodes + idN)->keys, &lPos);
  width = (double )WlzLBTNodeSz2D(lDom->nodes + idN);
  hWidth = width / 2.0;
  /* Set relative mesh node positions without rotation or offset. */
  switch(cls)
  {
    case WLZ_LBT_NODE_CLASS_2D_0:
      nNod  = 4;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = width;  nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = width;
      nPos[3].vtX = 0.0;    nPos[3].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_1:
      nNod  = 5;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = width;  nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = width;
      nPos[3].vtX = hWidth; nPos[3].vtY = width;
      nPos[4].vtX = 0.0;    nPos[4].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_2:
      nNod  = 6;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = width;  nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = hWidth;
      nPos[3].vtX = width;  nPos[3].vtY = width;
      nPos[4].vtX = hWidth; nPos[4].vtY = width;
      nPos[5].vtX = 0.0;    nPos[5].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_3:
      nNod  = 6;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = hWidth; nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = 0.0;
      nPos[3].vtX = width;  nPos[3].vtY = width;
      nPos[4].vtX = hWidth; nPos[4].vtY = width;
      nPos[5].vtX = 0.0;    nPos[5].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_4:
      nNod  = 7;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = hWidth; nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = 0.0;
      nPos[3].vtX = width;  nPos[3].vtY = hWidth;
      nPos[4].vtX = width;  nPos[4].vtY = width;
      nPos[5].vtX = hWidth; nPos[5].vtY = width;
      nPos[6].vtX = 0.0;    nPos[6].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_5:
      nNod  = 8;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = hWidth; nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = 0.0;
      nPos[3].vtX = width;  nPos[3].vtY = hWidth;
      nPos[4].vtX = width;  nPos[4].vtY = width;
      nPos[5].vtX = hWidth; nPos[5].vtY = width;
      nPos[6].vtX = 0.0;    nPos[6].vtY = width;
      nPos[7].vtX = 0.0;    nPos[7].vtY = hWidth;
      break;
  }
  /* Rotate the mesh nodes adding the offset from the LBT node's position. */
  switch(rot)
  {
    case 0:
      for(idN = 0; idN < nNod; ++idN)
      {
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtY;
      }
      break;
    case 1:
      for(idN = 0; idN < nNod; ++idN)
      {
	tD0 = nPos[idN].vtX;
	nPos[idN].vtX = lPos.vtX + width - nPos[idN].vtY;
	nPos[idN].vtY = lPos.vtY + tD0;
      }
      break;
    case 2:
      for(idN = 0; idN < nNod; ++idN)
      {
	nPos[idN].vtX = lPos.vtX + width - nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + width - nPos[idN].vtY;
      }
      break;
    case 3:
      for(idN = 0; idN < nNod; ++idN)
      {
	tD0 = nPos[idN].vtX;
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtY;
	nPos[idN].vtY = lPos.vtY + width - tD0;
      }
      break;
  }
  return(nNod);
}

/*!
* \return	Number of nodes for the given LBT domain node face.
* \ingroup	WlzMesh
* \brief	Computes the positions of the mesh nodes for the given
*		face of a 3D LBT domain node.
* \param	nPos			Array for node positions.
* \param	lDom			LBT domain.
* \param	idN			Index of LBT node.
* \param	idF			Index of the face.
* \param	cls			LBT node adjacency class.
* \param	rot			LBT node rotation from class.
*/
static int	WlzCMeshCompLBTFceNodPos3D(WlzDVertex3 *nPos,
				      WlzLBTDomain3D *lDom, int idN,
				      int idF, WlzLBTNodeClass2D cls, int rot)
{
  int		nNod = 0;
  double	tX,
		tY,
  		sz,
		hSz;
  WlzIVertex3	lPos;

  /* TODO Check this function! */

  /* Compute LBT node's position and size / 2. */
  WlzLBTKeyToPos3I((lDom->nodes + idN)->keys, &lPos);
  sz = (double )WlzLBTNodeSz3D(lDom->nodes + idN);
  hSz = sz / 2.0;
  /* Set relative mesh node positions without rotation or offset
   * all for face 0, all as defined in the comments for function
   * WlzCMeshFromBalLBTDom3D(). */
  nPos[0].vtX = hSz; nPos[0].vtY = hSz; nPos[0].vtZ = hSz;   /* Cube centre. */
  nPos[1].vtX = hSz; nPos[1].vtY = 0.0; nPos[1].vtZ = hSz;   /* Face centre. */
  nPos[2].vtX = 0.0; nPos[2].vtY = 0.0; nPos[2].vtZ = 0.0;
  nPos[3].vtX = sz;  nPos[3].vtY = 0.0; nPos[3].vtZ = 0.0;
  nPos[4].vtX = sz;  nPos[4].vtY = 0.0; nPos[4].vtZ = sz;
  nPos[5].vtX = 0.0; nPos[5].vtY = 0.0; nPos[5].vtZ = sz;
  switch(cls)
  {
    case WLZ_LBT_NODE_CLASS_2D_0:
      nNod  = 6;
      break;
    case WLZ_LBT_NODE_CLASS_2D_1:
      nNod  = 7;
      nPos[6].vtX = hSz; nPos[6].vtY = 0.0; nPos[6].vtZ = sz;
      break;
    case WLZ_LBT_NODE_CLASS_2D_2:
      nNod  = 8;
      nPos[6].vtX = hSz; nPos[6].vtY = 0.0; nPos[6].vtZ = sz;
      nPos[7].vtX = sz;  nPos[7].vtY = 0.0; nPos[7].vtZ = hSz;
      break;
    case WLZ_LBT_NODE_CLASS_2D_3:
      nNod  = 8;
      nPos[6].vtX = hSz; nPos[6].vtY = 0.0; nPos[6].vtZ = sz;
      nPos[7].vtX = hSz; nPos[7].vtY = 0.0; nPos[7].vtZ = 0.0;
      break;
    case WLZ_LBT_NODE_CLASS_2D_4:
      nNod  = 9;
      nPos[6].vtX = hSz; nPos[6].vtY = 0.0; nPos[6].vtZ = sz;
      nPos[7].vtX = hSz; nPos[7].vtY = 0.0; nPos[7].vtZ = 0.0;
      nPos[8].vtX = sz;  nPos[8].vtY = 0.0; nPos[8].vtZ = hSz;
      break;
    case WLZ_LBT_NODE_CLASS_2D_5:
      nNod  = 10;
      nPos[6].vtX = hSz; nPos[6].vtY = 0.0; nPos[6].vtZ = sz;
      nPos[7].vtX = hSz; nPos[7].vtY = 0.0; nPos[7].vtZ = 0.0;
      nPos[8].vtX = sz;  nPos[8].vtY = 0.0; nPos[8].vtZ = hSz;
      nPos[9].vtX = 0.0; nPos[9].vtY = 0.0; nPos[9].vtZ = hSz;
      break;
  }
  /* Rotate the mesh nodes to the correct orientation of face 0 about the
   * y axis. */
  switch(rot)
  {
    case 0:
      /* 3---2  ^z  %y
       * |   |  |  /
       * | 0 |  | /
       * |   |  |/
       * 0---1  +--->x
       */
      break;
    case 1:
      /* 3---2    2---1
       * |   |    |   |
       * | 0 |    | 0 |
       * |   |    |   |
       * 0---1    3---0
       */
      for(idN = 2; idN < nNod; ++idN)
      {
	tX = nPos[idN].vtX;
	nPos[idN].vtX = sz - nPos[idN].vtZ;
	nPos[idN].vtZ = tX;
      }
      break;
    case 2:
      /* 3---2    1---0
       * |   |    |   |
       * | 0 |    | 0 |
       * |   |    |   |
       * 0---1    2---3
       */
      for(idN = 2; idN < nNod; ++idN)
      {
	nPos[idN].vtX = sz - nPos[idN].vtX;
	nPos[idN].vtZ = sz - nPos[idN].vtZ;
      }
      break;
    case 3:
      /* 3---2    0---3
       * |   |    |   |
       * | 0 |    | 0 |
       * |   |    |   |
       * 0---1    1---2
       */
      for(idN = 2; idN < nNod; ++idN)
      {
	tX = nPos[idN].vtX;
	nPos[idN].vtX = nPos[idN].vtZ;
	nPos[idN].vtZ = sz - tX;
      }
      break;
  }
  /* Transform the nodes from face 0 to face N and add the node origin. */
  switch(idF)
  {
    case 0:
      /* 3---2  ^ z
       * |   |  |
       * | 0 |  | % y
       * |   |  |/
       * 0---1  +--->x
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtY;
	nPos[idN].vtZ = lPos.vtZ + nPos[idN].vtZ;
      }
      break;
    case 1:
      /* 3---2  ^ z       5---4        ^ y
       * |   |  |         |   |        | 
       * | 0 |  | % y  -> | 1 |        | % z
       * |   |  |/        |   |        |/    
       * 0---1  +---> x   1---0  x <---+
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	tY = nPos[idN].vtY;
	nPos[idN].vtX = lPos.vtX + sz - nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtZ;
	nPos[idN].vtZ = lPos.vtZ + tY;
      }
      break;
    case 2:
      /* 3---2  ^ z         6---5      ^ y
       * |   |  |           |   |      |
       * | 0 |  | % y    -> | 2 |      |
       * |   |  |/          |   |   z  |
       * 0---1  +---> x     2---1  <---+
       *                                \
       *                                 % x
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	tX = nPos[idN].vtX;
	tY = nPos[idN].vtY;
	nPos[idN].vtX = lPos.vtX + sz - tY;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtZ;
	nPos[idN].vtZ = lPos.vtZ + sz - tX;
      }
      break;
    case 3:
      /* 3---2  ^ z         7---6  ^ y
       * |   |  |           |   |  |
       * | 0 |  | % y    -> | 3 |  |
       * |   |  |/          |   |  |
       * 0---1  +---> x     3---2  +--->x
       *                            \
       *                             % z
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	tY = nPos[idN].vtY;
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtZ;
	nPos[idN].vtZ = lPos.vtZ + sz - tY;
      }
      break;
    case 4:
      /* 3---2  ^ z         4---7  ^ y
       * |   |  |           |   |  |
       * | 0 |  | % y    -> | 4 |  | % x
       * |   |  |/          |   |  |/
       * 0---1  +---> x     0---3  +--->z
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	tX = nPos[idN].vtX;
	tY = nPos[idN].vtY;
	nPos[idN].vtX = lPos.vtX + tY;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtZ;
	nPos[idN].vtZ = lPos.vtZ + tX;
      }
      break;
    case 5:
      /* 3---2  ^ z         5---6  ^ x
       * |   |  |           |   |  |
       * | 0 |  | % y    -> |   |  |
       * |   |  |/          |   |  |
       * 0---1  +---> x     4---7  +---> z
       *                            \
       *                             % y
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	tX = nPos[idN].vtX;
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtZ;
	nPos[idN].vtY = lPos.vtY + sz - nPos[idN].vtY;
	nPos[idN].vtZ = lPos.vtZ + tX;
      }
      break;
  }
  return(nNod);
}

/*!
* \return	The opposite edge or NULL if there is no opposite edge.
* \ingroup	WlzMesh
* \brief	Finds the opposite edge (to set the opp link) using node
*		nnxt links.
* \param	gEdu			Given edge.
*/
static WlzCMeshEdgU2D *WlzCMeshEdgUseFindOpp2D(WlzCMeshEdgU2D *gEdu)
{
  WlzCMeshEdgU2D *fEdu,
  		*tEdu,
		*oEdu = NULL;

  tEdu = fEdu = gEdu->next->nod->edu;
  do
  {
    if(tEdu->next->nod == gEdu->nod)
    {
      oEdu = tEdu;
      break;
    }
    tEdu = tEdu->nnxt;
  } while(tEdu != fEdu);
  return(oEdu);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the mesh elements for an LBT node. All pointers
*		must be valid but this is not checked for because this is
*		a static function.
* \param	mesh			The mesh.
* \param	nPos			Positions of the nodes.
* \param	mElm			The new mesh elements.
* \param	mNod			Mesh nodes, non-NULL where the
*					already exist.
* \param	cls			LBT node connectivity class.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmFromLBTNode2D(WlzCMesh2D *mesh,
                                        WlzDVertex2 *nPos,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
					WlzLBTNodeClass2D cls,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  *dstNElm = 0;
  switch(cls)
  {
    case WLZ_LBT_NODE_CLASS_2D_0:
      errNum = WlzCMeshElmsFromLBTNode2D0(mesh, mElm, mNod, nPos, dstNElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_1:
      errNum = WlzCMeshElmsFromLBTNode2D1(mesh, mElm, mNod, nPos, dstNElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_2:
      errNum = WlzCMeshElmsFromLBTNode2D2(mesh, mElm, mNod, nPos, dstNElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_3:
      errNum = WlzCMeshElmsFromLBTNode2D3(mesh, mElm, mNod, nPos, dstNElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_4:
      errNum = WlzCMeshElmsFromLBTNode2D4(mesh, mElm, mNod, nPos, dstNElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_5:
      errNum = WlzCMeshElmsFromLBTNode2D5(mesh, mElm, mNod, nPos, dstNElm);
      break;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the mesh elements for an LBT node. All pointers
*		must be valid but this is not checked for because this is
*		a static function.
* \param	mesh			The mesh.
* \param	nPos			Positions of the nodes.
* \param	mElm			The new mesh elements.
* \param	mNod			Mesh nodes, non-NULL where the
*					already exist.
* \param	cls			LBT node connectivity class.
*/
static WlzErrorNum WlzCMeshElmFromLBTNode3D(WlzCMesh3D *mesh,
                                        WlzDVertex3 *nPos,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
					WlzLBTNodeClass2D cls)
{
  int		nElm = 0;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  switch(cls)
  {
    case WLZ_LBT_NODE_CLASS_2D_0:
      errNum = WlzCMeshElmsFromLBTNode3D0(mesh, mElm, mNod, nPos, &nElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_1:
      errNum = WlzCMeshElmsFromLBTNode3D1(mesh, mElm, mNod, nPos, &nElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_2:
      errNum = WlzCMeshElmsFromLBTNode3D2(mesh, mElm, mNod, nPos, &nElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_3:
      errNum = WlzCMeshElmsFromLBTNode3D3(mesh, mElm, mNod, nPos, &nElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_4:
      errNum = WlzCMeshElmsFromLBTNode3D4(mesh, mElm, mNod, nPos, &nElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_5:
      errNum = WlzCMeshElmsFromLBTNode3D5(mesh, mElm, mNod, nPos, &nElm);
      break;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 2 mesh elements for a WLZ_LBT_NODE_CLASS_2D_0
*		LBT node.
*		\verbatim
                         nod3                 nod2
                          O                    O
                            +---------------
                           |       0       +
                           |              / /
                           |             / / +
                           |            / /  |
                           |           / /   |
                           |          / /    |
                  elm1 --------      / /     |
                           |       2/ /      |
                           |1      / /       |
                           |      / /2       |
                           |     / /         |
                           |    / /         1|
                           |   / /           |
                           |  / /       --------- elm0
                           + / /             |
                            / +      0       |
                              --------------+
                          O                    O
                         nod0                 nod1
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D0(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[2], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[2], mNod[3], mNod[0], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 2;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_1
*		LBT node.
*		\verbatim
                          nod4              nod3           nod2
			   O                 O              O
                             +--------------   +------------ 
                           |       0        /\       1       
                           |              +/ +\             +
                           |             //   \\            |
                           |            //     \\       -------- elm 1
                   elm2 -------        //       \\          |
                           |          //         \\        0|         
                           |         //           \\        |          
                           |1      2//2           1\\2      |           
                           |       //               \\      |            
                           |      //                 \\     |             
                           |     //                   \\    |              
                           |    //                     \\   |               
                           |   //                       \\  |                
                           |  //                         \+ |                 
                           + /+                 |         \ |                  
                            /              0    |           |
                             -------------------|---------+  
		          O                     |            O
                         nod0                 elm0          nod1
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D1(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[0], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 3;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 4 mesh elements for a WLZ_LBT_NODE_CLASS_2D_2
*		LBT node.
*		\verbatim
                          nod5              nod4           nod3
			   O                 O              O
                             +--------------   +------------ 
                           |        0      +/  +\     1     +
                           |              //     \\         |
                           |             //        \\      0|
                           |            //          1\\2  ----- elm1  
                   elm2 ------         //              \\   |
                           |          //                 \+ |         
                           |         //      elm3           O nod2     
                           |1      2//2                                 
                           |       //                   +/  +            
                           |      //                //      |             
                           |     //             //          |              
                           |    //         0//2             |               
                           |   //       //                 1|                
                           |  //    //                      |                 
                           + /+ /+                          |                  
                                              0 |           |
                              ------------------|---------+  
		          O                     |            O
                         nod0                 elm0          nod1
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D2(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[2], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[2], mNod[3], mNod[4], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[4], mNod[5], mNod[0], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[2], mNod[4], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 4;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_3
*		LBT node.
*		\verbatim
                          nod5             nod4             nod3
			   O                O                O
                             +-------------    +------------- 
                           |       0         |       0        
                           |                +|               +
                           |             +/ ||             +/|
                           |            //  ||            // |         
                           |    elm3   //   ||    elm2   //  |
                           |          //    ||          //   |         
                           |         //     ||         //    |          
                           |1      2//      ||1      2//     |           
                           |       //       ||       //      |            
                           |      //2      1||      //       |             
                           |     //         ||     //2      1|              
                           |    //          ||    //         |               
                           |   //           ||   //          |                
                           |  //   elm0     ||  //  elm1     |                 
                           + /+             |+ //            |                  
                                    0       |        0       |
                              -----------+    -------------+  
		          O                 O                O
                         nod0              nod1             nod2
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D3(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[4], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[1], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[4], mNod[5], mNod[0], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 4;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_4
*		LBT node.
*		\verbatim
                          nod6             nod5             nod4
			   O                O                O
                             +-------------    +------------- 
                           |       0         | +\     1      +
                           |              +/+|  \\           |
                           |             // ||    \\      ------ elm2
                           |            //  ||      \\2      |         
                           |    elm3   //   ||      1 \\    0|
                           |          //    ||          \\   |         
                           |         //     ||            \+            
                           |1      2//      ||   elm4        O nod3      
                           |       //2      ||             +/              
                           |      //      1 ||2          //  +             
                           |     //         ||         //    |              
                           |    //          ||      0//      |               
                           |   //           ||     //2      1|                
                           |  //   elm0     ||   //          |                 
                           | /+             |+ /+         ------ elm1           
                                    0       |        0       |
                              -----------+    ------------+  
		           O                O                O
                          nod0             nod1             nod2
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D4(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[5], mNod[6], mNod[0], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[4] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[3], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 5;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_5
*		LBT node.
*		\verbatim
                          nod6             nod5             nod4
			   O                O                O
                             +-------------    +------------- 
                           |       0     +/  | +\      1     +
                           |1          //   +|  \\          0|
                           |        2//     ||    \\         |
                     elm3 ---      //2      ||      \\2    ---- elm2   
                           |     //         ||       1\\     |
                           +   //           ||          \\   |         
                             /+             ||            \+            
                      nod7 O       elm4    1||2  elm5        O nod3      
                             +              ||             +/              
                           |  \\            ||           //  +             
                           |    \\          ||         //    |              
                           |      \\0       ||      0//      |               
                           |2     1 \\      ||     //2      1|                
                           |          \\    ||   //          |                 
                           +            \+  |+ /+            |                  
                                 | 0        |        | 0     |
                              ---|-------+    -------|----+  
		           O     |          O        |       O
                          nod0             nod1             nod2
		                elm0                elm1
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D5(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[7], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[5], mNod[6], mNod[7], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[4] = WlzCMeshNewElm2D(mesh, mNod[7], mNod[1], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[5] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[3], mNod[5], &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 6;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 4 mesh elements for a WLZ_LBT_NODE_CLASS_2D_0
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             / \                                             
                            /   \                                            
                           /     \                                           
                          /       \                                          
                         /         \                                         
                        /    f1     \                                        
                       /             \                                       
                    n5o---------------on4                      
                     /|\     f0      /|\                                     
                    / | \           / | \                                    
                   /  |  \  elm2   /  |  \                               
                  /   |   \       /   |   \                              
                 /    |    \     /    |    \                            
                /     |     \   /     |     \                          
               /      |      \ /      |      \                        
            n0o       |  elm1 o elm3  |       on0                    
               \  f1  |      /|\      |      /                      
                \     | f0  / | \  f0 |     /                            
                 \    |    /  n1 \    |    /                               
                  \   |   /       \   |   /                           
                   \  |  /  elm0   \  |  /                      
                    \ | /           \ | /                                    
                     \|/     f0      \|/                             
                    n2o---------------on3                          
                       \             /                      
                        \    f1     /                                         
                         \         /                             
                          \       /                             
                           \     /                             
                            \   /                             
                             \ /                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D0(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[4][4] =
                {
		  {3, 2, 0, 1},
		  {2, 5, 0, 1},
		  {5, 4, 0, 1},
		  {4, 3, 0, 1}
		};
  const int	nElm = 4;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 5 mesh elements for a WLZ_LBT_NODE_CLASS_2D_1
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             /|\                                             
                            / | \                                            
                           /  |  \                                           
                          / f1|f1 \                                          
                         /    |    \                                         
                        /     | n6  \                                        
                       /      |/     \                                       
                    n5o-------o-------on4                      
                     /|\      |      /|\                                     
                    / | \ elm2|elm3 / | \                                    
                   /  |  \    |    /  |  \                               
                  /   |   \ f0|f0 /   |   \                              
                 /    |    \  |  /    |    \                            
                /     |     \ | /     |     \                          
               /      |      \|/      |      \                        
            n0o       |  elm1 o elm4  |       on0                    
               \  f1  |      /|\      |      /                      
                \     | f0  / | \  f0 |     /                            
                 \    |    /  n1 \    |    /                               
                  \   |   /       \   |   /                           
                   \  |  /  elm0   \  |  /                      
                    \ | /           \ | /                                    
                     \|/     f0      \|/                             
                    n2o---------------on3                          
                       \             /                      
                        \    f1     /                                         
                         \         /                             
                          \       /                             
                           \     /                             
                            \   /                             
                             \ /                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D1(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[5][4] =
                {
		  {3, 2, 0, 1},
		  {2, 5, 0, 1},
		  {5, 6, 0, 1},
		  {6, 4, 0, 1},
		  {4, 3, 0, 1}
		};
  const int	nElm = 5;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 6 mesh elements for a WLZ_LBT_NODE_CLASS_2D_2
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             /|\                                             
                            / | \                                            
                           /  |  \                                           
                          / f1|f1 \                                          
                         /    |    \                                         
                        /     | n6  \                                        
                       /      |/     \                                       
                    n5o-------o-------on4                      
                     /|\      |      /|\                                     
                    / | \ elm2|elm3 / | \                                    
                   /  |  \    |    /  |  \                               
                  /   |   \ f0|f0 /   |f1 \                              
                 /    |    \  |  /    |    \                            
                /     |     \ | / elm4|     \                          
               /      |      \|/f0    |      \                        
            n0o       |  elm1 o-------o-------on0                    
               \  f1  |      /|\f0    |\     /                      
                \     | f0  / | \ elm5| n7  /                            
                 \    |    /  n1 \    |    /                               
                  \   |   /       \   |f1 /                           
                   \  |  /  elm0   \  |  /                      
                    \ | /           \ | /                                    
                     \|/     f0      \|/                             
                    n2o---------------on3                          
                       \             /                      
                        \    f1     /                                         
                         \         /                             
                          \       /                             
                           \     /                             
                            \   /                             
                             \ /                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D2(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[6][4] =
                {
		  {3, 2, 0, 1},
		  {2, 5, 0, 1},
		  {5, 6, 0, 1},
		  {6, 4, 0, 1},
		  {4, 7, 0, 1},
		  {7, 3, 0, 1}
		};
  const int	nElm = 6;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 6 mesh elements for a WLZ_LBT_NODE_CLASS_2D_3
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             /|\                                             
                            / | \                                            
                           /  |  \                                           
                          / f1|f1 \                                          
                         /    |    \                                         
                        /     | n6  \                                        
                       /      |/     \                                       
                    n5o-------o-------on4                      
                     /|\      |      /|\                                     
                    / | \ elm3|elm4 / | \                                    
                   /  |  \    |    /  |  \                               
                  /   |   \ f0|f0 /   |f1 \                              
                 /    |    \  |  /    |    \                            
                /     |     \ | /  f0 |     \
               /      |      \|/      |      \                        
            n0o       |  elm2 o-n1    |       on0                    
               \  f1  |      /|\      |      /                      
                \     | f0  / | \ elm5|     /                            
                 \    |    /  |  \    |    /                               
                  \   |   / f0|f0 \   |   /                           
                   \  |  /    |    \  |  /                      
                    \ | / elm1|elm0 \ | /                                    
                     \|/      |      \|/                             
                    n2o-------o-------on3                          
                       \      |\      /                      
                        \     | n7  /                                         
                         \    |    /                             
                          \ f1|f1 /                             
                           \  |  /                             
                            \ | /                             
                             \|/                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D3(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[6][4] =
                {
		  {3, 7, 0, 1},
		  {7, 2, 0, 1},
		  {2, 5, 0, 1},
		  {5, 6, 0, 1},
		  {6, 4, 0, 1},
		  {4, 3, 0, 1}
		};
  const int	nElm = 6;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 7 mesh elements for a WLZ_LBT_NODE_CLASS_2D_4
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             /|\                                             
                            / | \                                            
                           /  |  \                                           
                          / f1|f1 \                                          
                         /    |    \                                         
                        /     | n6  \                                        
                       /      |/     \                                       
                    n5o-------o-------on4                      
                     /|\      |      /|\                                     
                    / | \ elm3|elm4 / | \                                    
                   /  |  \    |    /  |  \                               
                  /   |   \ f0|f0 / f0|f1 \                              
                 /    |    \  |  /    |    \                            
                /     |     \ | / elm5| n8  \
               /      |      \|/n1    |/     \                        
            n0o       |  elm2 o-------o-------on0                    
               \  f1  |      /|\      |      /                      
                \     | f0  / | \ elm6|     /                            
                 \    |    /  |  \    |    /                               
                  \   |   / f0|f0 \ f0|f1 /                           
                   \  |  /    |    \  |  /                      
                    \ | / elm1|elm0 \ | /                                    
                     \|/      |      \|/                             
                    n2o-------o-------on3                          
                       \      |\      /                      
                        \     | n7  /                                         
                         \    |    /                             
                          \ f1|f1 /                             
                           \  |  /                             
                            \ | /                             
                             \|/                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D4(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[7][4] =
                {
		  {3, 7, 0, 1},
		  {7, 2, 0, 1},
		  {2, 5, 0, 1},
		  {5, 6, 0, 1},
		  {6, 4, 0, 1},
		  {4, 8, 0, 1},
		  {8, 3, 0, 1}
		};
  const int	nElm = 7;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 8 mesh elements for a WLZ_LBT_NODE_CLASS_2D_5
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             /|\                                             
                            / | \                                            
                           /  |  \                                           
                          / f1|f1 \                                          
                         /    |    \                                         
                        /     | n6  \                                        
                       /      |/     \                                       
                    n5o-------o-------on4                      
                     /|\      |      /|\                                     
                    / | \ elm4|elm5 / | \                                    
                   /  |  \    |    /  |  \                               
                  / f1|f0 \ f0|f0 / f0|f1 \                              
                 /    |    \  |  /    |    \                            
                /  n9 |elm3 \ | / elm6| n8  \
               /     \|      \|/n1    |/     \                        
            n0o-------o-------o-------o-------on0                    
               \      |      /|\      |      /                      
                \     |elm2 / | \ elm7|     /                            
                 \    |    /  |  \    |    /                               
                  \ f1|f0 / f0|f0 \ f0|f1 /                           
                   \  |  /    |    \  |  /                      
                    \ | / elm1|elm0 \ | /                                    
                     \|/      |      \|/                             
                    n2o-------o-------on3                          
                       \      |\      /                      
                        \     | n7  /                                         
                         \    |    /                             
                          \ f1|f1 /                             
                           \  |  /                             
                            \ | /                             
                             \|/                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D5(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[8][4] =
                {
		  {3, 7, 0, 1},
		  {7, 2, 0, 1},
		  {2, 9, 0, 1},
		  {9, 5, 0, 1},
		  {5, 6, 0, 1},
		  {6, 4, 0, 1},
		  {4, 8, 0, 1},
		  {8, 3, 0, 1}
		};
  const int	nElm = 8;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	void
* \ingroup      WlzTransform
* \brief	Debuging function for 2D mesh output in VTK format.
* \param	fP			Given file pointer.
* \param	mesh			Given mesh.
*/
void		WlzCMeshDbgOutVTK2D(FILE *fP, WlzCMesh2D *mesh)
{
  int		idE,
		idN,
		nElm,
		nVElm,
  		nNod;
  WlzCMeshElm2D  *elm;
  WlzCMeshNod2D	*nod;

  if(mesh && (mesh->type == WLZ_CMESH_TRI2D) &&
    ((nNod = mesh->res.nod.maxEnt) > 0) &&
    ((nElm = mesh->res.elm.maxEnt) > 0))
  {
    (void )fprintf(fP,
		   "# vtk DataFile Version 1.0\n"
		   "WlzCMesh2D 2D\n"
		   "ASCII\n"
		   "DATASET POLYDATA\n"
		   "POINTS %d float\n",
		   nNod);
    /* Output all nodes but use (0, 0, 0) for those that are invalid. */
    for(idN = 0; idN < nNod; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	(void )fprintf(fP, "%g %g 0\n",
		       nod->pos.vtX, nod->pos.vtY);
      }
      else
      {
	(void )fprintf(fP, "0 0 0\n");
      }
    }
    /* Output all valid mesh element simplices. */
    nVElm = 0;
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
        ++nVElm;
      }
    }
    (void )fprintf(fP, "POLYGONS %d %d\n",
		   nVElm, nVElm * 4);
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
	(void )fprintf(fP, "3 %d %d %d\n",
		       elm->edu[0].nod->idx, elm->edu[1].nod->idx, 
		       elm->edu[2].nod->idx);
      }
    }
  }
}

/*!
* \return	void
* \ingroup      WlzTransform
* \brief	Debuging function for 3D mesh output in VTK format.
* \param	fP			Given file pointer.
* \param	mesh			Given mesh.
*/
void		WlzCMeshDbgOutVTK3D(FILE *fP, WlzCMesh3D *mesh)
{
  int		idE,
		idF,
		idN,
		nElm,
		nVSpx,
  		nNod;
  WlzCMeshElm3D  *elm;
  WlzCMeshFace	*fce;
  WlzCMeshNod3D	*nod;

  if(mesh && (mesh->type == WLZ_CMESH_TET3D) &&
    ((nNod = mesh->res.nod.maxEnt) > 0) &&
    ((nElm = mesh->res.elm.maxEnt) > 0))
  {
    (void )fprintf(fP,
		   "# vtk DataFile Version 1.0\n"
		   "WlzCMesh3D 3D\n"
		   "ASCII\n"
		   "DATASET POLYDATA\n"
		   "POINTS %d float\n",
		   nNod);
    /* Output all nodes but use (0, 0, 0) for those that are invalid. */
    for(idN = 0; idN < nNod; ++idN)
    {
      nod = (WlzCMeshNod3D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	(void )fprintf(fP, "%g %g %g\n",
		       nod->pos.vtX, nod->pos.vtY, nod->pos.vtZ);
      }
      else
      {
	(void )fprintf(fP, "0 0 0\n");
      }
    }
    /* Output the faces of all valid mesh element simplices, but only one
     * face of an opposite face pair. This is done to reduce the number of
     * triangles in the output. */
    nVSpx = 0;
    /* First find number of faces. */
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
        for(idF = 0; idF < 4; ++idF)
	{
	  fce = elm->face + idF;
	  if((fce->opp == NULL) ||
	     (fce->opp == fce) ||
	     (fce->elm->idx < fce->opp->elm->idx))
	  {
            ++nVSpx;
	  }
	}
      }
    }
    /* Output faces using the same code as above to select the faces. */
    (void )fprintf(fP, "POLYGONS %d %d\n",
		   nVSpx, nVSpx * 4);
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
        for(idF = 0; idF < 4; ++idF)
	{
	  fce = elm->face + idF;
	  if((fce->opp == NULL) ||
	     (fce->opp == fce) ||
	     (fce->elm->idx < fce->opp->elm->idx))
	  {
	    (void )fprintf(fP, "3 %d %d %d\n",
			   fce->edu[0].nod->idx, fce->edu[1].nod->idx, 
			   fce->edu[2].nod->idx);
	  }
	}
      }
    }
  }
}

/*!
* \return	void
* ingroup	WlzTransform
* \brief	Debuging function for mesh output in VTK format.
* \param	fP			Given file pointer.
* \param	mesh			Given mesh.
*/
void		WlzCMeshDbgOutVTK(FILE *fP, WlzCMeshP mesh)
{
  if(mesh.v)
  {
    switch(mesh.m2->type)
    {
      case WLZ_CMESH_TRI2D:
        WlzCMeshDbgOutVTK2D(fP, mesh.m2);
	break;
      case WLZ_CMESH_TET3D:
        WlzCMeshDbgOutVTK3D(fP, mesh.m3);
        break;
      default:
        break;
    }
  }
}

#ifdef WLZ_CMESH_DEBUG_MAIN


extern char 	*optarg;
extern int 	optind,
		opterr,
		optopt;

int		main(int argc, char *argv[])
{
  int		idE,
  		nElm = 0,
  		ok = 1,
  		option,
  		usage = 0,
		features = 0,
		laplacianItr = 0,
		lowPassItr = 0,
		smoothBnd = 0,
		verify = 0;
  double	laplacianAlpha = 0.1,
		lowPassLambda = 0.33,
		lowPassMu = -0.34,
  		minElmSz = 25.0,
  		maxElmSz = 100.0;
  int		*idx = NULL;
  double	*vol = NULL,
  		*minLen = NULL,
		*maxLen = NULL;
  FILE		*fP = NULL;
  char		*inObjFileStr,
  		*outFileStr;
  const char	*errMsgStr;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  WlzObject	*obj = NULL;
  WlzCMeshP 	mesh;
  static char   optList[] = "a:BFhl:L:m:M:o:u:VW:";
  const char    inObjFileStrDef[] = "-",
  	        outFileStrDef[] = "-";

  mesh.v = NULL;
  opterr = 0;
  inObjFileStr = (char *)inObjFileStrDef;
  outFileStr = (char *)outFileStrDef;
  while((usage == 0) && ((option = getopt(argc, argv, optList)) != EOF))
  {
    switch(option)
    {
      case 'a':
	if(sscanf(optarg, "%lg", &laplacianAlpha) != 1)
	{
	  usage = 1;
	}
        break;
      case 'B':
        smoothBnd = 1;
	break;
      case 'F':
        features = 1;
	break;
      case 'l':
	if(sscanf(optarg, "%lg", &lowPassLambda) != 1)
	{
	  usage = 1;
	}
        break;
      case 'L':
	if(sscanf(optarg, "%d", &laplacianItr) != 1)
	{
	  usage = 1;
	}
        break;
      case 'm':
        if(sscanf(optarg, "%lg", &minElmSz) != 1)
	{
	  usage = 1;
	}
	break;
      case 'M':
        if(sscanf(optarg, "%lg", &maxElmSz) != 1)
	{
	  usage = 1;
	}
        break;
      case 'o':
        outFileStr = optarg;
	break;
      case 'u':
	if(sscanf(optarg, "%lg", &lowPassMu) != 1)
	{
	  usage = 1;
	}
        break;
      case 'W':
	if(sscanf(optarg, "%d", &lowPassItr) != 1)
	{
	  usage = 1;
	}
        break;
      case 'V':
        verify = 1;
	break;
      case 'h':
      default:
	usage = 1;
	break;
    }
  }
  ok = usage == 0;
  if(ok)
  {
    if((inObjFileStr == NULL) || (*inObjFileStr == '\0') ||
       (outFileStr == NULL) || (*outFileStr == '\0'))
    {
      ok = 0;
      usage = 1;
    }
    if(ok && (optind < argc))
    {
      if((optind + 1) != argc)
      {
        usage = 1;
        ok = 0;
      }
      else
      {
        inObjFileStr = *(argv + optind);
      }
    }
  }
  if(ok)
  {
    if((inObjFileStr == NULL) ||
       (*inObjFileStr == '\0') ||
       ((fP = (strcmp(inObjFileStr, "-")?
              fopen(inObjFileStr, "r"): stdin)) == NULL) ||
       ((obj = WlzAssignObject(WlzReadObj(fP, &errNum), NULL)) == NULL) ||
       (errNum != WLZ_ERR_NONE))
    {
      ok = 0;
      (void )fprintf(stderr,
                     "%s: failed to read object from file %s\n",
                     *argv, inObjFileStr);
    }
    if(fP && strcmp(inObjFileStr, "-"))
    {
      (void )fclose(fP); fP = NULL;
    }
  }
  if(ok)
  {
    (void )WlzAssignObject(obj, NULL);
    mesh = WlzCMeshFromObj(obj, minElmSz, maxElmSz, NULL, &errNum);
    if(errNum != WLZ_ERR_NONE)
    {
      ok = 0;
      (void )WlzStringFromErrorNum(errNum, &errMsgStr);
      (void )fprintf(stderr,
      		     "%s Failed to create conforming mesh, %s.\n",
      		     argv[0],
		     errMsgStr);
    }
  }
  if(ok)
  {
    WlzCMeshSetBoundNodFlags(mesh);
    if(verify)
    {
      errNum = WlzCMeshVerify(mesh, NULL, 1, stderr);
      if(errNum != WLZ_ERR_NONE)
      {
	ok = 0;
	(void )WlzStringFromErrorNum(errNum, &errMsgStr);
	(void )fprintf(stderr,
		       "%s Failed to verify mesh, %s.\n",
		       argv[0],
		       errMsgStr);
      }
    }
  }
  if(ok && (laplacianItr > 0))
  {
    errNum = WlzCMeshLaplacianSmooth(mesh, laplacianItr, laplacianAlpha,
    				     smoothBnd, 1);
    if((errNum == WLZ_ERR_NONE) && verify)
    {
      errNum = WlzCMeshVerify(mesh, NULL, 1, stderr);
    }
    if(errNum != WLZ_ERR_NONE)
    {
      ok = 0;
      (void )WlzStringFromErrorNum(errNum, &errMsgStr);
      (void )fprintf(stderr,
                     "%s Failed to Laplacian smooth mesh, %s.\n",
		     argv[0],
		     errMsgStr);
    }
  }
  if(ok && (lowPassItr > 0))
  {
    errNum = WlzCMeshLPFilterLM(mesh, lowPassLambda, lowPassMu,
    				lowPassItr, smoothBnd, 1);
    if((errNum == WLZ_ERR_NONE) && verify)
    {
      errNum = WlzCMeshVerify(mesh, NULL, 1, stderr);
    }
    if(errNum != WLZ_ERR_NONE)
    {
      ok = 0;
      (void )WlzStringFromErrorNum(errNum, &errMsgStr);
      (void )fprintf(stderr,
                     "%s Failed to low pass filter mesh, %s.\n",
		     argv[0],
		     errMsgStr);
    }
  }
  if(ok)
  {
    if((fP = (strcmp(outFileStr, "-")?
	     fopen(outFileStr, "w"): stdout)) == NULL)
    {
      ok = 0;
      (void )fprintf(stderr,
		     "%s: Failed to open output file %s.\n",
		     argv[0], outFileStr);
    }
  }
  if(ok && features)
  {
    errNum = WlzCMeshCmpElmFeat(mesh, &nElm, &idx, &vol, &minLen, &maxLen);
    if(errNum == WLZ_ERR_NONE)
    {
      for(idE = 0; idE < nElm; ++idE)
      {
        (void )printf("%d %lg %lg %lg\n",
	              *(idx + idE), *(vol + idE),
	              *(minLen + idE), *(maxLen + idE));
      }
    }
    else
    {
      ok = 0;
      (void )WlzStringFromErrorNum(errNum, &errMsgStr);
      (void )fprintf(stderr,
                     "%s Failed to compute mesh features, %s.\n",
		     argv[0],
		     errMsgStr);
    }
    AlcFree(idx);
    AlcFree(vol);
    AlcFree(minLen);
    AlcFree(maxLen);
  }
  if(ok)
  {
    WlzCMeshDbgOutVTK(fP, mesh);
  }
  if(fP && strcmp(outFileStr, "-"))
  {
    (void )fclose(fP); fP = NULL;
  }
  (void )WlzFreeObj(obj);
  if(usage)
  {
    fprintf(stderr,
            "Usage: %s [-h] [-o<output file>]\n"
	    "       [-L#] [-a#] [-W#] [-l#] [-u#] [-B]\n"
	    "       [-m#] [-M#] [-F] [-V] [<input object>]\n"
    	    "Computes a conforming mesh for the given input object.\n"
	    "Options are:\n"
	    "  -h  Help, prints this usage message.\n"
	    "  -o  Output file.\n"
	    "  -L  Number of Laplacian smoothing iterations.\n"
	    "  -a  Laplacian alpha parameter.\n"
	    "  -W  Number of low pass filter smoothing iterations.\n"
	    "  -l  Low pass filter lambda value.\n"
	    "  -u  Low pass filter mu value.\n"
	    "  -B  Smooth boundary (requires a smoothing method to be\n"
	    "      selected).\n"
	    "  -m  Minimum mesh element size.\n"
	    "  -M  Maximum mesh element size.\n"
	    "  -F  Prints features of the mesh elements to the standard\n"
	    "      output.\n"
	    "  -V  Verify mesh. This may take a long time and may give\n"
	    "      segmentation faults for buggy meshes.\n",
	    argv[0]);

  }
  return(!ok);
}
#endif /* WLZ_CMESH_DEBUG_MAIN */
