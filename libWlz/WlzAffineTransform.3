.\" ident MRC HGU $Id$
.\""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.\" Project:    Woolz
.\" Title:      WlzAffineTransform.3
.\" Date:       March 2000
.\" Author:     Richard Baldock, Bill Hill
.\" Copyright:	2000 Medical Research Council, UK.
.\"		All rights reserved.
.\" Address:	MRC Human Genetics Unit,
.\"		Western General Hospital,
.\"		Edinburgh, EH4 2XU, UK.
.\" Purpose:    Functions for computing Woolz affine transforms and
.\"		applying them to Woolz objects.
.\" $Revision$
.\" Maintenance:Log changes below, with most recent at top of list.
.\""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.tr ~ 
.TH "WlzAffineTransform" 3 "%G%" "MRC HGU Woolz" "Woolz Procedure Library"
.SH NAME \
WlzAffineTransformFromMatrix, \
WlzAffineTransformFromTranslation, \
WlzAffineTransformFromScale, \
WlzAffineTransformFromRotation, \
WlzAffineTransformFromPrimVal, \
WlzAffineTransformFromPrim, \
WlzAffineTransformFromSpin, \
WlzAffineTransformFromSpinSqueeze, \
WlzAffineTransformProduct, \
WlzAffineTransformInverse, \
WlzAffineTransformCopy, \
WlzAffineTransformDimension, \
WlzAffineTransformIsTranslate, \
WlzAffineTransformIsIdentity, \
WlzAffineTransformObj, \
WlzAffineTransformVertexD2, \
WlzAffineTransformVertexD3, \
WlzAffineTransformVertexF2, \
WlzAffineTransformVertexF3, \
WlzAffineTransformVertexI2, \
WlzAffineTransformVertexI3, \
WlzAffineTransformPrimGet, \
WlzAffineTransformMatrixSet, \
WlzAffineTransformTranslationSet, \
WlzAffineTransformScaleSet, \
WlzAffineTransformRotationSet, \
WlzAffineTransformPrimValSet, \
WlzAffineTransformPrimSet \- \
Data structures and functions for computing Woolz affine transforms and \
applying them to Woolz data structures and objects.
.SH SYNOPSIS
.LP
.B #include <Wlz.h>
.LP
.BI "WlzAffineTransform *WlzAffineTransformFromMatrix(WlzTransformType " type ,
.in +10m
.br
.BI "double **" arrayMat ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzAffineTransform *WlzAffineTransformFromTranslation(WlzTransformType " type ,
.in +10m
.br
.BI "double " tX ,
.BI "double " tY ,
.BI "double " tZ ,
.br
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzAffineTransform *WlzAffineTransformFromScale(WlzTransformType " type ,
.in +10m
.br
.BI "double " sX ,
.BI "double " sY ,
.BI "double " sZ ,
.br
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzAffineTransform *WlzAffineTransformFromRotation(WlzTransformType " type ,
.in +10m
.br
.BI "double " rX ,
.BI "double " rY ,
.BI "double " rZ ,
.br
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzAffineTransform *WlzAffineTransformFromPrimVal(WlzTransformType " type ,
.in +10m
.br
.BI "double " trX ,
.BI "double " trY ,
.BI "double " trZ ,
.br
.BI "double " trScale ,
.BI "double " trTheta ,
.BI "double " trPhi ,
.br
.BI "double " trAlpha ,
.BI "double " trPsi ,
.BI "double " trXsi ,
.br
.BI "int " trInvert ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzAffineTransform *WlzAffineTransformFromPrim(WlzAffineTransformPrim " prim );
.LP
.BI "WlzAffineTransform *WlzAffineTransformFromSpin(double " spX ,
.in +10m
.br
.BI "double " spY ,
.BI "double " spTheta ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzAffineTransform *WlzAffineTransformFromSpinSqueeze(double " spX ,
.in +10m
.br
.BI "double " spY ,
.BI "double " spTheta  ,
.BI "double " sqX ,
.br
.BI "double " sqY ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzAffineTransform *WlzAffineTransformProduct(WlzAffineTransform *" trans0 ,
.in +10m
.br
.BI "WlzAffineTransform *" trans1 ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzAffineTransform *WlzAffineTransformInverse(WlzAffineTransform *" tr ,
.in +10m
.br
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzAffineTransform *WlzAffineTransformCopy(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "int WlzAffineTransformDimension(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "int WlzAffineTransformIsTranslate(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzObject *" obj ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "int WlzAffineTransformIsIdentity(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzObject *WlzAffineTransformObj(WlzObject *" srcObj ,
.in +10m
.br
.BI "WlzAffineTransform *" tr ,
.BI "WlzInterpolationType " interp ,
.br
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzDVertex2 WlzAffineTransformVertexD2(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzDVertex2 " srcVtx ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzDVertex3 WlzAffineTransformVertexD3(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzDVertex3 " srcVtx ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzFVertex2 WlzAffineTransformVertexF2(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzFVertex2 " srcVtx ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzFVertex3 WlzAffineTransformVertexF3(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzFVertex3 " srcVtx ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzIVertex2 WlzAffineTransformVertexI2(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzIVertex2 " srcVtx ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzIVertex3 WlzAffineTransformVertexI3(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzIVertex3 " srcVtx ,
.BI "WlzErrorNum *" dstErr );
.in -10m
.LP
.BI "WlzErrorNum WlzAffineTransformPrimGet(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzAffineTransformPrim *" prim );
.in -10m
.LP
.BI "WlzErrorNum WlzAffineTransformMatrixSet(WlzAffineTransform *" tr ,
.in +10m
.BI "double **" arrayMat );
.in -10m
.LP
.BI "WlzErrorNum WlzAffineTransformTranslationSet(WlzAffineTransform *" tr ,
.in +10m
.BI "double " tX ,
.BI "double " tY ,
.BI "double " tZ );
.in -10m
.LP
.BI "WlzErrorNum WlzAffineTransformScaleSet(WlzAffineTransform *" tr ,
.in +10m
.BI "double " sX ,
.BI "double " sY ,
.BI "double " sZ );
.in -10m
.LP
.BI "WlzErrorNum WlzAffineTransformRotationSet(WlzAffineTransform *" tr ,
.in +10m
.BI "double " rX ,
.BI "double " rY ,
.BI "double " rZ );
.in -10m
.LP
.BI "WlzErrorNum WlzAffineTransformPrimValSet(WlzAffineTransform *" tr ,
.in +10m
.BI "double " trX ,
.BI "double " trY ,
.BI "double " trZ ,
.br
.BI "double " trScale ,
.BI "double " trTheta ,
.BI "double " trPhi ,
.br
.BI "double " trAlpha ,
.BI "double " trPsi ,
.BI "double " trXsi ,
.br
.BI "int " trInvert );
.in -10m
.LP
.BI "WlzErrorNum WlzAffineTransformPrimSet(WlzAffineTransform *" tr ,
.in +10m
.BI "WlzAffineTransformPrim " prim );
.in -10m
.SP 1
.ps -2
.cs R 24
.nf
typedef enum
{
  WLZ_TRANSFORM_2D_AFFINE = 1,                /* General 2D affine transform */
  WLZ_TRANSFORM_2D_REG,       /* 2D affine but only rotation and translation */
  WLZ_TRANSFORM_2D_TRANS,                  /* 2D affine but only translation */
  WLZ_TRANSFORM_2D_NOSHEAR,                        /* 2D affine but no shear */
  WLZ_TRANSFORM_3D_AFFINE,                    /* General 3D affine transform */
  WLZ_TRANSFORM_3D_REG,       /* 3D affine but only rotation and translation */
  WLZ_TRANSFORM_3D_TRANS,                  /* 3D affine but only translation */
  WLZ_TRANSFORM_3D_NOSHEAR,                        /* 3D affine but no shear */
  .
  .
  .
} WlzTransformType;
.fi
.cs R
.ps +2
.SP 1
.ps -2
.cs R 24
.nf
typedef struct _WlzAffineTransform
{
  WlzTransformType type;
  int           linkcount;
  void          *freeptr;
  double        **mat;
} WlzAffineTransform;
.fi
.cs R
.ps +2
.SP 1
A Woolz affine transform is defined by a homogeneous matrix array (\fImat\fR).
For 2D transforms this is used as a 3x3 matrix and for 3D transforms as a 4x4
matrix. The array is always allocated as a 4x4 AlcDouble2Alloc array.
.SP 1
.ps -2
.cs R 24
.nf
typedef struct _WlzAffineTransformPrim
{
  double        tx,                                         /* X translation */
                ty,                                         /* Y translation */
                tz,                                         /* Z translation */
                scale,                               /* Scale transformation */
                theta,                              /* Rotation about z-axis */
                phi,                                /* Rotation about y-axis */
                alpha,                                     /* Shear strength */
                psi,                             /* Shear angle in x-y plane */
                xsi;                                       /* 3D shear angle */
  int           invert;               /* Non-zero if reflection about y-axis */
} WlzAffineTransformPrim;
.fi
.cs R
.ps +2
.SP 1
The primitives data structure provides a convinient method of accessing the
transform primitives.
.SH ARGUMENTS
.TS
tab(^);
lI l.
dstErrNum^destination pointer for error number, may be null.
interp^level of interpolation to use
obj^Woolz object
prim^affine transform primitives
rx^rotation about the x-axis, ignored for 2D transforms
ry^rotation about the y-axis, ignored for 2D transforms
rz^rotation about the z-axis
spTheta^spin rotation about centre
spX^spin centre column (x)
spY^spin centre line (y)
sqX^squeeze (x) factor
sqY^squeeze (y) factor
srcVtx^vertex to be transformed
sx^scale along the x-axis
sy^scale along the y-axis
sz^scale along the z-axis
tr^affine transform
trAlpha^shear strength
trInvert^reflection about y-axis if non-zero
trPhi^rotation about y-axis
trPsi^shear angle in x-y plane
trScale^total scale transformation
trTheta^rotation about z-axis
trX^translation along the x-axis
trXsi^3D shear angle
trY^translation along the y-axis
trZ^translation along the z-axis
.TE
.SH MT-LEVEL
.LP
Safe
.SH DESCRIPTION
These functions and data structures enable Woolz affine transforms to be
computed, manipulated and applied to Woolz objects.
.LP
.B WlzAffineTransformDimension
computes the dimension of the given affine transform and returns an integer
with the value 2 or 3 for a 2D or 3D affine transform, 0 on error.
.LP
.B WlzAffineTransformIsTranslate
tests whether the given affine transform is a simple integer translation and
returns non-zero if it is.
.LP
.B WlzAffineTransformPrimSet
sets the given transform's matrix from an affine transform primitives data
structure.
A composite transform is built from the primitives
with the order of composition being scale (applied first),
shear, rotation and then translation (applied last), ie:
.in +8m
.B A = T.R.Sh.Sc,~x' = A.x
.in -8m
.LP
.B WlzAffineTransformTranslationSet
sets the given transform's matrix from the given translations.
.LP
.B WlzAffineTransformFromTranslation
creates a new affine transform from the given translations.
.LP
.B WlzAffineTransformScaleSet
sets the given transform's matrix from the given scales.
.LP
.B WlzAffineTransformFromScale
creates a new affine transform from the given scales.
.LP
.B WlzAffineTransformRotationSet
sets the given transform's matrix from the given
rotations. Although the 3 rotations contain redundant
information this may be a useful method for setting
rotation transforms. The order of composition is
.in +8m
.B R = Rz.Ry.Rx, x' = R.x.
.in -8m
.LP
.B WlzAffineTransformFromRotation
creates a new affine transform from the given rotations, see
\fBWlzAffineTransformRotationSet\fR
for the order of composition.
.LP
.B WlzAffineTransformPrimGet
gets the given 2D transform's primitives.
.LP
.B WlzAffineTransformMatrixSet
sets the given transform from the given matrix.
.LP
.B WlzAffineTransformFromMatrix
creates a new affine transform from the given matrix.
.LP
.B WlzAffineTransformPrimValSet
sets an affine transform from the given primitive values.
.LP
.B WlzAffineTransformFromPrimVal
creates a new affine transform from the given primitive values.
.LP
.B WlzAffineTransformFromSpin
creates a new 2D affine transform from the given spin angle and centre of
rotation.
.LP
.B WlzAffineTransformFromSpinSqueeze
creates a new 2D affine transform from the given spin angle, centre of rotation
and scale factors.
.LP
.B WlzAffineTransformCopy
copies the given affine transform.
.LP
.B WlzAffineTransformProduct
computes the product of the two given affine transforms.
.LP
.B WlzAffineTransformInverse
computes the inverse of the given affine transform.
.LP
.B WlzAffineTransformIsIdentity
checks whether the given transform is an identity transform and returns
a non-zero value if it is  an identity transform.
.LP
.B WlzAffineTransformObj
applies the given affine transform to the given Woolz object.
.LP
.B WlzAffineTransformVertexI2
transforms the given WlzIVertex2 vertex.
.LP
.B WlzAffineTransformVertexI3
transforms the given WlzIVertex3 vertex.
.LP
.B WlzAffineTransformVertexF2
transforms the given WlzFVertex2 vertex.
.LP
.B WlzAffineTransformVertexF3
transforms the given WlzFVertex3 vertex.
.LP
.B WlzAffineTransformVertexD2
transforms the given WlzDVertex2 vertex.
.LP
.B WlzAffineTransformVertexD3
transforms the given WlzDVertex3 vertex.
.SH EXAMPLES
.LP
.ps -2
.cs R 24
.nf
/*
 * Simple example of using WlzAffineTransformObj() to translate an object
 * in the x-y plane.
 */

#include <stdio.h>
#include <stdlib.h>
#include <Wlz.h>

int	        main(char *argv[], int argc)
{
  WlzObject     *inObj = NULL,
                *outObj = NULL;
  WlzAffineTransform *tr = NULL;
  double	tx = 300,
  		ty = 400;
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  if((inObj= WlzReadObj(stdin, &errNum)) == NULL)
  {
    (void )fprintf(stderr, "%s: Failed to read input object.\\n", *argv);
  }
  else if(((tr = WlzAffineTransformFromTranslation( WLZ_TRANSFORM_2D_AFFINE,
  			tx, ty, 0.0, &errNum)) == NULL) ||
          (errNum != WLZ_ERR_NONE))
  {
    (void )fprintf(stderr, "%s: Failed to create affine transform.n", *argv);
  }
  else if((outObj = WlzAffineTransformObj(inObj, tr,
  					  WLZ_INTERPOLATION_NEAREST,
  					  &errNum)) == NULL) ||
          (errNum != WLZ_ERR_NONE))
  {
    (void )fprintf(stderr, "%s: Failed to transform object.\\n", *argv);
  }
  else if((errNum = WlzWriteObj(stdout, outObj)) != WLZ_ERR_NONE)
  {
    (void )fprintf(stderr, "%s: Failed to write output object.\\n", *argv);
  }
  return(errNum);
}
.fi
.cs R
.ps +2
.SH SEE ALSO
Alc(3), WlzError(3)
.SH BUGS
Still to be found.
