'\" te
.\" ident MRC HGU $Id$
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.\" Project:    Woolz
.\" Title:      WlzHistogram.3
.\" Date:       March 1999
.\" Author:     Bill Hill
.\" Copyright:	1999 Medical Research Council, UK.
.\"		All rights reserved.
.\" Address:	MRC Human Genetics Unit,
.\"		Western General Hospital,
.\"		Edinburgh, EH4 2XU, UK.
.\" Purpose:    Woolz functions which compute, transform and use
.\"		histograms.
.\" $Revision$
.\" Maintenance:Log changes below, with most recent at top of list.
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.nh
.TH "WlzHistogram" 3 "MRC HGU Woolz" "Woolz Procedure Library"
.SH NAME
WlzHistogramObj,
WlzHistogramCopy,
WlzHistogramCummulative,
WlzHistogramDistance,
WlzHistogramEqualiseObj
WlzHistogramMapValues,
WlzHistogramMatchObj,
WlzHistogramNorm,
WlzHistogramRebin,
WlzHistogramSmooth, \- Woolz functions which compute, transform and
apply histograms.
.SH SYNOPSIS
.LP
.B #include <Wlz.h>
.LP
.BI "WlzObject *WlzHistogramObj(WlzObject *" "srcObj" ,
.in +4m
.BI "int *" "nBins" ,
.BI "double " "origin" ,
.br
.BI "double " "binSize" ,
.BI "WlzErrorNum *" "dstErrNum" );
.in -4m
.LP
.BI "WlzObject *WlzHistogramCopy(WlzObject *" "srcHistObj" ,
.in +4m
.br
.BI "WlzObjectType " "dstHistType" ,
.BI "WlzErrorNum *" "dstErrNum" );
.in -4m
.LP
.BI "WlzErrorNum WlzHistogramCummulative(WlzObject *" "histObj" );
.LP
.BI "double WlzHistogramDistance(WlzObject *" "histObj0" ,
.in +4m
.br
.BI "WlzObject *" "histObj1" ,
.BI "WlzErrorNum *" "dstErrNum" );
.in -4m
.LP
.BI "WlzErrorNum WlzHistogramEqualiseObj(WlzObject *" "srcObj" ,
.in +4m
.br
.BI "int " "smoothing" );
.in -4m
.LP
.BI "WlzErrorNum WlzHistogramMapValues(WlzObject *" "srcObj" ,
.in +4m
.br
.BI "WlzObject *" "mapHistObj" );
.in -4m
.LP
.BI "WlzErrorNum WlzHistogramMatchObj(WlzObject *" "srcObj" ,
.in +4m
.br
.BI "WlzObject *" "targetHist" ,
.BI "int " "independentPlanes" ,
.br
.BI "int " "smoothing" ,
.BI "double " "minDist" , 
.br
.BI "double " "maxDist" );
.in -4m
.LP
.BI "WlzErrorNum WlzHistogramNorm(WlzObject *" histObj ,
.in +4m
.br
.BI "double " "maxVal" );
.in -4m
.LP
.BI "WlzObject *WlzHistogramRebin(WlzObject *" srcHistObj ,
.in +4m
.br
.BI "WlzObjectType " "dstHistType" ,
.BI "int " "maxBins" ,
.br
.BI "int " "nBins" ,
.BI "double " "origin" ,
.br
.BI "double " "binSize" ,
.BI "WlzErrorNum *" "dstErrNum" );
.in -4m
.LP
.BI "WlzErrorNum WlzHistogramSmooth(WlzObject *" "histObj" ,
.in +4m
.br
.BI "int " "smoothing" );
.in -4m
.SH ARGUMENTS
.TS
tab(^);
lI l.
binSize^histogram bin width.
dstErrNum^destination pointer for error number.
dstHistType^type for new histogram domain.
histObj^histogram object.
histObj0^first histogram object.
histObj1^second histogram object.
independentPlanes^independent planes flag.
mapHistObj^histogram object for mapping grey values.
maxBins^number of histogram bins allocated.
maxDist^maximum distance.
maxVal^maximum value after normalisation.
minDist^minimum distance.
nBins^number of histogram bins.
origin^lowest grey value in first histogram bin.
smoothing^parameter for Gaussian smoothing of histogram.
srcHistObj^source histogram object.
srcObj^source domain object.
.TE
.SH MT-LEVEL
.LP
Safe
.SH DESCRIPTION
.LP
.B WlzHistogramObj
constructs a Woolz histogram object with integral
bin values from the given 2D or 3D domain object.
If the specified number of histogram bins is zero
then the number of bins, the origin and the bin size
are computed as follows:
.br
.in +4m
.TS
tab(^);
l l l.
nBins ^ = ^ ceil(max(g) - min(g) + 1.0)
origin ^ = ^ min(g)
binSize ^ = ^ 1.0
.TE
.in -4m
where max(g) and min(g) are the maximum and minimum grey values in
the domain object.
The given domain object is not modified.
.LP
.B WlzHistogramCopy
creates a new histogram object
with the specified type of bin values.
The bin values of the new histogram object are copied from the given
histogram object.
The bin values can either be integral (\fBWLZ_HISTOGRAMDOMAIN_INT\fR) or
double precision floating point (\fBWLZ_HISTOGRAMDOMAIN_FLOAT\fR).
The given histogram object is not modified.
.LP
.B WlzHistogramCummulative
modifies the given histogram object's
bin values so that they are cummulative.
.LP
.B WlzHistogramDistance
computes a distance measure from the two
given histogram objects.
The histogram distance is in the range [0.0 - 1.0],
with 1.0 being a perfect match between the histograms.
The given histogram objects are not modified.
.LP
.B WlzHistogramEqualiseObj
modifies the grey values of the given 2D or 3D domain object so that the
resulting object's histogram approximates a uniform histogram.
If the specified smoothing parameter is non-zero then
\fBWlzHistogramSmooth\fR is called with the smoothing parameter
to produce a smoothed copy of the given histogram object
before histogram equalisation.
The given histogram object is not modified.
.LP
.B WlzHistogramMapValues
uses the given mapping histogram,
which must have integral (\fBWLZ_HISTOGRAMDOMAIN_INT\fR) bins,
to remap the grey values of the given 2D or 3D domain object.
The mapping histogram \fMUST\fR have integral bin values
and bins appropriate for all domain object grey values,
because the histogram bin values are used as a look\-up table
indexed by grey value - histogram offset.
The given histogram object is not modified.
.LP
.B WlzHistogramMatchObj
modifies the grey values of the given 2D or 3D domain object so that the
resulting object's histogram matches the target histogram object.
If the given domain object is a 3D object and the
independent planes flag is set (non\-zero) then each of the 3D
object's planes is matched independently.
A domain object or plane will only be matched to the
given histogram if the distance between it's histogram
and the given target histogram is within the given
histogram distance range.
If the specified smoothing parameter is non\-zero then the object or plane's
histogram is smoothed by calling \fBWlzHistogramSmooth\fR with the smoothing
parameter.
If the given minimum distance is <= 0.0 and the maximum distance is >= 1.0
then matching will always be done.
The given target histogram is not modified.
.LP
.B WlzHistogramNorm
normalises the bin values of the given histogram object to the
range [0.0 - maxVal].
If maxVal is 0.0 then the histogram bin values are
normalised so that maxVal is equal to histograms upper bound, that is:
.in +4m
.TS
tab(^);
l l l.
maxVal ^ = ^ origin + (binSize * (nBins - 1))
.TE
.in -4m
.LP 
.B WlzHistogramRebin
creates a new histogram object
with the specified type of bin values,
number of bins, origin and bin size.
\fBWlzHistogramCopy\fR will copy a histogram object
more efficiently because it does not rebin the
histogram.
The given histogram object is not modified.
.LP
.B WlzHistogramSmooth
low pass filters the given histogram object's bin values by convolving them
with a Gaussian kernel in the space domain.
The kernel is symetric, normalised to an area of 1.0
and has a width three times the given filter width. 
The width parameter is the Gaussian kernel half\-height full\-width.
.SH EXAMPLES
.LP
.ps -2
.cs R 24
.nf
/* Simple example using a Woolz histogram object:
 * A histogram is computed from a 2D or 3D domain object read
 * from the standard input.
 * The histogram is written as ascii data to the standard output
 * both before and after smoothing.
 */

#include <stdio.h>
#include <stdlib.h>
#include <Wlz.h>

static void     PrintHistogram(WlzObject *histObj)
{
  int           idx;
  WlzHistogramDomain *histDom;

    histDom = histObj->domain.hist;
    for(idx = 0; idx < histDom->nBins; ++idx)
    {
      printf("%8g %8d\\n",
             histDom->origin + (idx * histDom->binSize),
             *(histDom->binValues.inp + idx));
    }
    printf("\\n");
}

int             main(char *argv[], int argc)
{
  WlzObject     *domObj = NULL,
                *histObj = NULL;
  WlzErrorNum   errNum = WLZ_ERR_NONE;
 
  if((domObj = WlzAssignObject(WlzReadObj(stdin, &errNum), NULL)) == NULL)
  {
    (void )fprintf(stderr, "%s: failed to read object.\\n",
                   argv[0]);
  }
  else if(((domObj->type != WLZ_2D_DOMAINOBJ) &&
           (domObj->type != WLZ_3D_DOMAINOBJ)) ||
          (domObj->domain.core == NULL) ||
          (domObj->values.core == NULL))
  {
    (void )fprintf(stderr, "%s: Inappropriate object type.\\n",
                   argv[0]);
    errNum = INVALID_OBJECT_TYPE;
  }
  else
  {
    histObj = WlzAssignObject(WlzHistogramObj(domObj, 0, 0.0, 1.0,
                              &errNum), NULL);
    if((histObj == NULL) || (errNum != WLZ_ERR_NONE))
    {
      (void )fprintf(stderr,
                     "%s: Failed to compute histogram object.\\n",
                     argv[0]);
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {           
    PrintHistogram(histObj);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzHistogramSmooth(histObj, 5);
    if(errNum != WLZ_ERR_NONE)
    {
      (void )fprintf(stderr,
                     "%s: Failed to smooth histogram object.\\n",
                     argv[0]);
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {           
    PrintHistogram(histObj);
  }
  if(domObj)
  {
    WlzFreeObj(domObj);
  }
  if(histObj)
  {
    WlzFreeObj(histObj);
  }
  return(errNum);
}

.fi
.cs R
.ps +2
.SH SEE ALSO
WlzHistogramObj(1), WlzHistogramData(1),
WlzHistogramEqualiseObj(1), WlzHistogramMatchObj(1),
WlzHistogramRebin(1), WlzHistogramSmooth(1),
WlzError(3)
.SH BUGS
Still to be found.
