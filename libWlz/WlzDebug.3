'\" t
.\" ident MRC HGU $Id$
.\""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.\" Project:    Woolz
.\" Title:      WlzDebug.3
.\" Date:       March 1999
.\" Author:     Bill Hill
.\" Copyright:	1999 Medical Research Council, UK.
.\"		All rights reserved.
.\" Address:	MRC Human Genetics Unit,
.\"		Western General Hospital,
.\"		Edinburgh, EH4 2XU, UK.
.\" Purpose:    Woolz debug functions.
.\" $Revision$
.\" Maintenance:Log changes below, with most recent at top of list.
.\""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.TH WlzDebug 3 "13th November 1996" "MRC HGU Woolz" "Woolz Procedure Library"
.SH NAME
WLZ_DBG, WLZ_DBGOBJ, WlzDbgWrite, WlzDbgObjWrite \- macros and procedures to
write debug messages.
.SH SYNOPSIS
.nf
.sp
#include <Wlz.h>
extern WlzDbgMask	wlzDbgMask, wlzDbgObjMask;
extern void		*wlzDbgData, *wlzDbgObjData;
extern WlzDbgFn		wlzDbgOutFn;
extern WlzDbgObjFn	wlzDbgOutOutFn;

WlzErrorNum	WlzDbgWrite(char *fmt, ...);

WlzErrorNum	WlzDbgObjWrite(WlzObject *obj, int freeFlg);

#define WLZ_DBG(F,M) \
		      ((((F)&(wlzDbgMask))==(F))?(*wlzDbgOutFn) M:WLZ_ERR_NONE)

#define WLZ_DBGOBJ(F,O,X) \
	 ((((F)&(wlzDbgObjMask))==(F))?(*wlzDbgOutObjFn)((O),(X)):WLZ_ERR_NONE)


.fi
.SH ARGUMENTS
.LP
.BI " " fmt "		Format for printing message."
.BI " " ... "		Varargs function."
.BI " " obj "		Woolz debug object for output."
.BI " " freeFlg "	Object free flag."
.LP
.SH MT-LEVEL
.LP
Unsafe
.SH DESCRIPTION
.LP
Convenience macros and procedures for printing debug messages. The
behavior of the debug messaging procedures is governed by a number of
external parameters which can be redefined. There are two debug channels,
*wlzDbgData and *wlzDbgObjData for text and woolz object data respectively.
By default these are stderr and stdout respectively. The output to these
channels is controlled by the masks wlzDbgMask and wlzDbgObjMask. Each debug
statement in the code will only be executed if the mask associated with the
statement is a subset of the corresponding global debug mask which can be set
dynamically within an interactive program to enable debugging "on the fly".
By default these masks are zero. The debug masks are combinations of:
.nf
.sp
	WLZ_DBG_NONE:		No debug output
	WLZ_DBG_LVL_1		Least debug output
	WLZ_DBG_LVL_2		Intermediate debug output
	WLZ_DBG_LVL_3		Most debug output
	WLZ_DBG_LVL_FN		Function entry and return
	WLZ_DBG_ALLOC		Allocation and freeing

.fi
.LP
The macros WLZ_DBG and WLZ_DBGOBJ use the functions set by the variables
wlzDbgOutFn and wlzDbgOutOutFn respectively which can be reset to enable
arbitrary debug message trapping and redisplay within an interactive
program.
.LP
.I WlzDbgWrite,
default procedure for printing the debug message to the file pointer
*wlzDbgData which has default value stderr. fmt is the format string for
the debug message and the varargs argument ... is for all the remaining
arguments. This procedure should not be used directly but via the macro
WLZ_DBG which can be redefined and "compiled out" for optimisation.
.I WlzDbgObjWrite,
write the given object to the file pointer defined by *wlzDbgObjData
(default stdout) and free it if freeFlg is non-zero. This procedure should
not be called directly but via the macro WLZ_DBGOBJ.
.I WLZ_DBG,
checks the debug flag against the global flag and if the corresponding
bits are set calls the debug function wlzDbgOutFn with the arguments
defined by the second macro argument. Note this argument must be in
parentheses (see example below) and match the arguments to WlzDbgWrite.
.I WLZ_DBGOBJ,
as for WLZ_DBG but now the macro has three arguments with the second and
third matching the arguments required for WlzDbgObjWrite.
.SH EXAMPLES
.LP
The following statements will write to the stderr information about the
given object provided at some point the variable wlzDbgMask has been set:
.nf
.sp
	wlzDbgMask = WLZ_DBG_ALLOC|WLZ_DBG_LVL_FN|WLZ_DBG_LVL_1;
	*wlzDbgData = (void *) stderr;
.
.
.
	WLZ_DBG((WLZ_DBG_ALLOC|WLZ_DBG_LVL_1),
		("WlzFreeObj FE 0x%lx\n",
		(unsigned long )obj));

.fi
note the parentheses around the second macro argument.
.SH SEE ALSO

.SH BUGS

